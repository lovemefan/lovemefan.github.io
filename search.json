[{"title":"Ubuntu19 下使用pip安装好包以后，在Pycharm中依然无法使用的解决办法","url":"/post/其他/Ubuntu19 下使用pip安装好包以后，在Pycharm中依然无法使用的解决办法/index.html  2020/03/06/其他/Ubuntu19 下使用pip安装好包以后，在Pycharm中依然无法使用的解决办法/","content":"# Ubuntu19 下使用pip安装好包以后，在Pycharm中依然无法使用的解决办法\n\n## 问题原因\n由于pip安装的包与系统下python interpreter 下的包目录不一致,导致pycharm中无法识别相关包,\n\n## 解决办法\n\n1. 如下找不到pip安装的包\n![mark](http://pan-lovemefan.oss-cn-shenzhen.aliyuncs.com/blog/20200306/142844861.png)\n\n2. 使用pip show 或者pip install查看包安装路径\n![mark](https://pan-lovemefan.oss-cn-shenzhen.aliyuncs.com/blog/20200306/143614507.png)\n\n3. 在pycharm中查看python library所在路径\n![mark](http://pan-lovemefan.oss-cn-shenzhen.aliyuncs.com/blog/20200306/145200393.png)\n4. 将pip安装路径的包复制到python library中,这样ubunut下pycharm就能识别出包了","tags":["其他"]},{"title":"计算机网络","url":"/post/408/计算机网络/index.html  2019/12/05/408/计算机网络/","content":"# 第 1 章   概述\n## 计算机网络在信息时代中的作用\n### 21 世纪的一些重要特征就是数字化、网络化和信息化，它是一个以网络为核心的信息时代。\n### 网络现已成为信息社会的命脉和发展知识经济的重要基础。\n### 网络是指“三网”，即电信网络、有线电视网络和计算机网络。\n### 发展最快的并起到核心作用的是计算机网络。\n### 因特网(Internet)的发展\n* 进入 20 世纪 90 年代以后，以因特网为代表的计算机网络得到了飞速的发展。\n* 已从最初的教育科研网络逐步发展成为商业网络。\n* 已成为仅次于全球电话网的世界第二大网络。 \n### 因特网的意义\n* 因特网是自印刷术以来人类通信方面最大的变革。\n* 现在人们的生活、工作、学习和交往都已离不开因特网。 \n## 因特网概述\n###  网络的网络\n* 起源于美国的因特网现已发展成为世界上最大的国际性计算机互联网 \n* 网络(network)由若干结点(node)和连接这些结点的链路(link)组成。 \n* 互联网是“网络的网络”(network of networks)。 \n* 连接在因特网上的计算机都称为主机(host)。 \n* 网络与因特网\n    * 网络把许多计算机连接在一起。\n    * 因特网则把许多网络连接在一起。\n### 因特网发展的三个阶段\n* 第一阶段是从单个网络 ARPANET 向互联网发展的过程。\n    * 1983 年 TCP/IP 协议成为 ARPANET 上的标准协议。\n    * 人们把 1983 年作为因特网的诞生时间。\n* 第二阶段的特点是建成了三级结构的因特网。\n    * 三级计算机网络，分为主干网、地区网和校园网（或企业网）。 \n* 第三阶段的特点是逐渐形成了多层次 ISP 结构的因特网。\n    * 出现了因特网服务提供者 ISP (Internet Service Provider)。  \n    * 根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。\n### 因特网的标准化工作\n* 制订因特网的正式标准要经过以下的四个阶段 \n    * 因特网草案(Internet Draft) ——在这个阶段还不是 RFC 文档。\n    * 建议标准(Proposed Standard) ——从这个阶段开始就成为 RFC 文档。\n    * 草案标准(Draft Standard)\n    * 因特网标准(Internet Standard) \n* 各种RFC之间的关系\n### 计算机网络在我国的发展\n## 因特网的组成\n### 因特网的边缘部分\n* 由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。\n    * 处在因特网边缘的部分就是连接在因特网上的所有的主机。这些主机又称为端系统(end system)。\n    *  “主机 A 和主机 B 进行通信”，实际上是指：“运行在主机 A 上的某个程序和运行在主机 B 上的另一个程序进行通信”。\n    * 即“主机 A 的某个进程和主机 B 上的另一个进程进行通信”。或简称为“计算机之间通信” \n### 因特网的核心部分\n* 由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（提供连通性和交换）\n    * 网络核心部分是因特网中最复杂的部分。\n    * 网络中的核心部分要向网络边缘中的大量主机提供连通性，使边缘部分中的任何一个主机都能够向其他主机通信（即传送或接收各种形式的数据）。\n    * 在网络核心部分起特殊作用的是路由器(router)。\n        * 路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。\n            * 在路由器中的输入和输出端口之间没有直接连线。\n            * 路由器处理分组的过程是：\n                * 把收到的分组先放入缓存（暂时存储）；\n                * 查找转发表，找出到某个目的地址应从哪个端口转发；\n                * 把分组送到适当的端口转发出去。 \n    * 路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 \n## 计算机网络在我国的发展\n### (1) 中国公用计算机互联网 CHINANET\n### (2) 中国教育和科研计算机网 CERNET\n### (3) 中国科学技术网 CSTNET\n### (4) 中国联通互联网 UNINET\n### (5) 中国网通公用互联网 CNCNET\n### (6) 中国国际经济贸易互联网 CIETNET\n### (7) 中国移动互联网 CMNET\n### (8) 中国长城互联网 CGWNET（建设中）\n### (9) 中国卫星集团互联网 CSNET（建设中） \n## 计算机网络的类别\n### 计算机网络的定义\n* 最简单的定义：计算机网络是一些互相连接的、自治的计算机的集合。\n* 因特网(Internet)是“网络的网络”。\n### 几种不同类别的网络\n* 不同作用范围的网络 \n    * 广域网 WAN (Wide Area Network)\n    * 局域网 LAN (Local Area Network) \n    * 城域网 MAN (Metropolitan Area Network)\n    * 个人区域网 PAN (Personal Area Network) \n* 从网络的使用者进行分类 \n    * 公用网 (public network) \n    * 专用网 (private network) \n## 计算机网络的性能\n### 计算机网络的性能指标\n* 速率\n    * 比特（bit）是计算机中数据量的单位，也是信息论中使用的信息量的单位。\n    * Bit 来源于 binary digit，意思是一个“二进制数字”，因此一个比特就是二进制数字中的一个 1 或 0。\n    * 速率即数据率(data rate)或比特率(bit rate)是计算机网络中最重要的一个性能指标。速率的单位是 b/s，或kb/s, Mb/s, Gb/s 等\n    * 速率往往是指额定速率或标称速率。  \n*  带宽 \n    * “带宽”(bandwidth)本来是指信号具有的频带宽度，单位是赫（或千赫、兆赫、吉赫等）。\n    * 现在“带宽”是数字信道所能传送的“最高数据率”的同义语，单位是“比特每秒”，或 b/s (bit/s)。 \n    * 常用的带宽单位\n        * 更常用的带宽单位是\n        * 千比每秒，即 kb/s （103 b/s）\n        * 兆比每秒，即 Mb/s（106 b/s）\n        * 吉比每秒，即 Gb/s（109 b/s）\n        * 太比每秒，即 Tb/s（1012 b/s）\n        * 请注意：在计算机界，K = 210 = 1024\n        *    M = 220, G = 230, T = 240。\n    * 数字信号流随时间的变化\n        * 在时间轴上信号的宽度随带宽的增大而变窄。\n* 吞吐量\n    * 吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。\n    * 吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。\n    * 吞吐量受网络的带宽或网络的额定速率的限制。  \n* 时延(delay 或 latency)\n    * 传输时延（发送时延 ）    发送数据时，数据块从结点进入到传输媒体所需要的时间。\n    * 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。 \n    * 传播时延    电磁波在信道中需要传播一定的距离而花费的时间。 \n    * 信号传输速率（即发送速率）和信号在信道上的传播速率是完全不同的概念。 \n    * 处理时延    交换结点为存储转发而进行一些必要的处理所花费的时间。 \n    * 排队时延    结点缓存队列中分组排队所经历的时延。\n    * 排队时延的长短往往取决于网络中当时的通信量。\n    * 数据经历的总时延就是发送时延、传播时延、处理时延和排队时延之和： \n* 时延带宽积\n    * 链路的时延带宽积又称为以比特为单位的链路长度。 \n* 利用率\n    * 信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。\n    * 网络利用率则是全网络的信道利用率的加权平均值。\n    * 信道利用率并非越高越好。 \n* 时延与网络利用率的关系\n    * 根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也就迅速增加。 \n    * 若令 D0 表示网络空闲时的时延，D 表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示 D 和 D0之间的关系：\n        * U 是网络的利用率，数值在 0 到 1 之间。 \n### 计算机网络的非性能特征\n* 费用\n* 质量\n* 标准化\n* 可靠性\n* 可扩展性和可升级性 \n* 易于管理和维护 \n## 计算机网络的体系结构\n### 计算机网络体系结构的形成\n* 相互通信的两个计算机系统必须高度协调工作才行，而这种“协调”是相当复杂的。 \n* “分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。\n### 协议与划分层次\n* 划分层次的必要性\n    * 计算机网络中的数据交换必须遵守事先约定好的规则。 \n    * 这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。\n    * 网络协议(network protocol)，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。\n* 网络协议的组成要素\n    * 语法     数据与控制信息的结构或格式 。 \n    * 语义     需要发出何种控制信息，完成何种动作以及做出何种响应。 \n    * 同步    事件实现顺序的详细说明。\n* 分层的好处 \n    * 各层之间是独立的。\n    * 灵活性好。\n    * 结构上可分割开。\n    * 易于实现和维护。\n    * 能促进标准化工作。  \n### 具有五层协议的体系结构\n* TCP/IP 是四层的体系结构：应用层、运输层、网际层和网络接口层。\n* 但最下面的网络接口层并没有具体内容。\n* 因此往往采取折中的办法，即综合 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构 。 \n### 实体、协议、服务和服务访问点\n* 实体(entity) 表示任何可发送或接收信息的硬件或软件进程。 \n* 协议是控制两个对等实体进行通信的规则的集合。 \n* 在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。\n* 要实现本层协议，还需要使用下层所提供的服务。 \n* 本层的服务用户只能看见服务而无法看见下面的协议。\n* 下面的协议对上面的服务用户是透明的。 \n* 协议是“水平的”，即协议是控制对等实体之间通信的规则。\n* 服务是“垂直的”，即服务是由下层向上层通过层间接口提供的。\n* 同一系统相邻两层的实体进行交互的地方，称为服务访问点 SAP (Service Access Point)。 \n* 协议必须把所有不利的条件事先都估计到，而不能假定一切都是正常的和非常理想的。 \n* 看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，而且还必须非常仔细地检查这个协议能否应付各种异常情况。 \n## Internet 和 Internet 的区别\n### 以小写字母 i 开始的 internet（互联网或互连网）是一个通用名词，它泛指由多个计算机网络互连而成的网络。 \n### 以大写字母I开始的的 Internet（因特网）则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定计算机网络，它采用 TCP/IP 协议族作为通信的规则，且其前身是美国的 ARPANET。\n## 万维网 WWW 的问世\n### 因特网已经成为世界上规模最大和增长速率最快的计算机网络，没有人能够准确说出因特网究竟有多大。\n### 因特网的迅猛发展始于 20 世纪 90 年代。由欧洲原子核研究组织 CERN 开发的万维网 WWW (World Wide Web)被广泛使用在因特网上，大大方便了广大非网络专业人员对网络的使用，成为因特网的这种指数级增长的主要驱动力。 \n## 客户软件的特点 \n### 被用户调用后运行，在打算通信时主动向远地服务器发起通信（请求服务）。因此，客户程序必须知道服务器程序的地址。\n### 不需要特殊的硬件和很复杂的操作系统。 \n## 服务器软件的特点 \n### 一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。\n### 系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的通信请求。因此，服务器程序不需要知道客户程序的地址。\n### 一般需要强大的硬件和高级的操作系统支持。\n## 因特网的边缘部分与核心部分\n## 两种国际标准\n### 法律上的(de jure)国际标准 OSI 并没有得到市场的认可。\n### 是非国际标准 TCP/IP 现在获得了最广泛的应用。\n### TCP/IP 常被称为事实上的(de facto) 国际标准。\n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据 \n## 主机 1 向主机 2 发送数据\n## 分组交换\n### 在发送端，先把较长的报文划分成较短的、固定长度的数据段。 \n### 添加首部构成分组\n* 每一个数据段前面添加上首部构成分组\n### 分组交换的传输单元\n* 分组交换网以“分组”作为数据传输单元。\n* 依次把各分组发送到接收端（假定接收端在左边）\n### 分组首部的重要性\n* 每一个分组的首部都含有地址等控制信息。\n* 分组交换网中的结点交换机根据收到的分组的首部中的地址信息，把分组转发到下一个结点交换机。\n* 用这样的存储转发方式，最后分组就能到达最终目的地。\n### 收到分组后剥去首部\n* 接收端收到分组后剥去首部还原成报文\n### 最后还原成原来的报文\n### 分组交换的优点\n* 高效    动态分配传输带宽，对通信链路是逐段占用。 \n* 灵活    以分组为传送单位和查找路由。\n* 迅速    不必先建立连接就能向其他主机发送分组。\n* 可靠    保证可靠性的网络协议；分布式的路由选择协议使网络有很好的生存性。\n### 分组交换带来的问题\n* 分组在各结点存储转发时需要排队，这就会造成一定的时延。 \n* 分组必须携带的首部（里面有必不可少的控制信息）也造成了一定的开销。\n##  电路交换\n### 两部电话机只需要用一对电线就能够互相连接起来。\n### 更多的电话机互相连通\n* 5 部电话机两两相连，需 10 对电线。\n* N 部电话机两两相连，需 N(N – 1)/2 对电线。\n* 当电话机的数量很大时，这种连接方法需要的电线对的数量与电话机数的平方成正比。\n### 使用交换机\n* 当电话机的数量增多时，就要使用交换机来完成全网的交换任务。\n### 电路交换的特点\n* 电路交换必定是面向连接的。 \n* 电路交换的三个阶段：\n    * 建立连接\n    * 通信\n    * 释放连接\n* 电路交换传送计算机数据效率低\n    * 计算机数据具有突发性。\n    * 这导致通信线路的利用率很低。\n## 三种交换的比较 \n## 两种通信方式\n### 客户服务器方式（C/S 方式）   即Client/Server方式 \n* 客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。\n* 客户服务器方式所描述的是进程之间服务和被服务的关系。\n* 客户是服务的请求方，服务器是服务的提供方。\n### 对等方式（P2P 方式）   即 Peer-to-Peer方式  \n* 对等连接(peer-to-peer，简写为 P2P)是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方。\n* 只要两个主机都运行了对等连接软件（P2P 软件），它们就可以进行平等的、对等连接通信。\n* 双方都可以下载对方已经存储在硬盘中的共享文档。 \n* 对等连接方式的特点\n    * 对等连接方式从本质上看仍然是使用客户服务器方式，只是对等连接中的每一个主机既是客户又同时是服务器。\n    * 例如主机 C 请求 D 的服务时，C 是客户，D 是服务器。但如果 C 又同时向 F提供服务，那么 C 又同时起着服务器的作用。\n## TCP/IP 的体系结构\n## 关于开放系统互连参考模型OSI/RM\n### 只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。\n### 在市场化方面 OSI 却失败了。\n* OSI 的专家们在完成 OSI 标准时没有商业驱动力；\n* OSI 的协议实现起来过分复杂，且运行效率很低；\n* OSI 标准的制定周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场；\n* OSI 的层次划分并也不太合理，有些功能在多个层次中重复出现。  \n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%201%20%E7%AB%A0%20%20%20%E6%A6%82%E8%BF%B0/%E7%AC%AC%201%20%E7%AB%A0%20%20%20%E6%A6%82%E8%BF%B0.png)\n\n\n\n# 第 2 章  物理层\n## 物理层的基本概念\n### 物理层的主要任务描述为确定与传输媒体的接口的一些特性\n* 机械特性    指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等等。\n* 电气特性    指明在接口电缆的各条线上出现的电压的范围。\n* 功能特性    指明某条线上出现的某一电平的电压表示何种意义。\n* 过程特性    指明对于不同功能的各种可能事件的出现顺序。 \n## 数据通信的基础知识\n### 数据通信系统的模型\n*  \n### 有关信道的几个基本概念\n* 单向通信（单工通信）——只能有一个方向的通信而没有反方向的交互。\n* 双向交替通信（半双工通信）——通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。\n* 双向同时通信（全双工通信）——通信的双方可以同时发送和接收信息。 \n* 几种最基本的调制方法\n    * 调幅(AM)：载波的振幅随基带数字信号而变化。 \n    * 调频(FM)：载波的频率随基带数字信号而变化。\n    * 调相(PM) ：载波的初始相位随基带数字信号而变化。 \n    * 概要: 图片\n### 信道的极限容量\n* 信道能够通过的频率范围\n    * 1924 年，奈奎斯特(Nyquist)就推导出了著名的奈氏准则。他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值\n* 信噪比\n    * 香农(Shannon)用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率。\n信道的极限信息传输速率 C 可表达为\nC = W log2(1+S/N)  b/s \nW 为信道的带宽（以 Hz 为单位）；\nS 为信道内所传信号的平均功率；\nN 为信道内部的高斯噪声功率。\n        * 香农公式表明\n            * 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 \n            * 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 \n            * 若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。\n            * 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。\n### 信道的极限信息传输速率\n## 物理层下面的传输媒体\n### 导向传输媒体\n* 双绞线\n    * 屏蔽双绞线 STP (Shielded Twisted Pair)\n    * 无屏蔽双绞线 UTP (Unshielded Twisted Pair) \n* 同轴电缆\n    * 50 Ω同轴电缆\n    * 75 Ω 同轴电缆\n* 光缆 \n    * 光纤的工作原理\n        * 光线在纤芯中传输的方式是不断地全反射\n### 非导向传输媒体\n* 无线传输所使用的频段很广。\n* 短波通信主要是靠电离层的反射，但短波信道的通信质量较差。\n* 微波在空间主要是直线传播。 \n    * 卫星通信  \n    * 地面微波接力通信\n## 信道复用技术\n### 频分复用、时分复用和统计时分复用\n* 频分复用 FDM(Frequency Division Multiplexing) \n    * 用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。\n        * 示意图\n* 时分复用TDM(Time Division Multiplexing) \n    * 时分复用则是将时间划分为一段段等长的时分复用帧（TDM 帧）。每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙。\n        * 示意图\n* 统计时分复用 STDM\u000b(Statistic TDM)  \n    * 是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。\n        * 示意图\n### 波分复用\n* 波分复用 WDM(Wavelength Division Multiplexing)  \n    * 光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。\n### 码分复用\n* 码分复用 CDM(Code Division Multiplexing)  \n    * 常用的名词是码分多址 CDMA     (Code Division Multiple Access)。\n    * 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。\n    * 这种系统发送的信号有很强的抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 \n    * 每一个比特时间划分为 m 个短的间隔，称为码片(chip)。\n    * 具体内容\n        * 1.为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 S 和 T 有\n        * 2.为了讨论方便，取 m=8，设码片 s 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。\n\n在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到(其中 S' 为 S 的反码。)\n        * 3.利用上面的式子我们知道，当接收端使用码片  对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。\n    * 码分复用需要发送的数据量为原先的 m 倍。\n## 数字传输系统\n### 脉码调制 PCM 体制\n### 同步光纤网 SONET 和同步数字系列 SDH\n## 宽带接入技术\n### xDSL技术\n* xDSL 技术就是用数字技术对现有的模拟电话用户线进行改造，使它能够承载宽带业务。把 0~4 kHz 低端频谱留给传统电话使用，而把原来没有被利用的高端频谱留给用户上网使用。\n### 光纤同轴混合网（HFC 网）\n* HFC 网是在目前覆盖面很广的有线电视网 CATV 的基础上开发的一种居民宽带接入网。HFC 网除可传送 CATV 外，还提供电话、数据和其他宽带交互型业务。\n### FTTx 技术\n* FTTx（光纤到……）也是一种实现宽带居民接入网的方案。这里字母 x 可代表不同意思。\n    * 光纤到家 FTTH (Fiber To The Home)：光纤一直铺设到用户家庭可能是居民接入网最后的解决方法。\n    * 光纤到大楼 FTTB (Fiber To The Building)：光纤进入大楼后就转换为电信号，然后用电缆或双绞线分配到各用户。\n    * 光纤到路边 FTTC (Fiber To The Curb)：从路边到各用户可使用星形结构双绞线作为传输媒体。 \n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%202%20%E7%AB%A0%20%20%E7%89%A9%E7%90%86%E5%B1%82/%E7%AC%AC%202%20%E7%AB%A0%20%20%E7%89%A9%E7%90%86%E5%B1%82.png)\n\n\n# 第 3 章  数据链路层\n## 使用点对点信道的数据链路层\n### 数据链路和帧\n* 数据链路层使用的信道主要有以下两种类型：\n    * 点对点信道。这种信道使用一对一的点对点通信方式。\n    * 广播信道。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发 \n* 数据链路层模型\n* 链路(link)是一条无源的点到点的物理线路段，中间没有任何其他的交换结点。\n* 数据链路(data link) 除了物理线路外，还必须有通信协议来控制这些数据的传输。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。\n* 数据链路层传送的是帧\n### 三个基本问题\n* (1) 封装成帧\n    * 将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。\n        *  \n* (2) 透明传输\n    * 透明表示一个实际存在的事物看起来好像不存在一样。\n    * 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。\n        *  \n* (3) 差错控制 \n    * 循环冗余检验 CRC\n目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。\n    * 帧检验序列 FCS\n在数据后面添加上的冗余码称为帧检验序列 FCS (Frame Check Sequence)。\n    * 冗余码的计算\n        * 例子：\n现在 k = 6, M = 101001。\n设 n = 3, 除数 P = 1101，\n被除数是 2^nM = 101001000。 \n模 2 运算的结果是：商 Q = 110101，\n           余数 R = 001。\n把余数 R 作为冗余码添加在数据 M 的后面发送出去。发送的数据是：2^nM + R \n   即：101001001，共 (k + n) 位。 \n\n    * 概要: CRC 是一种常用的检错方法，而 FCS 是添加在数据后面的冗余码。\nFCS 可以用 CRC 这种方法得出，但 CRC 并非用来获得 FCS 的唯一方法。\n## 点对点协议 PPP\n### PPP 协议的特点\n* 互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。\n### PPP 协议的帧格式\n* 示意图：\nF 字段为帧的定界符\nA 和 C 字段暂时没有意义\nFCS 字段是使用 CRC 的检验序列\n信息部分的长度不超过 1500\n### PPP 协议的工作状态\n* 过程：\n当用户拨号接入 ISP 时，路由器的调制解调器对拨号做出确认，并建立一条物理连接。\nPC 机向路由器发送一系列的 LCP 分组（封装成多个 PPP 帧）。\n这些分组及其响应选择一些 PPP 参数，和进行网络层配置，NCP 给新接入的 PC机分配一个临时的 IP 地址，使 PC 机成为因特网上的一个主机。\n通信完毕时，NCP 释放网络层连接，收回原来分配出去的 IP 地址。接着，LCP 释放数据链路层连接。最后释放的是物理层的连接。\n## 使用广播信道的数据链路层\n### 局域网的数据链路层\n* 局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。\n* 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。\n* 可以按照网络拓扑结构对局域网进行分类：\n    * 星形网\n    * 环形网\n    * 总线网\n    * 树形网 \n* 数据链路层的两个子层 \n    * 逻辑链路控制 LLC (Logical Link Control)子层\n    * 媒体接入控制 MAC (Medium Access Control)子层。\n    * 概要: 与接入到传输媒体有关的内容都放在 MAC子层，而 LLC 子层则与传输媒体无关，不管采用何种协议的局域网对 LLC 子层来说都是透明的\n所以以后一般不考虑 LLC 子层 \n* 适配器\n    * 网络接口板又称为通信适配器(adapter)或网络接口卡 NIC (Network Interface Card)，或“网卡”。\n        * 适配器的重要功能：\n            * 进行串行/并行转换。\n            * 对数据进行缓存。\n            * 在计算机的操作系统安装设备驱动程序。\n            * 实现以太网协议。 \n###     CSMA/CD 协议\n* CSMA/CD 表示载波监听多点接入 / 碰撞检测。\n    * 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。\n    * 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。\n    * 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。\n* 具体内容\n    * 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。\n    * 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。\n    * 概要: 示意图\n## 使用广播信道的以太网\n### 使用集线器的星形拓扑\n* 传统以太网最初是使用粗同轴电缆，后来演进到使用比较便宜的细同轴电缆，最后发展为使用更便宜和更灵活的双绞线。\n这种以太网采用星形拓扑，在星形的中心则增加了一种可靠性非常高的设备，叫做集线器(hub)  \n### 以太网的信道利用率\n* 一个帧从开始发送，经可能发生的碰撞后，将再重传数次，到发送成功且信道转为空闲(即再经过时间 τ  使得信道上无信号在传播)时为止，是发送一帧所需的平均时间。 \n* 发送一帧占用线路的时间是 T0 +  τ ，而帧本身的发送时间是 T0。于是我们可计算出理想情况下的极限信道利用率 Smax为： \n###  以太网的 MAC 层\n* MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。\n* 一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。\n### 以太网帧格式：\n* 类型 ：标记上层使用的协议；\n数据 ：长度在 46-1500 之间，如果太小则需要填充；\nFCS ：帧检验序列，使用的是 CRC 检验方法；\n## 扩展的以太网\n### 在物理层扩展以太网\n* 用多个集线器可连成更大的局域网\n    * 用集线器组成更大的局域网都在一个碰撞域中\n        * 优点\n            * 使原来属于不同碰撞域的局域网上的计算机能够进行跨碰撞域的通信。\n            * 扩大了局域网覆盖的地理范围。\n        * 缺点\n            * 碰撞域增大了，但总的吞吐量并未提高。\n            * 如果不同的碰撞域使用不同的数据率，那么就不能用集线器将它们互连起来。\n### 在数据链路层扩展以太网\n* 在数据链路层扩展局域网是使用网桥。\n    * 网桥工作在数据链路层，它根据 MAC 帧的目的地址对收到的帧进行转发。\n网桥具有过滤帧的功能。当网桥收到一个帧时，并不是向所有的接口转发此帧，而是先检查此帧的目的 MAC 地址，然后再确定将该帧转发到哪一个接口 。\n        * 优点\n            * 过滤通信量。 \n            * 扩大了物理范围。\n            * 提高了可靠性。\n            * 可互连不同物理层、不同 MAC 子层和不同速率（如10 Mb/s 和 100 Mb/s 以太网）的局域网。\n        * 缺点\n            * 存储转发增加了时延。 \n            * 在MAC 子层并没有流量控制功能。 \n            * 具有不同 MAC 子层的网段桥接在一起时时延更大。\n            * 网桥只适合于用户数不太多(不超过几百个)和通信量不太大的局域网，否则有时还会因传播过多的广播信息而产生网络拥塞。这就是所谓的广播风暴。  \n    * 交换机\n        * 交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。\n正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。\n            * 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧，主机 B 回应该帧向主机 A 发送数据包时，交换机查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 2 的映射。\n### 虚拟局域网\n* 虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。\n* 例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。\n* 使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。\n## 高速以太网\n###  100BASE-T 以太网\n* 速率达到或超过 100 Mb/s 的以太网称为高速以太网\n* 可在全双工方式下工作而无冲突发生。因此，不使用 CSMA/CD 协议。\n### 吉比特以太网\n* 允许在 1 Gb/s 下全双工和半双工两种方式工作。\n* 在半双工方式下使用 CSMA/CD 协议（全双工方式不需要使用 CSMA/CD 协议）。\n### 10 吉比特以太网\n* 10 吉比特以太网只工作在全双工方式\n* 也不使用 CSMA/CD 协议。\n### 使用高速以太网进行宽带接入\n* 以太网接入的重要特点是它可提供双向的宽带通信，并且可根据用户对带宽的需求灵活地进行带宽升级。\n* 采用以太网接入可实现端到端的以太网传输，中间不需要再进行帧格式的转换。这就提高了数据的传输效率和降低了传输的成本。  \n## 其他类型的高速局域网接口\n## 集线器在转发帧时，不对传输媒体进行检测。\n网桥在转发帧之前必须执行 CSMA/CD 算法。\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%203%20%E7%AB%A0%20%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/%E7%AC%AC%203%20%E7%AB%A0%20%20%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82.png)\n\n\n# 第 4 章  网络层\n## 网络层提供的两种服务\n### 虚电路服务\n### 数据报服务\n### 概要: 虚电路服务与数据报服务的对比\n## 网际协议 IP\n### 网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。与 IP 协议配套使用的还有四个协议：\n* 地址解析协议 ARP (Address Resolution Protocol)\n* 逆地址解析协议 RARP   (Reverse Address Resolution Protocol)\n* 网际控制报文协议 ICMP   (Internet Control Message Protocol)\n* 网际组管理协议 IGMP   (Internet Group Management Protocol)\n* 概要: 示意图\n### 虚拟互连网络\n* 网络互相连接起来要使用一些中间设备\n    * 物理层中继系统：转发器(repeater)。\n    * 数据链路层中继系统：网桥或桥接器(bridge)。\n    * 网络层中继系统：路由器(router)。\n    * 网桥和路由器的混合物：桥路器(brouter)。\n    * 网络层以上的中继系统：网关(gateway)。  \n###  IP 数据报的格式\n* 版本 : 有 4（IPv4）和 6（IPv6）两个值；\n* 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。\n* 区分服务 : 用来获得更好的服务，一般情况下不使用。\n* 总长度 : 包括首部长度和数据部分长度。\n* 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。\n* 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。\n* 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。\n* 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。\n* 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。\n    * IP数据报分片\n* 概要: 示意图\n### 分类的 IP 地址\t\n* IP 地址的编址方式经历了三个历史阶段：\n    * 分类\n        * 由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。\nIP 地址 ::= {< 网络号 >, < 主机号 >}\n            * 示意图\n    * 子网划分\n        * 通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。\n\nIP 地址 ::= {< 网络号 >, < 子网号 >, < 主机号 >}\n\n要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。\n\n注意，外部网络看不到子网的存在。\n    * 无分类\n        * 无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。\n\nIP 地址 ::= {< 网络前缀号 >, < 主机号 >}\n\nCIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。\n\nCIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。\n\n一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。\n\n在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。\n### IP 地址与硬件地址\n* IP层抽象的互联网屏蔽了下层很复杂的细节\n在抽象的网络层上讨论问题，就能够使用\n统一的、抽象的 IP 地址\n研究主机和主机或主机和路由器之间的通信 \n    * 示意图\n### 地址解析协议 ARP 与逆地址解析协议RARP\n* 缘由\n    * 网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。\n* 地址解析协议 ARP\n    * ARP 实现由 IP 地址得到 MAC 地址\n        * 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。\n\n如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。\n            * 示意图\n* 逆地址解析协议 RARP\n    * 逆地址解析协议 RARP 使只知道自己硬件地址的主机能够知道其 IP 地址。\n        * 这种主机往往是无盘工作站。 因此 RARP协议目前已很少使用。\n###   IP 层转发分组的流程\n* 分组转发算法 \n    * (1)  从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。\n    * (2)  若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行(3)。\n    * (3)  若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行(4)。\n    * (4)  若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行(5)。\n    * (5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行(6)。\n    * (6)  报告转发分组出错。 \n    * 概要: 示意图\n## 划分子网和构造超网\n###  划分子网\n###   使用子网时分组转发\n###   无分类编址 CIDR（构造超网）\n## 网际控制报文协议 ICMP\n### 简介\n* ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。\n###      ICMP 报文的种类\n* ICMP 差错报告报文\n    * 终点不可达 \n    * 源点抑制(Source quench)  \n    * 时间超过 \n    * 参数问题 \n    * 改变路由（重定向）(Redirect)  \n*  ICMP 询问报文\n    * 回送请求和回答报文\n    * 时间戳请求和回答报文\n* ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即类型、代码和检验和。接着的 4 个字节的内容与 ICMP 的类型有关。 \n###   ICMP 的应用举例\n* 1. Ping\n    * Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。\n\nPing 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。\n* 2. Traceroute\n    * Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。\n\nTraceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。\n        * 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；\n        * 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。\n        * 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。\n        * 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。\n## 因特网的路由选择协议\n### 有关路由选择协议的几个基本概念\n* 静态路由选择策略——即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。 \n* 动态路由选择策略——即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。\n### 自治系统 AS(Autonomous System) \n* 自治系统 AS 的定义：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS之间的路由。\n### 内部网关协议 IGP (Interior Gateway Protocol) \n* 即在一个自治系统内部使用的路由选择协议。\n    * 内部网关协议 RIP\n        * RIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。\n\nRIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。\n        * 距离向量算法：\n            * 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1；\n            * 对修改后的 RIP 报文中的每一个项目，进行以下步骤：\n            * 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中；\n            * 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。\n            * 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。\n        * RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。\n    * 内部网关协议 OSPF\n        * 开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。\n\n开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。\n        * OSPF 具有以下特点：\n            * 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。\n            * 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。\n            * 只有当链路状态发生变化时，路由器才会发送信息。\n        * 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。\n### 外部网关协议 BGP (External Gateway Protocol)\n* 若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议将路由选择信息传递到另一个自治系统中。\n* AS 之间的路由选择很困难，主要是由于：\n    * 互联网规模很大；\n    * 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量；\n    * AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。\n* BGP 只能寻找一条比较好的路由，而不是最佳路由。\n\n每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。\n    * 示意图\n### 路由器的构成\n* 路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。\n* 路由器从功能上可以划分为\n    * 路由选择\n    * 分组转发\n* 分组转发结构由三个部分组成\n    * 交换结构\n    * 一组输入端口\n    * 一组输出端口\n    * 概要: 示意图\n## IP 多播\n###       \t  IP 多播的基本概念\n* 多播可明显地减少网络中资源的消耗\n###            在局域网上进行硬件多播\n* \n###   因特网组管理协议 IGMP 和多播路由选择协议\n* IGMP 使多播路由器\u000b知道多播组成员信息 \n* 多播转发必须动态地适应多播组成员的变化（这时网络拓扑并未发生变化）。请注意，单播路由选择通常是在网络拓扑发生变化时才需要更新路由。\n## 虚拟专用网 VPN 和网络地址转换 NAT\n###            虚拟专用网 VPN\n* 由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。\n    * 有三个专用地址块：\n        * 10.0.0.0 ~ 10.255.255.255\n        * 172.16.0.0 ~ 172.31.255.255\n        * 192.168.0.0 ~ 192.168.255.255\n* VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指好像是，而实际上并不是，它有经过公用的互联网。\n* 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。\n###           网络地址转换 NAT\n* 专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。\n* 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。\n## 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。\n## 因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%204%20%E7%AB%A0%20%20%E7%BD%91%E7%BB%9C%E5%B1%82/%E7%AC%AC%204%20%E7%AB%A0%20%20%E7%BD%91%E7%BB%9C%E5%B1%82.png)\n\n# 第 5 章  运输层\n## 运输层协议概述\n### 进程之间的通信\n* 运输层向它上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。\n* 两个主机进行通信实际上就是两个主机中的应用进程互相通信。 \n* 应用进程之间的通信又称为端到端的通信。 \n* 运输层协议和网络层协议的主要区别 \n### 运输层的两个主要协议\n* (1) 用户数据报协议 UDP(User Datagram Protocol)\n    * UDP 传送的数据单位协议是 UDP 报文或用户数据报。 \n* (2) 传输控制协议 TCP(Transmission Control Protocol)\n    * TCP 传送的数据单位协议是 TCP 报文段(segment)\n### 运输层的端口\n* 软件端口与硬件端口\n    * 在协议栈层间的抽象的协议端口是软件端口。\n    * 路由器或交换机上的端口是硬件端口。\n* 三类端口\n    * 熟知端口，数值一般为 0~1023。\n    * 登记端口号，数值为1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。\n    * 客户端口号或短暂端口号，数值为49152~65535，留给客户进程选择暂时使用。当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。\n## 用户数据报协议 UDP \n### UDP 概述\n* 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。\n### UDP 的首部格式\n## 传输控制协议 TCP 概述\n### TCP 最主要的特点\n* 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。\n### TCP 的连接\n* TCP 连接的端点叫做套接字(socket)或插口。\n    * 套接字 socket = (IP地址: 端口号) \n## 可靠传输的工作原理\n### 停止等待协议\n### 连续 ARQ 协议\n## TCP 报文段的首部格式\n### 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。\n### 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。\n### 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。\n### 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。\n### 同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。\n### 终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。\n### 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。\n### 概要: 示意图\n## TCP 可靠传输的实现\n###  以字节为单位的滑动窗口     \n* 窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。\n\n发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。\n\n接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。\n    * 1\n    * 2\n    * 3\n    *  4\n### 超时重传时间的选择\n* 超时重传\n    * TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。\n\n一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：\n    * 其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。\n\n超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：（其中 RTTd 为偏差的加权平均值）\n### 选择确认 SACK\n## TCP的流量控制\n### 利用滑动窗口实现流量控制\n* TCP 流量控制\n    * 流量控制是为了控制发送方发送速率，保证接收方来得及接收。\n\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n* 流量控制举例\n### 必须考虑传输效率\n## TCP 的拥塞控制\n### 拥塞控制的一般原理\n* 如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。\n* 拥塞控制所起的作用\n### 几种拥塞控制方法\n* TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。\n    * 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。\n\n为了便于讨论，做如下假设：\n\n接收方有足够大的接收缓存，因此不会发生流量控制；\n虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。\n    * 1. 慢开始与拥塞避免\n        * 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...\n\n注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。\n\n如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。\n    * 2. 快重传与快恢复\n        * 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。\n\n在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。\n\n在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。\n\n慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。\n###  随机早期检测 RED\n## TCP 的运输连接管理\n### TCP 的连接建立\n* 假设 A 为客户端，B 为服务器端。\n\n首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。\n\nA 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。\n\nB 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。\n\nA 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。\n\nB 收到 A 的确认后，连接建立。\n* 三次握手的原因\n    * 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。\n\n客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。\n### TCP 的连接释放\n* 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。\n\nA 发送连接释放报文，FIN=1。\n\nB 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。\n\n当 B 不再需要连接时，发送连接释放报文，FIN=1。\n\nA 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。\n\nB 收到 A 的确认后释放连接。\n* 四次挥手的原因\n    * 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。\n* TIME_WAIT\n    * 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：\n        * 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。\n        * 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。\n### TCP 的有限状态机 \n* 粗实线箭头表示对客户进程的正常变迁。\n粗虚线箭头表示对服务器进程的正常变迁。\n另一种细线箭头表示异常变迁。\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%205%20%E7%AB%A0%20%20%E8%BF%90%E8%BE%93%E5%B1%82/%E7%AC%AC%205%20%E7%AB%A0%20%20%E8%BF%90%E8%BE%93%E5%B1%82.png)\n\n\n# 第 6 章  应用层\n## 域名系统 DNS\n### 域名系统概述\n* DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。\n### 因特网的域名结构\n* 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。\n### 域名服务器\n* 一个服务器所负责管辖的（或有权限的）范围叫做区(zone)。\n* 每一个区设置相应的权限域名服务器，用来保存该区中的所有主机的域名到IP地址的映射。\n*  \n* DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传从而保证可靠性。在两种情况下会使用 TCP 进行传输：\n    * 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。\n    * 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。\n## 文件传送协议\n### FTP 概述\n* 文件传送协议 FTP (File Transfer Protocol) 是因特网上使用得最广泛的文件传送协议。\n* FTP 提供交互式的访问，允许客户指明文件的类型与格式，并允许文件具有存取权限。\n* FTP 屏蔽了各计算机系统的细节，因而适合于在异构网络中任意计算机之间传送文件。\n### FTP 的基本工作原理\n* FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：\n    * 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。\n    * 数据连接：用来传送一个文件数据。\n* 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式：\n    * 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。\n    * 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。\n    * 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。\n### 简单文件传送协议 TFTP\n* TFTP 是一个很小且易于实现的文件传送协议。\n* TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。\n* TFTP 只支持文件传输而不支持交互。\n* TFTP 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。 \n* TFTP 的主要特点是\n    *     (1) 每次传送的数据 PDU 中有 512 字节的数据，但最后一次可不足 512 字节。\n    *     (2) 数据 PDU 也称为文件块(block)，每个块按序编号，从 1 开始。\n    *     (3) 支持 ASCII 码或二进制传送。\n    *     (4) 可对文件进行读或写。\n    *     (5) 使用很简单的首部。 \n## 远程终端协议 TELNET \n### 简述\n* TELNET 是一个简单的远程终端协议，也是因特网的正式标准。\n* 用户用 TELNET 就可在其所在地通过 TCP 连接注册（即登录）到远地的另一个主机上（使用主机名或 IP 地址）。\n* TELNET 能将用户的击键传到远地主机，同时也能将远地主机的输出通过 TCP 连接返回到用户屏幕。这种服务是透明的，因为用户感觉到好像键盘和显示器是直接连在远地主机上。 \n## 万维网 WWW\n### 概述\n* 万维网 WWW (World Wide Web)并非某种特殊的计算机网络。\n* 万维网是一个大规模的、联机式的信息储藏所。\n* 万维网用链接的方法能非常方便地从因特网上的一个站点访问另一个站点，从而主动地按需获取丰富的信息。\n* 这种访问方式称为“链接”。\n* 万维网是分布式超媒体(hypermedia)系统，它是超文本(hypertext)系统的扩充。\n### 万维网的工作方式 \n* 万维网以客户服务器方式工作。\n* 浏览器就是在用户计算机上的万维网客户程序。万维网文档所驻留的计算机则运行服务器程序，因此这个计算机也称为万维网服务器。\n### 万维网必须解决的问题\n* (1) 怎样标志分布在整个因特网上的万维网文档？ \n使用统一资源定位符 URL (Uniform Resource Locator)来标志万维网上的各种文档。\n使每一个文档在整个因特网的范围内具有唯一的标识符 URL。 \n* (2) 用何协议实现万维网上各种超链的链接？ \n在万维网客户程序与万维网服务器程序之间进行交互所使用的协议，是超文本传送协议 HTTP (HyperText Transfer Protocol)。\nHTTP 是一个应用层协议，它使用 TCP 连接进行可靠的传送。 \n* (3) 怎样使各种万维网文档都能在因特网上的各种计算机上显示出来，同时使用户清楚地知道在什么地方存在着超链？ \n超文本标记语言 HTML (HyperText Markup Language)使得万维网页面的设计者可以很方便地用一个超链从本页面的某处链接到因特网上的任何一个万维网页面，并且能够在自己的计算机屏幕上将这些页面显示出来。 \n* (4) 怎样使用户能够很方便地找到所需的信息？ \n为了在万维网上方便地查找信息，用户可使用各种的搜索工具（即搜索引擎）。 \n### 统一资源定位符 URL\n* 统一资源定位符 URL 是对可以从因特网上得到的资源的位置和访问方法的一种简洁的表示。\n* URL 的一般形式是：<协议>://<主机>:<端口>/<路径> \n### 超文本传送协议 HTTP\n* HTTP 是面向事务的客户服务器协议。\n* HTTP 1.0 协议是无状态的(stateless)。\n* HTTP 协议本身也是无连接的，虽然它使用了面向连接的 TCP 向上提供的服务。\n### 万维网的文档\n* 超文本标记语言 HTML\n    * 超文本标记语言 HTML 中的 Markup 的意思就是“设置标记”。\n    * HTML 定义了许多用于排版的命令（即标签）。\n    * HTML 把各种标签嵌入到万维网的页面中。这样就构成了所谓的 HTML 文档。HTML 文档是一种可以用任何文本编辑器创建的 ASCII 码文件。   \n* 动态万维网文档\n    * 静态文档是指该文档创作完毕后就存放在万维网服务器中，在被用户浏览的过程中，内容不会改变。 \n    * 动态文档是指文档的内容是在浏览器访问万维网服务器时才由应用程序动态创建。\n    * 动态文档和静态文档之间的主要差别体现在服务器一端。这主要是文档内容的生成方法不同。而从浏览器的角度看，这两种文档并没有区别。  \n### 万维网的信息检索系统\n* 全文检索搜索\n    * 全文检索搜索引擎是一种纯技术型的检索工具。它的工作原理是通过搜索软件到因特网上的各网站收集信息，找到一个网站后可以从这个网站再链接到另一个网站。然后按照一定的规则建立一个很大的在线数据库供用户查询。\n* 分类目录搜索\n    * 分类目录搜索引擎并不采集网站的任何信息，而是利用各网站向搜索引擎提交的网站信息时填写的关键词和网站描述等信息，经过人工审核编辑后，如果认为符合网站登录的条件，则输入到分类目录的数据库中，供网上用户查询。\n## 电子邮件\n### 电子邮件概述\n* 电子邮件(e-mail)是因特网上使用得最多的和最受用户欢迎的一种应用。\n* 电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取。\n* 电子邮件不仅使用方便，而且还具有传递迅速和费用低廉的优点。\n* 一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。\n### 电子邮件的最主要的组成构件 \n### 简单邮件传送协议 SMTP\n* SMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。\n### 电子邮件的信息格式\n* 一个电子邮件分为信封和内容两大部分。\n* RFC 822 只规定了邮件内容中的首部(header)格式，而对邮件的主体(body)部分则让用户自由撰写。\n    * 邮件内容的首部\n        * “To:”后面填入一个或多个收件人的电子邮件地址。用户只需打开地址簿，点击收件人名字，收件人的电子邮件地址就会自动地填入到合适的位置上。\n        *  “Subject:”是邮件的主题。它反映了邮件的主要内容，便于用户查找邮件。\n        * 抄送 “Cc:” 表示应给某某人发送一个邮件副本。\n        * “From” 和 “Date” 表示发信人的电子邮件地址和发信日期。“Reply-To” 是对方回信所用的地址。  \n### 邮件读取协议 POP3 和 IMAP\n* POP3\n    * POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。但最新版本的 POP3 可以不删除邮件。\n* IMAP\n    * IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。\n### 基于万维网的电子邮件 \n* 例子\n    * 电子邮件从 A 发送到网易邮件服务器是使用 HTTP 协议。\n    * 两个邮件服务器之间的传送使用 SMTP。\n    * 邮件从新浪邮件服务器传送到 B 是使用 HTTP 协议。\n    * 概要: 示意图\n### 通用因特网邮件扩充 MIME\n* MIME 概述\n    * MIME 并没有改动 SMTP 或取代它。\n    * MIME 的意图是继续使用目前的[RFC 822]格式，但增加了邮件主体的结构，并定义了传送非 ASCII 码的编码规则。\n## 动态主机配置协议 DHCP \n### DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要手动配置 IP 地址等信息。\n### DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。\n### DHCP 工作过程如下：\n* 1.客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。\n2.DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。\n3.如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。\n4.DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。\n## 简单网络管理协议 SNMP\n### 网络管理的基本概念\n* 网络管理包括对硬件、软件和人力的使用、综合与协调，以便对网络资源进行监视、测试、配置、分析、评价和控制，这样就能以合理的价格满足网络的一些需求，如实时运行性能，服务质量等。网络管理常简称为网管。\n* SNMP 的网络管理由三个部分组成 \n    * SNMP 本身\n        * SNMP 定义了管理站和代理之间所交换的分组格式。所交换的分组包含各代理中的对象（变量）名及其状态（值）。\n    * 管理信息结构 SMI (Structure of Management Information)\n        * SMI 定义了命名对象和定义对象类型（包括范围和长度）的通用规则，以及把对象和对象的值进行编码的规则。\n    * 管理信息库 MIB(Management Information Base)。\n        * MIB 在被管理的实体中创建了命名对象，并规定了其类型。\n### 管理信息结构 SMI\n* SMI 的功能：\n    * (1) 被管对象应怎样命名；\n    *     (2) 用来存储被管对象的数据类型有哪些种；\n    *     (3) 在网络上传送的管理数据应如何编码。\n### 管理信息库 MIB\n* 被管对象必须维持可供管理程序读写的若干控制和状态信息。这些信息总称为管理信息库 MIB 。\n### SNMP 的协议数据单元和报文\n* SNMP的操作只有两种基本的管理功能，即：\n    * “读”操作，用 get 报文来检测各被管对象的状况；\n    *   “写”操作，用 set 报文来改变各被管对象的状况。\n* SNMP 的报文格式 \n## 应用进程跨越网络的通信\n### 系统调用和应用编程接口\n### 几种常用的系统调用\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%AC%AC%206%20%E7%AB%A0%20%20%E5%BA%94%E7%94%A8%E5%B1%82/%E7%AC%AC%206%20%E7%AB%A0%20%20%E5%BA%94%E7%94%A8%E5%B1%82.png)\n","tags":["408"]},{"title":"计算机操作系统","url":"/post/408/计算机操作系统/index.html  2019/12/05/408/计算机操作系统/","content":"# 计算机操作系统\n## 一.操作系统引论\n### 1.操作系统的目标和功能\n* 目标\n    * 方便性\n    * 有效性\n        * 提高系统资源利用率\n        * 提高系统吞吐量\n    * 可扩充性\n    * 开放性\n* 作用\n    * OS作为用户与计算机硬件系统之间的接口\n        * 命令方式\n        * 系统调用方式\n        * 图标–窗口方式\n    * OS实现了对计算机资源的抽象\n### 2.操作系统的发展过程\n* 未配置操作系统的计算机系统\n    * 人工操作方式\n     * > 用户独占全机 CPU等待人工操作 严重降低了计算机资源的利用率\n\n    * 脱机输入/输出(Off–Line I/O)方式\n     * > 减少了CPU的空闲时间 提高了I/O速度 效率仍然不理想\n\n* 单道批处理系统\n* 多道批处理系统\n* > 1.资源利用率高\n* > 2.系统吞吐量大\n* > 3.平均周转时间长\n* > 4.无交互能力\n\n    * (宏观并行，微观串行)\n* 分时系统\n* > 特征:\n* > 1.多路性\n* > 2.独立性\n* > 3.及时性\n* > 4.交互性\n\n* 实时系统\n* 集群系统–超算~云计算\n* 微机操作系统的发展\n### 3.操作系统的基本特征\n* 1.并发concurrence\n    * 区别并行和并发\n     * > 并行性是指两个或多个事件在同一时刻发生→宏观并行，微观并行\n     * > 并发性是指两个或多个事件在同一时间间隔内发生→宏观并行，微观串行\n\n        * 并发是进程宏观一起运行，微观上交替运行，而并行是指同时运行\n    * 引入进程\n     * > 进程是指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令，数据和堆栈等组成的，是一个能独立运行的活动实体\n\n* 2.共享sharing\n    * 1.互斥共享方式\n    * 2.同时访问方式\n    * 并发和共享是多用户(多任务)OS的两个最基本的特征。它们又是互为存在的条件\n* 3.虚拟virtual\n    * 时分复用技术\n    * 空分复用技术\n* 4.异步asynchronism\n### 4.操作系统的主要功能\n* 1.处理机管理功能\n    * 进程控制\n    * 进程同步\n        * 进程互斥方式\n        * 进程同步方式(协同)\n    * 进程通信\n    * 调度\n        * 作业调度\n        * 进程调度\n* 2.存储器管理功能\n    * 内存分配\n        * 静态分配\n        * 动态分配\n    * 内存保护\n    * 地址映射\n    * 内存扩充\n* 3.设备管理功能\n    * 缓冲管理\n    * 设备分配\n    * 设备处理\n        * 设备处理程序又称设备驱动程序\n* 4.文件管理功能\n    * 文件存储空间的管理\n    * 目录管理\n    * 文件的读写管理和保护\n* 5.操作系统与用户之间的接口\n    * 用户接口\n    * 程序接口\n* 6.现代操作系统的新功能\n    * 系统安全\n    * 网络的功能和服务\n    * 支持多媒体\n### 5.OS结构设计\n* 传统操作系统结构\n    * 无结构操作系统\n    * 模块化OS\n    * 分层式结构OS\n* 微内核os结构\n    * 客户/服务器模式\n    * 面对对象的程序设计\n## 第二章进程的描述与控制\n### 前驱图和程序执行\n### 程序并发执行\n* 程序的并发执行\n* 程序并发执行时的特征\n    * 间断性\n    * 失去封闭性\n    * 不可再现性\n### 进程的描述\n* 进程的定义\n    * 进程是程序的一次执行\n    * 进程是一个程序及其数据在处理机上顺序执行时所发生的活动\n    * 进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位\n* 进程的特征\n    * 动态性\n    * 并发性\n    * 独立性\n    * 异步性\n* 从操作系统角度分类\n    * 系统进程\n    * 用户进程\n* 进程和程序的区别\n    * 进程是动态概念，而程序则是静态概念\n    * 程序是指令的有序集合，永远存在；进程强调是程序在数据集上的一次执行，有创建有撤销，存在是暂时的；\n    * 进程具有并发性，而程序没有\n    * 进程可创建其他进程，而程序并不能形成新的程序\n    * 进程是竞争计算机资源的基本单位，程序不是\n* 进程和程序的联系\n    * 进程是程序在数据集上的一次执行\n    * 程序是构成进程的组成部分，一个程序可对应多个进程，一个进程可包括多个程序\n    * 进程的运行目标是执行所对应的程序\n    * 从静态看，进程由程序、数据和进程控制块（PCB）组成\n* 进程的基本状态及转换\n    * 进程的三种基本状态\n        * 就绪状态ready\n        * 执行状态running\n        * 阻塞状态block\n    * 三种基本状态的转换\n    * 创建状态和终止状态\n        * 五状态进程模型\n    * 注意\n        * 阻塞态->运行态和就绪态->阻塞态这二种状态转换不可能发生\n* 挂起操作和进程状态的转换\n    * 挂起和阻塞的区别\n    * 挂起操作的目的\n        * 终端用户的需要: 修改、检查进程\n        * 父进程的需要：修改、协调子进程\n        * 对换的需要：缓和内存\n        * 负荷调节的需要：保证实时任务的执行\n    * 关键图\n* 进程管理中的数据结构\n    * 进程控制块PCB的作用\n        * 作为独立运行基本单位的标志\n        * 能实现间断性运行方式\n        * 提供进程管理所需要的信息\n        * 提供进程调度所需要的信息\n        * 实现与其他进程的同步与通信\n    * 进程控制块的信息\n        * 进程标识符\n            * 外部标识符PID\n            * 内部标识符(端口)\n        * 处理机状态\n            * 通用寄存器\n            * 指令计数器\n            * 程序状态字PSW\n            * 用户栈指针\n        * 进程调度信息\n            * 进程状态\n            * 进程优先级\n            * 进程调度所需的其他信息\n            * 事件\n        * 进程控制信息\n            * 程序和数据的地址\n            * 进程同步和通信机制\n            * 资源清单\n            * 链接指针\n        * 进程控制块的组织方式\n            * 线性方式\n            * 链接方式\n            * 索引方式\n### 进程控制\n* 操作系统内核\n    * 两大功能\n        * 支撑功能\n            * 中断管理\n            * 时钟管理\n            * 原语操作\n                * 进程的管理，由若干原语（primitive）来执行\n        * 资源管理功能\n            * 进程管理\n            * 存储器管理\n            * 设备管理\n    * 状态\n        * 系统态，管态，内核态\n        * 用户态，目态\n* 进程的创建\n    * 进程的层次结构\n        * 父进程\n        * 子进程\n    * 引起创建进程的事件\n        * 用户登录\n        * 作业调度\n        * 提供服务\n        * 应用请求\n    * 进程的创建过程\n        * 1.申请空白PCB\n        * 2.为新进程分配其运行所需的资源\n        * 3.初始化进程块PCB\n        * 4.如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列\n    * 进程的终止\n        * 引起进程终止的事件\n            * 1.正常结束\n            * 2.异常结束\n            * 3.外界干预\n        * 进程的终止过程\n            * 1.根据被终止进程的标识符\n    * 进程的阻塞与唤醒\n        * 引起进程阻塞和唤醒的事件\n            * 请求系统服务而未满足\n            * 启动某种操作而阻塞当前进程\n            * 新数据尚未到达\n            * 无新工作可做：系统进程\n        * 进程阻塞过程(自己阻塞自己)\n        * 进程唤醒过程(系统或其他进程唤醒自己)\n    * 进程的挂起与激活\n        * suspend\n        * active\n* 进程同步\n    * 基本概念\n        * 两种形式的制约关系\n            * 间接相互制约关系\n                * 互斥——竞争\n            * 直接相互制约关系\n                * 同步——协作\n        * 临界资源\n        * 分区\n            * 进入区enter section\n            * 临界区critical section\n            * 退出区exit section\n            * 剩余区remainder section\n        * 同步机制应遵循的规则\n            * 1.空闲让进\n            * 2.忙则等待\n            * 3.有限等待\n            * 4.让权等待\n    * 进程同步机制\n        * 软件同步机制:都没有解决让权等待，而且部分方法还会产生死锁的情况\n        * 硬件同步机制\n            * 关中断\n            * 利用Test-and-Set指令实现互斥\n            * 利用swap指令实现进程互斥\n        * 信号量机制\n            * 整型信号量\n            * 记录型信号量\n                * 由于整型信号量没有遵循让权等待原则，记录型允许负数，即阻塞链表\n            * AND型信号量\n            * 信号量集\n                * 理解:AND型号量的wait和signal仅能对信号施以加1或减1操作，意味着每次只能对某类临界资源进行一个单位的申请或释放。当一次需要N个单位时，便要进行N次wait操作，这显然是低效的，甚至会增加死锁的概率。此外，在有些情况下，为确保系统的安全性，当所申请的资源数量低于某一下限值时，还必须进行管制，不予以分配。因此，当进程申请某类临界资源时，在每次分配前，都必须测试资源数量，判断是否大于可分配的下限值，决定是否予以分配\n                * 操作\n                    * Swait(S1，t1，d1…Sn，tn，dn)\n                    * Ssignal(S1，d1…Sn，dn)\n                * 特殊情况\n    * 经典进程的同步问题\n        * 生产者–消费者问题\n        * 哲学家进餐问题\n        * 读者–写者问题\n### 进程通信\n* 进程通信是指进程之间的信息交换，又称低级进程通信\n* 进程通信的类型\n    * 共享存储器系统\n        * 基于共享数据结构的通信方式\n            * 生产者和消费者\n        * 基于共享存储区的通信方式\n            * 高级通信\n    * 管道通信系统(pipe)\n        * 高级通信\n    * 消息传递系统\n        * 高级通信\n        * 方式分类\n            * 直接通信\n            * 间接通信\n    * 客服机–服务器系统\n* 消息传递通信的实现方式\n    * 直接消息传递系统\n    * 信箱通信\n### 线程的基本概念\n* 线程的引入\n    * 线程的引入正是为了简化线程间的通信，以小的开销来提高进程内的并发程度\n    * 多线程并发的不足\n        * 进程的两个基本属性\n            * 一个拥有资源的独立单位，可独立分配系统资源\n            * 一个可独立调度和分派的基本单位，PCB\n        * 程序并发执行所需付出的时空开销\n            * 创建进程\n            * 撤销进程\n            * 进程切换\n        * 进程间通信效率低\n        * 将分配资源和调度两个属性分开\n    * 线程——作为调度和分派的基本单位\n        * 进程是系统资源分配的单位，线程是处理器调度的单位\n        * 线程表示进程的一个控制点，可以执行一系列的指令。通常，和应用程序的一个函数相对应\n        * 进程分解为线程还可以有效利用多处理器和多核计算机\n* 线程与进程的比较\n    * 不同点\n        * 调度的基本单位\n        * 并发性\n    * 相似点\n        * 状态：运行、阻塞、就绪\n        * 线程具有一定的生命期\n        * 进程可创建线程，一个线程可创建另一个子线程\n        * 多个线程并发执行时仍然存在互斥与同步\n* 线程的实现\n    * 线程的实现方式\n        * 内核支持线程KST\n        * 用户级线程ULT\n        * 组合方式\n    * 多线程OS中的进程属性\n        * 进程是一个可拥有资源的基本单位\n        * 多个线程可并发执行\n        * 进程已不是可执行的实体\n    * 线程的状态和线程控制块\n        * 线程运行的三个状态\n            * 执行状态\n            * 就绪状态\n            * 阻塞状态\n        * 线程控制块TCB\n## 第三章:处理机调度与死锁\n### 处理机调度算法的目标\n* 处理机调度算法的共同目标\n    * 资源利用率:CPU的利用率=CPU有效工作时间/(CPU有效工作时间+CPU空闲等待时间)\n    * 公平性\n    * 平衡性\n    * 策略强制执行\n* 批处理系统的目标\n    * 平均周转时间短\n    * 系统吞吐量高\n    * 处理机利用率高\n* 分时系统的目标\n    * 响应时间快\n    * 均衡性\n* 实时系统目标\n    * 截止时间的保证\n    * 可预测性\n* 处理机调度的层次\n    * 高级调度（作业调度）\n        * 分时系统无需作业调度，因为需要交互\n        * 批处理系统需要作业调度\n    * 中级调度（和挂起有关）\n    * 低级调度（进程调度）\n        * 进程调度是最基本的调度，任何操作系统都有进程调度。\n        * 低级调度的三个基本机制\n            * 排队器\n            * 分派器\n            * 上下文切换\n        * 进程调度方式\n            * 非抢占方式\n            * 抢占方式\n                * 优先权原则\n                * 短进程优先原则\n                * 时间片原则\n        * 进程调度的任务\n            * 保存处理机的现场信息\n            * 按某种算法选取进程\n            * 把处理器分配给进程\n        * 进程调度的算法\n            * 优先级调度算法\n                * 优先级调度算法的类型\n                    * 非抢占式优先级调度算法\n                        * 等当前进程执行完以后，再执行另一个优先权最高的进程\n                        * 这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。 \n                    * 抢占式优先级调度算法\n                        * 不等当前进程结束，直接抢处理机\n                        * 常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。\n                * 优先级的类型\n                    * 静态优先级\n                        * 优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，例如，0~7或0~255中的某一整数， 又把该整数称为优先数。\n                        * 可以参考BIOS系统中设置boot的优先级\n                    * 动态优先级\n                        * 在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。\n            * 轮转调度算法\n                * 基本原理:在轮转(RR)法中，系统根据FCFS策略，将所有的就绪进程排成一个就绪队列，并可设置每隔一定时间间隔(如30ms)即产生一次中断，激活系统中的进程调度程序，完成一次调度，将CPU分配给队首进程，令其执行\n                * 进程切换时机\n                    * 时间片未用完，进程完成\n                    * 时间片到，进程未完成\n                * 时间片大小的确定\n                    * 太小利于短作业，增加系统切换开销\n                    * 太长就退化为FCFS算法\n                    * 一般选择: q略大于一次交互所需要的时间，使大多数进程在一个时间片内完成\n                * 一般来说，平均周转时间将比SJF长，但是有较好的响应时间\n            * 多队列调度算法\n            * 多级反馈队列调度算法\n                * 调度机制\n                    * 设置多个就绪队列\n                    * 每个队列都采用FCFS算法\n                    * 按照队列优先级调度，在第n队列中采取按时间片轮转的方式运行\n                * 调度算法的性能\n                    * 对于终端型用户，由于作业小，感觉满意\n                    * 对于短批处理作业用户，周转时间也较小\n                    * 长批处理作业用户，也能够得到执行\n            * 基于公平原则的调度算法\n                * 保证调度算法\n                * 公平分享调度算法\n### 作业与作业调度\n* 作业\n    * 作业不仅包含程序和数据，还配有一份作业说明书，系统根据说明书对程序的运行进行控制。批处理系统是以作业为单位从外存掉入内存的。\n* 作业控制块JCB\n    * 为每个作业设置一个JCB，保存了对作业管理调度的全部信息。是作业存在的标志。\n* 作业步\n    * 作业步，每个作业都必须经过若干相对独立，有相互关联的顺序步骤才能得到结果。每一个步骤就是一个作业步。\n* 作业运行的三个阶段\n    * 收容阶段\n    * 运行阶段\n    * 完成阶段\n* 作业运行的三个状态\n    * 后备状态\n    * 运行状态\n    * 完成状态\n* 作业调度的主要任务\n    * 接纳多少个作业\n    * 接纳哪些作业\n* 先来先服务(first–come first–served，FCFS)调度算法\n    * 比较有利于长作业，而不利于短作业。\n    * 有利于CPU繁忙的作业，而不利于I/O繁忙的作业。\n* 短作业优先(short job first，SJF)的调度算法\n    * 优点\n        * 比FCFS改善平均周转时间和平均带权周转时间，缩短作业的等待时间；\n        * 提高系统的吞吐量；\n    * 缺点\n        * 必须预知作业的运行时间\n        * 对长作业非常不利，长作业的周转时间会明显地增长\n        * 在采用SJF算法时，人–机无法实现交互\n        * 该调度算法完全未考虑作业的紧迫程度，故不能保证紧迫性作业能得到及时处理\n* 优先级调度算法(priority–scheduling algorithm，PSA)\n* 高响应比优先调度算法(Highest Response Ratio Next,HRRN)\n    * 原理\n        * 在每次选择作业投入运行时，先计算此时后备作业队列中每个作业的响应比RP然后选择其值最大的作业投入运行\n        * 优先权=(等待时间+要求服务时间)/要求服务时间=响应时间/要求服务时间=1+等待时间/要求服务时间\n    * 特点\n        * 如果作业的等待时间相同，则要求服务的时间愈短，其优先权愈高，因而类似于SJF算法，有利于短作业\n        * 当要求服务的时间相同时，作业的优先权又决定于其等待时间，因而该算法又类似于FCFS算法\n        * 对于长时间的优先级，可以为随等待时间的增加而提高，当等待时间足够长时，也可获得处理机\n### 实时调度(HRT和SRT任务)\n* 实现实时调度的基本条件\n    * 提供必要信息\n        * 就绪时间\n        * 开始截止时间和完成截止时间\n        * 处理时间\n        * 资源要求\n        * 优先级\n    * 系统处理能力强\n        * ∑(Ci/Pi)≤1\n        * N个处理机:∑(Ci/Pi)≤N\n    * 采用抢占式调度机制\n    * 具有快速切换机制\n        * 对中断的快速响应能力\n        * 快速的任务分派能力\n* 实时调度算法的分类\n    * 非抢占式调度算法\n        * 非抢占式轮转调度算法\n        * 非抢占式优先调度算法\n    * 抢占式调度算法\n        * 基于时钟中断的抢占式优先级调度算法\n        * 立即抢占的优先级调度算法\n* 最早截止时间优先EDF(Earliest Deadline First)算法\n    * 根据任务的开始截至时间来确定任务的优先级\n        * 截至时间越早，优先级越高\n    * 非抢占式调度方式用于非周期实时任务\n    * 抢占式调度方式用于周期实时任务\n* 最低松弛度优先LLF(Least Laxity First)算法\n    * 类似EDF\n    * 算法根据任务紧急(或松弛)的程度，来确定任务的优先级。任务的紧急程度愈高，为该任务所赋予的优先级就愈高， 以使之优先执行。\n    * 松弛度例子\n        * 例如，一个任务在200ms时必须完成，而它本身所需的运行时间就有100ms，因此，调度程序必须在100 ms之前调度执行，该任务的紧急程度(松弛程度)为100 ms\n* 优先级倒置(Priority inversion problem)\n    * 优先级倒置的形成\n        * 高优先级进程被低优先级进程延迟或阻塞。\n    * 优先级倒置的解决方法\n        * 简单的:假如进程P3在进入临界区后P3所占用的处理机就不允许被抢占\n        * 实用的:建立在动态优先级继承基础上的\n### 死锁概述\n* 资源问题\n    * 可重用性资源\n        * 计算机外设\n    * 消耗性资源\n        * 数据，消息\n    * 可抢占性资源\n        *  不引起死锁\n        * CPU，内存 \n    * 不可抢占性资源\n        * 光驱，打印机\n* 计算机系统中的死锁\n    * 竞争不可抢占性资源引起死锁\n    * 竞争可消耗资源引起死锁\n    * 进程推进顺序不当引起死锁\n* 死锁的定义，必要条件和处理方法\n    * 定义:如果一组进程中的每一个进程都在等待仅由该进程中的其他进程才能引发的事件，那么该组进程是死锁的\n    * 产生死锁的必要条件\n        * 互斥条件\n        * 请求和保存条件\n        * 不可抢占条件\n        * 循环等待条件\n            * 如果每个资源只有一个实例，则环路等待条件是死锁存在的充分必要条件\n    * 处理死锁的方法\n        * 预防死锁\n            * 静态方法，在进程执行前采取的措施，通过设置某些限制条件，去破坏产生死锁的四个条件之一，防止发生死锁。\n            * 预防死锁的策略\n                * 破坏\"请求和保存\"条件\n                    * 第一种协议\n                        * 所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源\n                        * 优点:简单，易行，安全\n                        * 缺点\n                            * 资源被严重浪费，严重地恶化了资源的利用率\n                            * 使进程经常会发生饥饿现象\n                    * 第二种协议\n                        * 它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的，且已用毕的全部资源，然后再请求新的所需资源\n                * 破坏\"不可抢占\"条件\n                    * 当一个已经保存了某些不可被抢占资源的进程，提出新的资源请求而不能得到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请\n                * 破坏\"循环等待\"条件\n                    * 对系统所以资源类型进行线性排序，并赋予不同的序号\n                    * 例如令输入机的序号为1，打印机序号为2，磁盘机序号为3等。所有进程对资源的请求必须严格按资源序号递增的次序提出。\n        * 避免死锁\n            * 动态的方法，在进程执行过程中采取的措施，不需事先采取限制措施破坏产生死锁的必要条件，而是在进程申请资源时用某种方法去防止系统进入不安全状态，从而避免发生死锁。如银行家算法\n            * 避免死锁的策略\n                * 系统安全状态\n                    * 安全状态\n                        * 某时刻，对于并发执行的n个进程，若系统能够按照某种顺序如<p1,p2…pn>来为每个进程分配所需资源，直至最大需求，从而使每个进程都可顺利完成，则认为该时刻系统处于安全状态，这样的序列为安全序列\n                    * 安全状态之例\n                    * 由安全状态向不安全状态的转换\n                * 利用银行家算法避免死锁\n                    * 含义:每一个新进程在进入系统时，它必须申明在运行过程中，可能需要每种资源类型的最大单元数目，其数目不应超过系统所拥有的资源总量。当进程请求一组资源时，系统必须首先确定是否有足够的资源分配给该进程。若有，再进一步计算在将这些资源分配给进程后，是否会使系统处于不安全状态。如果不会，才将资源分配给它，否则让进程等待\n                    * 银行家算法中的数据结构\n                        * 可用资源向量 Available[m]：m为系统中资源种类数，Available[j]=k表示系统中第j类资源数为k个。\n                        * 最大需求矩阵 Max[n,m]：n为系统中进程数，Max[i,j]=k表示进程i对j类资源的最大需求数为中k。\n                        * 分配矩阵 Allocation[n，m]:它定义了系统中每一类资源当前已分配给每一进程资源数，   Allocation[i,j] = k表示进程i已分得j类资源的数目为k个。\n                        * 需求矩阵 Need[n,m]：它表示每个进程尚需的各类资源数，Need[i,j]=k 表示进程i   还需要j类资源k个。Need[i,j]=Max[i,j] - Allocation[i,j]\n                    * 银行家算法\n                    * 安全性算法\n                    * 银行家算法之例\n                    * 解题\n                        * 矩阵\n                        * 列表\n        * 检测死锁\n            * 死锁的检测与解除\n                * 死锁的检测\n                    * 资源分配图\n                        * 简化步骤\n                            * 选择一个没有阻塞的进程p\n                            * 将p移走，包括它的所有请求边和分配边\n                            * 重复步骤1，2，直至不能继续下去\n                    * 死锁定理\n                        * 若一系列简化以后不能使所有的进程节点都成为孤立节点\n                    * 检测时机\n                        *  当进程等待时检测死锁 （其缺点是系统的开销大）\n                        *  定时检测\n                        *  系统资源利用率下降时检测死锁\n                    * 死锁检测中的数据结构\n                * 死锁的解除\n                    * 抢占资源\n                    * 终止(或撤销)进程\n                    * 终止进程的方法\n                        * 终止所有死锁进程\n                        * 逐个终止进程\n                            * 代价最小\n                                * 进程的优先级的大小\n                                * 进程已执行了多少时间，还需时间\n                                * 进程在运行中已经使用资源的多少，还需多少资源\n                                * 进程的性质是交互式还是批处理的\n                    * 付出代价最小的死锁解除算法\n                        * 是使用一个有效的挂起和解除机构来挂起一些死锁的进程\n        * 解除死锁\n## 第四章:存储器管理\n### 存储器的层次结构\n* 多层结构的存储系统\n    * 存储器的多层结构\n        * CPU寄存器\n        * 主存\n        * 辅存\n    * 可执行存储器\n        * 寄存器和主存的总称\n        * 访问速度快，进程可以在很少的时钟周期内用一条load或store指令完成存取。\n* 主存储器与寄存器\n* 高速缓存和磁盘缓存\n### 程序的装入和链接\n* 步骤\n    * 编译\n        * 源程序 ->目标模块（Object modules）--------Compiler\n            * 由编译程序对用户源程序进行编译，形成若干个目标模块\n    * 链接\n        * 一组目标模块 ->装入模块 （Load Module）----------Linker\n            * 由链接程序将编译后形成的一组目标模板以及它们所需要的库函数链接在一起，形成一个完整的装入模块\n    * 装入\n        * 装入模块 ->内存  --------Loader\n            * 由装入程序将装入模块装入内存\n* 程序的装入\n    * 绝对装入方式\n        * 在编译时，如果知道程序将驻留在内存中指定的位置。编译程序将产生绝对地址的目标代码。\n    * 可重定位装入方式\n        * 在可执行文件中，列出各个需要重定位的地址单元和相对地址值。当用户程序被装入内存时，一次性实现逻辑地址到物理地址的转换，以后不再转换(一般在装入内存时由软件完成)。\n        * 优点：不需硬件支持，可以装入有限多道程序。\n        * 缺点：一个程序通常需要占用连续的内存空间，程序装入内存后不能移动。不易实现共享。\n    * 动态运行时的装入方式\n        * 动态运行时的装入程序在把装入模块装入内存后，并不立即把装入模块中的逻辑地址转换为物理地址，而是把这种地址转换推迟到程序真正要执行时才进行\n        * 优点：\n            * OS可以将一个程序分散存放于不连续的内存空间，可以移动程序，有利用实现共享。\n            * 能够支持程序执行中产生的地址引用，如指针变量（而不仅是生成可执行文件时的地址引用）。\n        * 缺点：需要硬件支持，OS实现较复杂。\n        * 它是虚拟存储的基础。\n* 程序的链接\n    * 静态链接方式(lib)\n    * 装入时动态链接\n    * 运行时动态链接(dll)\n### 连续分配存储管理方式\n* 连续分配\n    * 单一连续分配(DOS)\n    * 固定分区分配(浪费很多空间)\n    * 动态分区分配\n* 地址映射和存储保护措施\n    * 基址寄存器：程序的最小物理地址\n    * 界限寄存器：程序的逻辑地址范围\n    * 物理地址 = 逻辑地址 + 基址\n* 内碎片：占用分区之内未被利用的空间\n* 外碎片：占用分区之间难以利用的空闲分区（通常是小空闲分区）\n* 把内存划分为若干个固定大小的连续分区。固定式分区又称为静态分区。\n    * 分区大小相等：只适合于多个相同程序的并发执行（处理多个类型相同的对象）。\n    * 分区大小不等：多个小分区、适量的中等分区、少量的大分区。根据程序的大小，分配当前空闲的、适当大小的分区。\n    * 优点：无外碎片、易实现、开销小。\n    * 缺点：\n        * 存在内碎片，造成浪费\n        * 分区总数固定，限制了并发执行的程序数目。\n        * 通用Os很少采用，部分控制系统中采用\n* 动态创建分区：指在作业装入内存时，从可用的内存中划出一块连续的区域分配给它，且分区大小正好等于该作业的大小。可变式分区中分区的大小和分区的个数都是可变的，而且是根据作业的大小和多少动态地划分。\n    * 基于顺序搜索的动态分区分配算法\n        * 首次适应算法（first fit,FF）\n            * 顺序找，找到一个满足的就分配，但是可能存在浪费\n            * 这种方法目的在于减少查找时间。\n            * 空闲分区表（空闲区链）中的空闲分区要按地址由低到高进行排序\n        * 循环首次适应算法（next fit，NF）\n            * 相对上面那种，不是顺序，类似哈希算法中左右交叉排序\n            * 空闲分区分布得更均匀，查找开销小\n            * 从上次找到的空闲区的下一个空闲区开始查找，直到找到第一个能满足要求的的空闲区为止，并从中划出一块与请求大小相等的内存空间分配给作业。\n        * 最佳适应算法（best fit，BF）\n            * 找到最合适的，但是大区域的访问次数减少\n            * 这种方法能使外碎片尽量小。\n            * 空闲分区表（空闲区链）中的空闲分区要按大小从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。\n        * 最坏适应算法（worst fit，WF）\n            * 相对于最好而言，找最大的区域下手，导致最大的区域可能很少，也造成许多碎片\n            * 空闲分区按大小由大到小排序\n    * 基于索引搜索的动态分区分配算法\n        * 快速适应算法（quick fit）\n        * 伙伴系统（buddy system）\n        * 哈希算法\n    * 动态可重定位分区分配\n        * 紧凑\n        * 动态重定位\n            * 动态运行时装入，地址转化在指令执行时进行，需获得硬件地址变换机制的支持\n            * 内存地址=相对地址+起始地址\n        * 动态重定位分区分配算法\n            * 1、在某个分区被释放后立即进行紧凑，系统总是只有一个连续的分区而无碎片，此法很花费机时。\n            * 2、当“请求分配模块”找不到足够大的自由分区分给用户时再进行紧凑，这样紧缩的次数比上种方法少得多，但管理复杂。采用此法的动态重定位分区分配算法框图如下：\n    * 优点：没有内碎片。\n    * 缺点：外碎片。\n### 对换（了解）\n* 系统把所有的作业放在外存，每次只调用一个作业进入内存运行，当时间片用完时，将它调至外存后备队列上等待，在从后备队列调入另一个作业进入内存运行。\n### 基本分页存储管理方式\n* 分页存储管理的基本方式\n    * 页面\n        * 将一个进程的逻辑地址空间分成若干个大小相等的片\n    * 页框（frame）\n        * 内存空间分成与页面相同大小的存储块\n    * 由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”\n    * 地址结构\n        * 页号P+位移量W(0-31)\n    * 页表\n        * 在分页系统中，允许将进程的各个页离散地存储在内存在内存的任一物理块中，为保证进程仍然能够正确地运行，即能在内存中找到每一个页面所对应的物理块，系统又为每个进程建立了一张页面映像表，简称页表\n        * 页表的作用是实现从页面号到物理块号的地址映射\n* 地址变换机构\n    * 基本的地址变换机构\n        * 要访问两次内存\n        * 页表大都驻留在内存中\n        * 为了实现地址变换功能，在系统中设置页表寄存器（PTR），用来存放页表的始址和页表的长度。\n        * 在进程未执行时，每个进程对应的页表的始址和长度存放在进程的PCB中，当该进程被调度时，就将它们装入页表寄存器。\n    * 具有快表的地址变换机构\n        * 提高了效率，此处会有计算题\n        * 如果页表存放在内存中，则每次访问内存时，都要先访问内存中的页表，然后根据所形成的物理地址再访问内存。这样CPU存一个数据必须访问两次内存，从而使计算机的处理速度降低了1/2。\n        * 为了提高地址变换的速度，在地址变换机构中增设了一个具有并行查询功能的特殊的高速缓冲存储器，称为“联想存储器”或“快表”，用以存放当前访问的那些页表项。\n        * 地址变换过程为：\n            * 1、CPU给出有效地址\n            * 2、地址变换机构自动地将页号送入高速缓存，确定所需要的页是否在快表中。\n            * 3、若是，则直接读出该页所对应的物理块号，送入物理地址寄存器；\n            * 4、若快表中未找到对应的页表项，则需再访问内存中的页表\n            * 5、找到后，把从页表中读出的页表项存入快表中的一个寄存器单元中，以取代一个旧的页表项。\n* 两级和多级页表\n    * 主要是有的时候页表太多了，要化简\n    * 格式：外层页号P1+外层页内地址P2+页内地址d\n    * 基本方法：将页表进行分页，每个页面的大小与内存物理块的大小相同，并为它们进行编号，可以离散地将各个页面分别存放在不同的物理块中。\n* 反置页表\n    * 反置页表为每一个物理块（页框）设置一个页表项，并按物理块排序，其内容则是页号和其所属进程的标识。\n* 优点：\n    * 没有外碎片，每个内碎片不超过页大小。\n    * 一个程序不必连续存放。\n    * 便于改变程序占用空间的大小。即随着程序运行而动态生成的数据增多，地址空间可相应增长。\n* 缺点：程序全部装入内存。\n### 分段存储管理方式\n* 引入\n    * 方便编程\n    * 信息共享\n    * 动态增长\n    * 动态链接\n* 在分段存储管理方式中，作业的地址空间被划分为若干个段，每个段是一组完整的逻辑信息，每个段都有自己的名字，都是从零开始编址的一段连续的地址空间，各段长度是不等的。\n* 内存空间被动态的划分为若干个长度不相同的区域，称为物理段，每个物理段由起始地址和长度确定\n* 分段系统的基本原理\n    * 分段\n        * 格式：段号+段内地址\n    * 段表\n        * 段表实现了从逻辑段到物理内存区的映射。\n    * 地址变换机构\n* 和分页的区别\n    * 页是信息的物理单位\n    * 页的大小固定且由系统固定\n    * 分页的用户程序地址空间是一维的\n    * 通常段比页大，因而段表比页表短，可以缩短查找时间，提高访问速度。\n    * 分页是系统管理的需要，分段是用户应用的需要。一条指令或一个操作数可能会跨越两个页的分界处，而不会跨越两个段的分界处。\n* 信息共享\n    * 这是分段最重要的优点\n* 段页式存储管理方式\n    * 基本原理\n        * 格式：段号（S）+段内页号（P）+页内地址（W）\n    * 地址变换过程\n        * 需要三次访问过程\n    * 在段页式系统中，为了获得一条指令或数据，需三次访问内存：第一次访问内存中的段表，从中取得页表始址；第二次访问内存中的页表，从中取出该页所在的物理块号，并将该块号与页内地址一起形成指令或数据的物理地址；第三次访问才是真正根据所得的物理地址取出指令或数据。\n## 第五章：虚拟存储器\n### 常规存储管理方式的特征\n* 一次性\n* 驻留性\n### 局部性原理\n* 程序在执行时将呈现出局部性特征，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域\n* 时间局限性\n    * 如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环操作\n* 空间局限性\n    * 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。\n### 定义\n* 指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统\n### 优点\n* 大程序：可在较小的可用内存中执行较大的用户程序；\n* 大的用户空间：提供给用户可用的虚拟内存空间通常大于物理内存(real memory)\n* 并发：可在内存中容纳更多程序并发执行；\n* 易于开发：不必影响编程时的程序结构\n* 以CPU时间和外存空间换取昂贵内存空间，这是操作系统中的资源转换技术\n### 特征\n* 离散性\n    * 指在内存分配时采用离散的分配方式，它是虚拟存储器的实现的基础\n* 多次性\n    * 指一个作业被分成多次调入内存运行，即在作业运行时没有必要将其全部装入，只须将当前要运行的那部分程序和数据装入内存即可。多次性是虚拟存储器最重要的特征\n* 对换性\n    * 指允许在作业的运行过程中在内存和外存的对换区之间换进、换出。\n* 虚拟性\n    * 指能够从逻辑上扩充内存容量，使用户所看到的内存容量远大于实际内存容量。\n### 虚拟存储器的实现方式\n* 请求分页存储管理方式\n    * 硬件\n        * 请求页表机制\n            * 格式：页号+物理块号+状态位P+访问字段A+修改位M+外存地址\n        * 缺页中断机构\n        * 地址变换机构（过程图很关键）\n    * 请求分页中的内存分配\n        * 最小物理块数\n            * 即能保证进程正常运行所需的最小物理块数\n        * 内存分配策略\n            * 固定分配局部置换（国王的大儿子）\n            * 可变分配全局置换（国王的二儿子）\n            * 可变分配局部置换（国王的小儿子）\n    * 物理块分配算法\n        * 平均分配算法\n        * 按比例分配算法\n        * 考虑优先权的分配算法\n    * 页面调入策略\n        * 系统应在何时调入所需页面\n            * 预调页策略（不能实现）\n            * 请求调页策略（需要才给）\n        * 系统应该从何处调入这些页面\n            * 对换区\n            * 文件区\n        * 页面调入过程\n        * 缺页率（出计算题）\n* 请求分段系统\n    * 硬件\n        * 请求分段的段表机构\n        * 缺段中断机构\n        * 地址变换机构\n### 页面置换算法\n* 抖动的概念\n    * 即刚被换出的页很快又要被访问，需要将它重新调入，此时又需要再选一页调出\n* 最佳置换算法(需要预知后面进程，所以不能实现)\n* 先进先出页面置换算法（FIFO）\n    * 选择在内存中驻留时间最久的页面予以淘汰\n* 最近最久未使用置换算法（LRU）Recently\n    * 寄存器支持\n    * 特殊的栈结构\n* 最少使用置换算法（LFU）Frequently\n* clock置换算法（对访问位A的判断）\n    * 改进型——增加对修改位M思维判断\n* 页面缓冲算法（PBA,page buffering algorithm）\n    * 空闲页面链表\n    * 修改页面链表\n## 第六章：输入输出系统\n### I/O系统的功能，模型和接口\n* I/O系统管理的对象是I/O设备和相应的设备控制器。\n* I/O系统的基本功能\n    * 隐藏物理设备的细节\n    * 与设备的无关性\n    * 提高处理机和I/O设备的利用率\n    * 对I/O设备进行控制\n    * 确保对设备的正确共享\n    * 错误处理\n* I/O软件的层次结构\n    * 用户层I/O软件\n    * 设备独立性软件\n    * 设备驱动程序（厂家开发）\n    * 中断处理程序\n    * 硬件\n* I/O系统的分层\n    * 中断处理程序\n    * 设备驱动程序\n    * 设备独立性软件\n* I/O系统接口\n    * 块设备接口\n        * 指以数据块为单位来组织和传送数据信息的设备\n        * 典型的块设备是磁盘、光盘\n        * 块设备的基本特征\n            * ①传输速率较高，通常每秒钟为几兆位；\n            * ②它是可寻址的，即可随机地读/写任意一块；\n            * ③磁盘设备的I/O采用DMA方式。\n    * 流设备接口\n        * 又称字符设备指以单个字符为单位来传送数据信息的设备\n        * 这类设备一般用于数据的输入和输出，有交互式终端、打印机\n        * 字符设备的基本特征\n            * ①传输速率较低；\n            * ②不可寻址，即不能指定输入时的源地址或输出时的目标地址；\n            * ③字符设备的I/O常采用中断驱动方式。\n    * 网络通信接口\n        * 提供网络接入功能，使计算机能通过网络与其他计算机进行通信或上网浏览。\n### I/O设备和设备控制器\n* 分类\n    * 使用特性分\n        * 存储设备\n        * I/O设备\n    * 传输速率分\n        * 低速设备（几字节——几百字节）\n            * 典型的设备有键盘、鼠标、语音的输入\n        * 中速设备（数千——数万字节）\n            * 典型的设备有行式打印机、激光打印机\n        * 高速设备（数十万——千兆字节）\n            * 典型的设备有磁带机、磁盘机、光盘机\n* 设备并不是直接与CPU进行通信，而是与设备控制器通信。在设备与设备控制器之间应该有一个接口。\n    * 数据信号：控制器 ←  设备 ←  控制器\n        * 传送数据信号，输入、输出bit\n    * 控制信号: 控制器  →  设备\n        * 执行读、写操作的信号\n    * 状态信号：设备当前使用状态\n* 设备控制器\n    * 主要功能：控制一个或多个I/O设备，以实现I/O设备和计算机之间的数据交换\n    * 基本功能\n        * 接收和识别命令\n            * 控制寄存器、命令译码器\n        * 数据交换\n            * 实现CPU与控制器，控制器与设备间的数据交换\n        * 标识和报告设备的状态\n        * 地址识别\n            * 配置地址译码器，识别不同的设备\n        * 数据缓冲区\n        * 差错控制\n    * 设备控制器的组成\n        * 设备控制器与处理机（CPU）的接口\n            * 实现CPU与设备控制器之间的通信\n        * 设备控制器与设备的接口\n            * 控制器可连接多个设备\n        * I/O逻辑\n            * 实现对设备的控制\n            * CPU利用该逻辑向控制器发送I/O命令\n            * 命令、地址译码\n* 内存映像I/O\n    * 驱动程序将抽象I/O命令转换出的一系列具体的命令，参数等数据装入设备控制器的相应寄存器，由控制器来执行这些命令，具体实施对I/O设备的操作\n* I/O通道\n    * 目的：建立独立的I/O操作(组织, 管理和结束)，使由CPU处理的I/O工作转由通道完成（解放CPU，实现并行）\n\n    * 什么是I/O通道？\n        *  是一种特殊的处理机，具有通过执行通道程序完成I/O操作的指令\n        *  特点：指令单一(局限于与I/O操作相关的指令)，与CPU共享内存\n    * 基本过程：\n        * CPU向通道发出I/O指令->通道接收指令->从内存取出通道程序处理I/O->向CPU发出中断\n    * 通道类型\n        * 字节多路通道\n            * 低中速连接子通道时间片轮转方式共享主通道\n            * 字节多路通道不适于连接高速设备，这推动了按数组方式进行数据传送的数组选择通道的形成。\n        * 数组选择通道\n            * 这种通道可以连接多台高速设备，但只含有一个分配型子通道，在一段时间内只能执行一道通道程序， 控制一台设备进行数据传送， 直至该设备传送完毕释放该通道。这种通道的利用率很低。\n        * 数组多路通道\n            * 含有多个非分配型子通道，前两种通道的组合，通道利用率较好\n    * 瓶颈问题\n        * 原因;通道不足\n        * 解决办法：增加设备到主机间的通路，而不增加通道（结果类似RS触发器）\n### 中断机构和中断处理程序\n* 中断\n    * 分类\n        * 中断（外部触发）\n            * 对外部I/O设备发出的中断信号的响应\n        * 陷入（内部原因：除0）\n            * 由CPU内部事件引起的中断\n    * 中断向量表（类比51单片机）\n        * 中断程序的入口地址表\n    * 中断优先级\n        * 对紧急程度不同的中断处理方式\n    * 对多中断源的处理方式\n        * 屏蔽中断\n        * 嵌套中断\n* 中断处理程序\n    * 测定是否有未响应的中断信号\n    * 保护被中断进程的CPU环境\n    * 转入相应的设备处理程序\n    * 中断处理\n    * 恢复CPU 的现场并退出中断\n### 设备驱动程序\n* 是I/O进程与设备控制器之间的通信程序，又由于它常以进程的形式存在，故以后就简称为设备驱动进程\n* 主要任务是接受来自它上一层的与设备无关软件的抽象请求，并执行这个请求。\n* 功能\n    * 1) 接收由I/O进程发来的命令和参数， 并将命令中的抽象要求转换为具体要求。例如，将磁盘块号转换为磁盘的盘面、 磁道号及扇区号。\n    * 2) 检查用户I/O请求的合法性，了解I/O设备的状态，传递有关参数，设置设备的工作方式。 \n    * 3) 发出I/O命令，如果设备空闲，便立即启动I/O设备去完成指定的I/O操作；如果设备处于忙碌状态，则将请求者的请求块挂在设备队列上等待。\n    * 4) 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。\n    * 5) 对于设置有通道的计算机系统，驱动程序还应能够根据用户的I/O请求，自动地构成通道程序。 \n* 设备驱动程序的处理过程\n    * 将用户和上层软件对设备控制的抽象要求转换成对设备的具体要求，如对抽象要求的盘块号转换为磁盘的盘面、磁道及扇区。\n    * 检查I/O请求的合理性。\n    * 读出和检查设备的状态，确保设备处于就绪态。\n    * 传送必要的参数，如传送的字节数，数据在主存的首址等。\n    * 工作方式的设置。\n    * 启动I/O设备，并检查启动是否成功，如成功则将控制返回给I/O控制系统，在I/O设备忙于传送数据时，该用户进程把自己阻塞，直至中断到来才将它唤醒，而CPU可干别的事。\n* 对I/O设备的控制方式\n    * I/O控制的宗旨\n        * 减少CPU对I/O控制的干预\n        * 充分利用CPU完成数据处理工作\n    * I/O 控制方式\n        * 轮询的可编程I/O方式\n        * 中断驱动I/O方式\n        * DMA控制方式\n        * I/O通道控制方式\n* DMA控制器组成\n    * 主机与DMA控制器的接口\n    * DMA控制器与块设备的接口\n    * I/O控制逻辑\n### 与设备无关的I/O软件\n* 基本概念\n    * 含义： 应用程序独立于具体使用的物理设备。\n    * 驱动程序是一个与硬件(或设备)紧密相关的软件。为实现设备独立性，须在驱动程序上设置一层软件，称为设备独立性软件。\n    * 设备独立性(Device Independence)的优点\n        * 以物理设备名使用设备\n        * 引入了逻辑设备名\n        * 逻辑设备名称到物理设备名称的转换（易于实现I/O重定向）\n* 与设备无关的软件\n    * 设备驱动程序的统一接口\n    * 缓存管理\n    * 差错控制\n    * 对独立设备的分配与回收\n    * 独立于设备的逻辑数据块\n* 设备分配中的数据结构\n    * 设备控制表DCT\n    * 控制器控制表COCT\n    * 通道控制表CHCT\n    * 显然，在有通道的系统中，一个进程只有获得了通道，控制器和所需设备三者之后，才具备了进行I/O操作的物理条件\n    * 系统设备表SDT\n    * 逻辑设备表LUT\n    * 分配的流程，从资源多的到资源紧张的:LUT->SDT->DCT->COCT->CHCT\n    * 在申请设备的过程中，根据用户请求的I/O设备的逻辑名，查找逻辑设备和物理设备的映射表；以物理设备为索引，查找SDT，找到该设备所连接的DCT；继续查找与该设备连接的COCT和CHCT，就找到了一条通路。\n### 用户层的I/O软件\n* 系统调用与库函数\n    * OS向用户提供的所有功能，用户进程都必须通过系统调用来获取\n    * 在C语言以及UNIX系统中，系统调用（如read）与各系统调用所使用的库函数（如read）之间几乎是一一对应的。而微软的叫Win32API\n* 假脱机系统（spooling）\n    * spooling技术是对脱机输入/输出系统的模拟\n    * 主要组成\n        * 输入/输出井\n        * 输入/输出缓冲区\n        * 输入/输出进程\n        * 井管理程序\n    * 特点（体现操作系统的虚拟性）\n        * 提高了I/O的速度\n            * 对数据所进行的I/O操作，已从对低速设备演变为对输入井或输出井中的数据存取。\n        * 将独占设备改造为共享设备\n            * 实际分给用户进程的不是打印设备，而是共享输出井中的存储区域 \n        * 实现了虚拟设备功能\n            * 将独占设备变成多台独占的虚拟设备。\n### 缓冲区管理\n* 缓冲的引入（原因）\n    * 缓和CPU与I/O设备间速度不匹配的矛盾\n    * 减少对CPU的中断频率，放宽对CPU中断响应时间的限制\n    * 提高CPU和I/O设备之间的并行性\n    * 解决数据粒度不匹配的问题\n* 单缓冲区\n    * 即在CPU计算的时候，将数据数据输入到缓冲区(大小取决与T和C的大小)\n* 双缓冲区\n    * 即允许CPU连续工作（T不断）\n* 环形缓冲区（专为生产者和消费者打造）\n    * 组成\n        * 多个缓冲区\n        * 多个指针\n    * 使用\n        * Getbuf过程\n        * Releasebuf过程\n    * 同步问题\n* 缓冲池(理解为更大的缓冲区)\n    * 组成\n        * 空白缓冲队列（emq）\n            * 由空缓冲区链接而成F(emq)，L(emq)分别指向该队列首尾缓冲区\n        * 输入队列（inq）\n            * 由装满输入数据的缓冲区链接而成F(inq)，L(inq)分别指向该队列首尾缓冲区\n        * 输出队列（outq）\n            * 由装满输出数据的缓冲区链接而成F(outq)， L(outq)分别指向该队列首尾缓冲\n    * Getbuf和Putbuf过程\n        * 收容：缓冲池接收外界数据\n        * 提取：外界从缓冲池获得数据\n    * 缓冲区工作方式（从缓冲区的角度来看）\n        * 收容输入\n        * 提取输入\n        * 收容输出\n        * 提取输出\n### 磁盘存储器的性能和调度\n* 数据的组织和格式\n* 磁盘的类型\n    * 固定头磁盘（贵）\n    * 移动头磁盘\n* 磁盘访问的时间（关键）\n    * 寻道时间Ts=m*n+s\n    * 旋转延迟时间Tr\n    * 传输时间Tt=b/rN\n    * 总时间Ta=Ts+1/2r+b/rN\n* 磁盘的调度算法（掌握图表）\n    * 先来先服务（FCFS）\n        * 优点：公平，简单\n        * 缺点：可能导致某些进程的请求长期得不到满足\n    * 最短寻道时间优先（SSTF）\n        * 说明：要求访问的磁道和当前磁头所在的磁道距离最近，以使每次的寻道时间最短\n    * 扫描算法（SCAN）\n        * 扫描算法不仅考虑到欲访问的磁道与当前磁道间的距离，更优先考虑的是磁道当前的移动方向\n        * 联想电梯的运行\n        * 可防止低优先级进程出现“饥饿”的现象\n    * 循环扫描算法（CSCAN）\n        * 算法规定磁头单向移动，例如，只是自里向外移动，当磁头移到最外的磁道并访问后，磁头立即返回到最里的欲访问磁道，亦即将最小磁道号紧接着最大磁道号构成循环，进行循环扫描\n    * NStepScan算法\n        * N步SCAN算法是将磁盘请求队列分成若干个长度为N的子队列，磁盘调度将按FCFS算法依次这些子队列。\n    * FSCAN算法\n        * 是Nstepscan算法的简化，将磁盘请求队列分成两个子队列\n## 第七章：文件管理\n### 数据项\n* 基本数据项\n* 组合数据项\n### 记录\n* 记录是一组相关数据项的集合，用于描述一个对象在某个方面的属性\n### 文件\n* 文件类型\n* 文件长度\n* 文件的物理位置\n* 文件的建立时间\n### 文件操作\n* 创建文件\n* 删除文件\n* 读文件\n* 写文件\n* 设置文件读写的位置\n### 文件的逻辑结构\n* 顺序文件\n* 记录寻址\n* 索引文件\n* 索引顺序文件\n* 直接文件和哈希文件\n### 文件目录\n* 文件控制块（FCB）\n    * 文件名+inode(属性)\n* 简单的文件目录\n    * 单级文件目录\n        * 查找慢\n        * 不允许重名\n        * 不便于实现文件共享\n    * 两级文件目录\n        * 提高检索速度，从M*N到M+N\n* 树形结构目录\n    * 路径名\n        * “..”是父目录\n        * “/”是根目录\n        * 区别绝对路径和相对路径（../.../.../1/2/3/）\n### 文件共享\n* 有向无循环图（DAG）\n* 利用符号链接实现文件共享\n    * 实际上就是“快捷方式”\n### 文件保护\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png)\n","tags":["408"]},{"title":"数据结构","url":"/post/408/数据结构/index.html  2019/12/05/408/数据结构/","content":"# 数据结构\n## 第一章：数据结构的\n基本概念\n### 定义\n* 在任何问题中，数据元素都不是孤立存在的，而是在它们之间存在着某种关系，这种数据元素相互之间的关系称为结构（Structure）。数据结构是相互之间存在一种或多种特定关系的数据元素的集合。数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算。数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。\n### 逻辑结构\n* 逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。它与数据的存储无关，是独立于计算机的\n* 数据的逻辑结构分为线性结构和非线性结构\n    * 集合 结构中的数据元素之间除了“同属于一个集合”的关系外，别无其他关系。 类似于数学上的集合\n    * 线性结构 结构中的数据元素之间只存在一对一的关系。比如排队\n    * 树形结构 结构中的数据元素之间存在一对多的关系。比如家族族谱\n    * 图状结构或网状结构 结构中的数据元素之间存在多对多的关系。 比如地图\n### 物理结构\n* 存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。它包括数据元素的表示和关系的表示。数据的存储结构是逻辑结构用计算机语言的实现，它依赖于计算机语言。数据的存储结构主要有：顺序存储、链式存储、索引存储和散列存储。\n    * 顺序存储：存储的物理位置相邻。（p.s. 物理位置即信息在计算机中的位置。）\n    * 链接存储：存储的物理位置未必相邻，通过记录相邻元素的物理位置来找到相邻元素。\n    * 索引存储：类似于目录，以后可以联系操作系统的文件系统章节来理解。\n    * 散列存储：通过关键字直接计算出元素的物理地址（以后详解）。\n### 算法的五个特征\n* 1，有穷性：有限步之后结束\n* 2，确定性：不存在二义性，即没有歧义\n* 3，可行性：比如受限于计算机的计算能力，有些算法虽然理论上可行，但实际上无法完成。\n* 4，输入：能被计算机处理的各种类型数据，如数字，音频，图像等等。\n* 5，输出：一至多个程序输出结果。\n### 算法的复杂度\n* 时间复杂度：\n    * • 它用来衡量算法随着问题规模增大，算法执行时间增长的快慢；\n    * • 是问题规模的函数：T(n)是时间规模函数 时间复杂度主要分析T(n)的数量级\n    * • T(n)=O(f(n)) f(n)是算法中基本运算的频度 一般我们考虑最坏情况下的时间复杂度\n* 空间复杂度：\n    * • 它用来衡量算法随着问题规模增大，算法所需空间的快慢；\n    * • 是问题规模的函数：S(n)=O(g(n)) ；算法所需空间的增长率和g(n)的增长率相同。\n### 概要: 复杂度计算为重点\n* 常用的时间复杂度大小关系：\n* 复杂度如何计算\n    * 时间复杂度计算（单个循环体）\n        * 直接关注循环体的执行次数，设为k \n    * 时间复杂度计算（多个循环体）\n        * 两个运算规则：乘法规则，加法规则。\n## 第二章：线性表\n### 线性表的逻辑结构\n* 定义：线性表是具有相同数据类型的n（n≥0）个数据元素的有限序列。其中n为表长。当n=0时 线性表是一个空表\n* 特点：线性表中第一个元素称为表头元素；最后一个元素称为表尾元素。\n除第一个元素外，每个元素有且仅有一个直接前驱。\n除最后一个元素外，每个元素有且仅有一个直接后继。\n### 线性表的顺序存储结构\n* 线性表的顺序存储又称为顺序表。\n它是用一组地址连续的存储单元（比如C语言里面的数组），依次存储线性表中的数据元素，从而使得逻\n辑上相邻的两个元素在物理位置上也相邻。\n* 建立顺序表的三个属性: \n1.存储空间的起始位置（数组名data）\n2.顺序表最大存储容量（MaxSize）\n3.顺序表当前的长度（length）\n* 其实数组还可以动态分配空间，存储数组的空间是在程序执行过程中通过动态存储分配语句分配\n* 总结：\n    * 1.顺序表最主要的特点是随机访问（C语言中基于数组），即通过首地址和元素序号可以在O(1)的时间内找到指定的元素。\n    * 2.顺序表的存储密度高，每个结点只存储数据元素。无需给表中元素花费空间建立它们之间的逻辑关系（因为物理位置相邻特性决定）\n    * 3.顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素。\n### 顺序表的操作\n* 1.插入\n    * 算法思路：\n        * 1.判断i的值是否正确\n        * 2.判断表长是否超过数组长度\n        * 3.从后向前到第i个位置，分别将这些元素都向后移动一位\n        * 4.将该元素插入位置i 并修改表长\n    * 代码\n    * 分析：\n        * 最好情况：在表尾插入（即i=n+1），元素后移语句将不执行，时间复杂度为O(1)。\n        * 最坏情况：在表头插入（即i=1），元素后移语句将执行\nn次，时间复杂度为O(n)。\n        * 平均情况：假设pi（pi=1/(n+1) ）是在第i个位置上插入\n一个结点的概率，则在长度为n的线性表中插入一个结\n点时所需移动结点的平均次数为\n* 2.删除\n    * 算法思路：\n        * 1.判断i的值是否正确\n        * 2.取删除的元素\n        * 3.将被删元素后面的所有元素都依次向前移动一位\n        * 4.修改表长\n    * 代码\n    * 分析\n        * 最好情况：删除表尾元素（即i=n），无须移动元素，时间复杂度为O(1)。\n        * 最坏情况：删除表头元素（即i=1），需要移动除第一个元素外的所有元素，时间复杂度为O(n)。\n        * 平均情况：假设pi(pi=1/n)是删除第i个位置上结点的概率，则在长度为n的线性表中删除一个结点时所需移动结点的平均次数为\n### 线性表的链式存储结构\n* 线性表的链式存储是指通过一组任意的存储单元来存储线性表中的数据元素。\n* 头结点和头指针的区别？\n    * 不管带不带头结点，头指针始终指向链表的第一个结点，而头结点是带头结点链表中的第一个结点，结点内通常不存储信息\n* 为什么要设置头结点？\n    * 1.处理操作起来方便 例如：对在第一元素结点前插入结点和删除第一结点起操作与其它结点的操作就统一了\n    * 2.无论链表是否为空，其头指针是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\n### 单链表的操作\n* 1.头插法建立单链表：\n    * 建立新的结点分配内存空间，将新结点插入到当前链表的表头\n    * 代码\n* 2.尾插法建立单链表：\n    * 建立新的结点分配内存空间，将新结点插入到当前链表的表尾\n    * 代码\n* 3.按序号查找结点\n    * 在单链表中从第一个结点出发，顺指针next域逐个往下搜索，直到找到第i个结点为止,否则返回最后一个结点指针域NULL。\n    * 代码\n* 4.按值查找结点\n    * 从单链表第一个结点开始，由前往后依次比较表中各结点数据域的值，若某结点数据域的值等于给定值e，则返回该结点的指针；若整个单链表中没有这样的结点，则返回NULL。\n    * 代码\n* 5．插入\n    * 插入操作是将值为x的新结点插入到单链表的第i个位置上。先检查插入位置的合法性，然后找到待插入位置的前驱结点，即第i−1个结点，再在其后插入新结点。\n    * 算法思路：\n1.取指向插入位置的前驱结点的指针\n① p=GetElem(L,i-1);\n2.令新结点*s的指针域指向*p的后继结点\n② s->next=p->next;\n3.令结点*p的指针域指向新插入的结点*s\n③ p->next=s; \n* 6．删除\n    * 删除操作是将单链表的第i个结点删除。先检查删除位置的合法性，然后查找表中第i−1个结点，即被删结点的前驱结点，再将其删除。\n    * 算法思路：\n1.取指向删除位置的前驱结点的指针 p=GetElem(L,i-1);\n2.取指向删除位置的指针 q=p->next;\n3.p指向结点的后继指向被删除结点的后继 p->next=q->next\n4.释放删除结点 free(q);\n### 双链表\n* 定义\n* 1.插入：(方法不唯一)\n① s->next=p->next;\n② p->next->prior=s;\n③ s->prior=p;\n④ p->next=s;\n* 2.删除：\n① p->next=q->next;\n② q->next->prior=p;\n③ free(q);\n\n### 循环链表&&静态链表\n* 循环单链表：循环单链表和单链表的区别在于，表中最后一个结点的指针不是NULL，而改为指向头结点，从而整个链表形成一个环\n* 循环双链表：类比循环单链表，循环双链表链表区别于双链表就是首尾结点构成环\n    * 当循环双链表为空表时，其头结点的prior域和next域都等于Head。\n* 静态链表：静态链表是用数组来描述线性表的链式存储结构。\n    * 数组第一个元素不存储数据，它的指针域存储第一个元素所在的数组下标。链表最后一个元素的指针域值为-1。\n    * 例子\n## 第三章：栈和队列\n### 栈\n* 栈（Stack）：只允许在一端进行插入或删除操作的线性表。\n* 栈顶（Top）：线性表允许进行插入和删除的那一端。\n* 栈底（Bottom）：固定的，不允许进行插入和删除的另一端\n* 特点：\n1.栈是受限的线性表，所以自然具有线性关\n系。\n2.栈中元素后进去的必然先出来，即后进先出\nLIFO（Last In First Out）\n    * 栈中元素后进\n去的必然先出\n来，即后进先\n出LIFO（Last In\nFirst Out）\n* 顺序栈\n    * 栈是线性表的特例，那栈的顺序存储也是线性表顺序存储的简化。栈的顺序存储结构也叫作顺序栈。\n    * 顺序栈的操作\n        * 1.判空：\n        * 2.进栈：\n        * 3.出栈：\n        * 4.读取栈顶元素：\n* 共享栈\n    * 顺序栈的存储空间大小需要事先开辟好，很多时候对每个栈各自单独开辟存储空间的利用率不如将各个栈的存储空间共享\n    * 示意图\n    * 共享栈的结构\n    * 共享栈的操作：（进栈）\n* 链式栈\n    * 栈是线性表的特例，线性表的存储结构还有链式存储结构，所以也可以用链表的方式来实现栈。栈的链式存储结构也叫作链栈。\n    * 特点\n1.链栈一般不存在栈满的情况。\n2.空栈的判定条件通常定为top==NULL；\n    * 结构\n    * 链式栈的操作\n        * 1.进栈\n        * 2.出栈\n### 队列\n* 队列是只允许在一端进行插入，而在另一端进行删除的线性表\n* 队头（Front）：允许删除的一端，又称为队首。\n* 队尾（Rear）： 允许插入的一端。\n* 先进入队列的元素必然先离开队列，即先进先出（First In First Out）简称FIFO\n* 顺序队列\n    * 用数组来实现队列，可以将队首放在数组下标为0的位置。\n* 循环队列\n    * 把数组“掰弯”，形成一个环。Rear指针到了下标为4的位置还能继续指回到下标为0的地方。这样首尾相连的顺序存储的队列就叫循环队列\n    * 入队：rear=(rear+1)%MaxSize\n    * 出队：front=(front+1)%MaxSize\n    * 循环队列的操作\n        * 1.入队：\n        * 2.出队：\n    * 概要: 那如何分辨队列是空还是满呢？\n        * 方法一：设置标志位flag，当flag=0且rear等于front时为队列空，当flag=1且rear等于front时为队列满。\n        * 方法二：我们把front=rear仅作为队空的判定条件。当队列满的时候，令数组中仍然保留一个空余单元。我们认为这种情况就是队列满了。\n* 链式队列\n    * 队列的链式存储结构，其实就是线性表的单链表，只不过需要加点限制，只能表尾插入元素，表头删除元素。\n    * 为了方便操作，我们分别设置队头指针和队尾指针，队头指针指向头结点，队尾指针指向尾结点。\n    * 链式队列的操作\n        * 1.入队：我们知道队列只能从队尾插入元素，队头删除元素。于是入队就是在队尾指针进行插入结点操作。链队的插入操作和单链表的插入操作是一致的。\n\n        * 2.出队：出队就是头结点的后继结点出队，然后将头结点的后继改为它后面的结点。\n* 双端队列\n    * 双端队列是指允许两端都可以进行入队和出队操作的队列\n### 栈的应用\n* 1、括号匹配：假设有两种括号，一种圆的()，一种方的[]，嵌套的顺序是任意的。\n    * 算法思想：若是左括号，入栈；若是右括号，出栈一个左括号判断是否与之匹配；检验到字符串尾，还要检查栈是否为空。只有栈空，整个字符串才是括号匹配的。\n\n    * 代码\n* 2、表达式求值：\n    *  \n    * 规则：从左到右扫描表达式的每个数字和符号，遇到数字就进栈，遇到符号就将处于栈顶的两个数字出栈然后跟这个符号进行运算，最后将运算结果进栈，直到最终获得结果。\n* 3、递归：\n    * 要理解递归，你要先理解递归，直到你能理解递归。\n如果在一个函数、过程或数据结构的定义中又应用了它自身，那么这个函数、过程或数据结构称为是递归定义的，简称递归。递归最重要的是递归式和递归边界。\n    * 1.阶乘\n        * 时间复杂度：O(NlogN)\n    * 2.斐波那契数列\n        * 时间复杂度   O(2^n)\n* 概要: 如何将中缀表达式转换成后缀表达式？\n    * 1.按运算符优先级对所有运算符和它的运算数加括号。(原本的括号不用加)\n    * 2.把运算符移到对应的括号后。\n    * 3.去掉括号。\n    * 例子\n## 第四章：树\n### 树的基本概念\n* 树是递归定义的结构\n* 结点\n    * 根节点：树只有一个根结点\n    * 结点的度：结点拥有的子树的数量\n        * 度为0：叶子结点或者终端结点\n        * 度不为0：分支结点或者非终端结点\n            * 分支结点除去根结点也称为内部结点\n* 树的度：树中所有结点的度数的最大值\n* 结点关系\n    * 祖先结点\n        * 根结点到该结点的唯一路径的任意结点\n    * 子孙结点\n    * 双亲结点\n        * 根结点到该结点的唯一路径上最接近该结点的结点\n    * 孩子结点\n    * 兄弟结点\n        * 有相同双亲结点的结点\n* 层次，高度，深度，树的高度\n    * 层次：根为第一层，它的孩子为第二层，以此类推\n    * 结点的深度：根结点开始自顶向下累加\n    * 结点的高度：叶节点开始自底向上累加\n    * 树的高度（深度）：树中结点的最大层数\n* 树的性质\n    * 1.树中的结点数等于所有结点的度数加1。\n        * 证明：不难想象，除根结点以外，每个结点有且仅有一个指向它的前驱结点。也就是说每个结点和指向它的分支一一对应。\n假设树中一共有b个分支，那么除了根结点，整个树就包含有b个结点，所以整个树的结点数就是这b个结点加上根结点，设为n，则n=b+1。而分支数b也就是所有结点的度数，证毕。\n    * 2.度为m的树中第i层上至多有m^(i−1)个结点（i≥1）。\n        * 证明：（数学归纳法）\n首先考虑i=1的情况：第一层只有根结点，即一个结点，i=1带入式子满足。\n假设第i-1层满足这个性质，第i-1层最多有m i-2个结点。\n……… ..........\ni-1层\n………\n又因为树的度为m,所以对于第i-1层的每个结点，最多\n有m个孩子结点。所以第i层的结点数最多是i-1层的m\n倍，所以第i层上最多有m ^(i-1)个结点。\n    * 3.高度为h的m叉树至多有(m^h-1)/(m-1)个结点\n    * 4.具有n个结点的m叉树的最小高度为logm(n(m-1)+1) \n### 树的存储结构\n* 顺序存储结构\n    * 双亲表示法：用一组连续的存储空间存储树的结点，同时在每个结点中，用一个变量存储该结点的双亲结点在数组中的位置。\n* 链式存储结构\n    * 孩子表示法：把每个结点的孩子结点排列起来存储成一个单链表。所以n个结点就有n个链表；\n如果是叶子结点，那这个结点的孩子单链表就是空的；\n然后n个单链表的的头指针又存储在一个顺序表（数组）中。\n\n    * 孩子兄弟表示法：顾名思义就是要存储孩子和孩子结点的兄弟，具体来说，就是设置两个指针，分别指向该结\n点的第一个孩子结点和这个孩子结点的右兄弟结点。\n### 二叉树\n* 定义\n    * 二叉树是n（n≥0）个结点的有限集合：\n① 或者为空二叉树，即n=0。\n② 或者由一个根结点和两个互不相交的被称为根的左子树\n和右子树组成。左子树和右子树又分别是一棵二叉树。 \n        * 1.每个结点最多有两棵子树。\n        * 2.左右子树有顺序\n* 二叉树的五种基本形态：\n    * 1.空树\n    * 2.只有一个根结点\n    * 3.根结点只有左子树\n    * 4.根结点只有右子树\n    * 5.根结点既有左子树又有右子树\n* 特殊二叉树\n    * 1.斜树\n    * 2.满二叉树:\n    * 3.完全二叉树\n* 二叉树的性质\n    * 1.非空二叉树上叶子结点数等于度为2的结点数加1\n    * 2.非空二叉树上第K层上至多有2^k−1个结点（K≥1）\n    * 3.高度为H的二叉树至多有2^H-1个结点（H≥1）\n    * 4.具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)]或[log2N] +1。\n### 二叉树的存储结构\n* 顺序存储\n    * 二叉树的顺序存储结构就是用一组地址连续的存储单元依次自上而下、自左至右存储完全二叉树上的结点元素。\n* 链式存储\n    * 二叉树每个结点最多两个孩子，所以设计二叉树的结点结构时考虑两个指针指向该结点的两个孩子。\n### 二叉树的遍历\n* 先序遍历：\n1）访问根结点；\n2）先序遍历左子树；\n3）先序遍历右子树。\n    * 递归\n    * 非递归\n* 中序遍历：\n1）中序遍历左子树；\n2）访问根结点；\n3）中序遍历右子树。\n    * 递归\n    * 非递归\n* 后序遍历：\n1）后序遍历左子树；\n2）后序遍历右子树；\n3）访问根结点。\n    * 递归\n    * 非递归\n* 层次遍历：\n若树为空，则什么都不做直接返回。\n否则从树的第一层开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。\n\n### 线索二叉树\n* N个结点的二叉链表，每个结点都有指向左右孩子的\n结点指针，所以一共有2N个指针，而N个结点的二叉\n树一共有N-1条分支，也就是说存在2N-(N-1)=N+1个空指针。比如左图二叉树中有6个结点，那么就有7个空\n指针。\n\n* 大量的空余指针能否利用起来？\n    * 指向前驱和后继的指针称为线索，加上线索的二叉链表就称为线索链表，相应的二叉树就称为线索二叉树\n    * 对二叉树以某种次序遍历使其变为线索二叉树的过程就叫做线索化\n### 哈夫曼树和哈夫曼编码\n* 算法的描述如下：\n1）将这N个结点分别作为N棵仅含一个结点的二叉树，构成森林F。\n2）构造一个新结点，并从F中选取两棵根结点权值最小的树作为新结点的左、右子树，并且将新结点的权值\n置为左、右子树上根结点的权值之和。\n3）从F中删除刚才选出的两棵树，同时将新得到的树加入F中。\n4）重复步骤2）和3），直至F中只剩下一棵树为止。\n\n## 第五章：图\n### 图的基本概念\n* 定义：\n树是N（N≥0）个结点的有限集合，N=0时，称为空树，这是一种特殊情况。在任意一棵非空树中应满足：\n1）有且仅有一个特定的称为根的结点。\n2）当N>1时，其余结点可分为m（m>0）个互不相交的有限集合T1，T2，…，Tm，其中每一个集合本身又是一棵树，并且称为根结点的子树。\n    * 图G由顶点集V和边集E组成，记为G=(V，E)\n        * V(G)表示图G中顶点的有限非空集。\n用|V|表示图G中顶点的个数，也称为图G的阶\n        * E(G)表示图G中顶点之间的关系（边）集合。\n用|E|表示图G中边的条数。\n* 分类\n    * 有向图\n        * 有向边（弧）的有限集合\n            * 弧是顶点的有序对\n            * <v,w>\n            * v是弧尾，w是弧头\n            * v邻接到w或w邻接自v\n    * 无向图\n        * 无向边的有限集合\n            * 边是顶点的无序对\n            * （v,w）\n            * （v,w）=(w,v)\n            * w，v互为邻接点\n* 简单图\n    * 1.不存在顶点到自身的边\n    * 2.同一条边不重复出现\n* 多重图\n    * 若图G中某两个结点之间的边数多于一条，又允许顶点通过通过同一个边和自己关联\n* 完全图\n    * 无向完全图\n        * 如果任意两个顶点之间都存在边\n    * 有向完全图\n        * 如果任意两个顶点之间都存在方向相反的两条弧\n* 子图\n* 连通图：图中任意两个顶点都是连通的\n* 连通分量：无向图中的极大连通子图\n    * 连通\n        * 顶点A到顶点B有路径\n    * 极大\n        * 1.顶点足够多\n        * 2.极大连通子图包含这些依附这些顶点的所有边\n    * 结论1:如果一个图有n个顶点，并且有小于n-1条边，则此图必是非连通图。\n    * 概要: 找连通分量的方法：\n从选取一个顶点开始，以这个顶点作为一个子图，然后逐个添加与这个子图相连的顶点和边直到所有相连的顶点都加入该子图\n* 强连通：顶点V到顶点W和顶点W到顶点V都有路径\n* 强连通图：图中任一对顶点都是强连通的\n* 连通图的生成树：包含图中全部n个顶点，但是只有n-1条边的极小连通子图\n    * 结论2:生成树去掉一条边则变成非连通图，加上一条边就会形成回路。\n* 度：以该顶点为一个端点的边数目\n    * 无向图中顶点V的度是指依附于该顶点的边的条数，记为TD(v)\n    * 有向图中顶点V的度分为出度和入度\n        * 入度（ID）是以顶点v为终点的有向边的数目\n        * 出度（OD）是以顶点V为起点的有向边的数目\n* 简单路径和简单回路：顶点不重复出现的路径称为简单路径。对于回路，除了第一个和最后一个顶点其余顶点不重复出现的回路称为简单回路\n* 权和网：图中每条边考研赋予一定意义的数值，这个数值叫做这条边的权，有权值得图称为带权图，也叫做网\n* 路径和路径长度：顶点p到q之间的路径是指顶点序列怕保存的，p,a,b,c,d,……q。路径上边的数目就是路径长度\n* 回路（环）：第一个和最后一个顶点相同的路径称为回路或者环\n* 距离：从顶点u到v的最短路径长度。不存在路径则为无穷\n### 图的存储结构\n* 邻接矩阵（顺序存储）\n* 邻接表（链式存储）\n    * 十字链表（有向图）\n    * 邻接多重表（无向图）\n### 图的遍历\n* 深度优先遍历\n    * 深度优先搜索(DFS:Depth-First-Search):深度优先搜索类似于树的先序遍历算法\n        * 空间复杂度：由于DFS是一个递归算法，递归是需要一个工作栈来辅助工作，最多需要图中所有顶点进栈，所以时间复杂度为O(|V|)\n        * 时间复杂度：1)邻接表：遍历过程的主要操作是对顶点遍历它的邻接点，由于通过访问边表来查找邻接点，所以时间复杂度为O(|E|),访问顶点时间为O(|V|),所以总的时间复杂度为O(|V|+|E|)\n                      2)邻接矩阵：查找每个顶点的邻接点时间复杂度为O(|V|),对每个顶点都进行查找，所以总的时间复杂度为O(|V|2)\n* 广度优先遍历\n    * 广度优先搜索(BFS:Breadth-First-Search):广度优先搜索类似于树的层序遍历算法\n        * 空间复杂度：BFS需要借助一个队列，n个顶点均需要入队一次，所以最坏情况下n个顶点在队列，那么则需要O(|V|)的空间复杂度。    \n        * 时间复杂度：\n1)邻接表：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，就需要访问这个顶点的所有边，所以时间复杂度为O(|E|)。所以总的时间复杂度为O(|V|+|E|)\n2)邻接矩阵：每个顶点入队一次，时间复杂度为O(|V|),对于每个顶点，搜索它的邻接点，需要遍历一遍矩阵的一行，所以时间复杂度为O(|V|),所以总的时间复杂度为O(|V|2)\n\n### 图的应用\n* 最小生成树\n    * 普利姆（Prlm）\n        * ①从图中找第一个起始顶点v0，作为生成树的第一个顶点，然后从这个顶点到其他顶点的所有边中选一条权值最小的边。然后把这条边的另一个顶点v和这条边加入到生成树中。\n        * ②对剩下的其他所有顶点，分别检查这些顶点与顶点v的权值是否比这些顶点在lowcost数组中对应的权值小，如果更小，则用较小的权值更新lowcost数组。\n        * ③从更新后的lowcost数组中继续挑选权值最小而且不在生成树中的边，然后加入到生成树。\n        * ④反复执行②③直到所有所有顶点都加入到生成树中。\n        * 概要:  \n            * 双重循环，外层循环次数为n-1，内层并列的两个循环次数都是n。故普利姆算法时间复杂度为O(n2)\n而且时间复杂度只和n有关，所以适合稠密图\n    * 克鲁斯卡尔（Kruskal）\n        * 将图中边按照权值从小到大排列，然后从最小的边开始扫描，设置一个边的集合来记录，如果该边并入不构成回路的话，则将该边并入当前生成树。直到所有的边都检测完为止。\n        * 概要:  \n            * \n            *  \n            * 概要: 克鲁斯卡尔算法操作分为对边的权值排序部分和一个单重for循环，它们是并列关系，由于排序耗费时间大于单重循环，所以克鲁斯卡尔算法的主要时间耗费在排序上。排序和图中边的数量有关系，所以适合稀疏图\n* 最短路径\n    * 迪杰斯特拉\n        * 一个源点到其余顶点的最短路径\n            * 该算法设置一个集合S记录已求得的最短路径的顶点，可用一个数组s[]来实现，初始化为0，当s[vi]=1时表示将顶点vi放入S中，初始时把源点v0放入S中。此外，在构造过程中还设置了两个辅助数组：\ndist[]：记录了从源点v0到其他各顶点当前的最短路径长度，dist[i]初值为arcs[v0][i]。\npath[]：path[i]表示从源点到顶点i之间的最短路径的前驱结点，在算法结束时，可根据其值追溯得到源点v0到顶点vi的最短路径。\n\n假设从顶点0出发，也就是顶点0为源点，集合S最初只包含顶点0，邻接矩阵arcs表示带权有向图，arcs[i][j]表示有向边<i，j>的权值，若不存在有向边<i，j>，则arcs[i][j]为∞。Dijkstra算法的步骤如下：\n1）初始化：集合S初始为{0}，dist[]的初始值dist[i]=arcs[0][i]，i=1，2，…，n-1。\n2）找出dist[]中的最小值dist[j]，将顶点j加入集合S，即修改s[vj]=1。\n3）修改从v0出发到集合V-S上任一顶点vk可达的最短路径长度：如果dist[j] + arcs[j][k]< dist[k]，则令dist[k]=dist[j] + arcs[j][k]。另外更新path[k]=j(也就是顶点j加入集合之后如果有新的路径使得到顶点k路径变短的话就将到顶点k的路径长度修改成较短的)\n4）重复2）～3）操作共n-1次，直到所有的顶点都包含在S中。\n    * 弗洛伊德\n        * 所有顶点到所有顶点的最短路径\n            * 算法思想：\n递推产生一个n阶方阵序列A(−1)，A(0)，…，A(k)，…，A(n−1)\n其中A(k)[i][j]表示从顶点vi到顶点vj的路径长度，k表示绕行第k个顶点的运算步骤。初始时，对于任意两个顶点vi和vj，若它们之间存在边，则以此边上的权值作为它们之间的最短路径长度；若它们之间不存在有向边，则以∞作为它们之间的最短路径长度。以后逐步尝试在原路径中加入顶点k(k=0，1，…，n-1)作为中间顶点。如果增加中间顶点后，得到的路径比原来的路径长度减少了，则以此新路径代替原路径\n    * 非带权图\n        * 两点之间经过边数最少的路径\n    * 带权图\n        * 两点之间经过的边上权值之和最小的路径\n* 拓扑排序\n    * AOV\n        * 如果我们把每个环节看成图中一个顶点，在这样一个有向图中，用顶点表示活动，用弧表示活动之间的优先关系，那么这样的有向图称为AOV网(Activity On Vertex)\n\n    * 拓扑排序就是对一个有向图构造拓扑序列的过程，构造会有两种结果：\n如果此图全部顶点都被输出了，说明它是不存在回路的AOV网；\n如果没有输出全部顶点，则说明这个图存在回路，不是AOV网。\n    * 拓扑排序算法：\n     从AOV网中选择一个入度为0的顶点输出，然后删去此顶点，并删除以此顶点为弧尾的弧。重复这个步骤直到输出图中全部顶点，或者找不到入度为0的顶点为止。\n\n* 关键路径\n    * AOE(Activity On Edge):在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续时间，这种有向图的边表示活动的网称为AOE网。\n\n## 第六章：查找\n### 查找的基本概念和顺序查找\n* 查找定义：在数据集合中寻找满足某种条件的数据元素的过程称为查找\n* 关键字：数据元素中某个可以以唯一标识该元素的数据项\n* 平均查找长度（ASL：Average Search Length）:在查找的过程中，一次查找的长度是指需要比较的关键字次数，而平均查找长度则是所有查找过程中进行关键字的比较次数的平均值\n* 顺序查找(线性查找)，主要用于在线性表中进行查找。从查找表的一端开始，顺序扫描查找表，依次将扫描到的关键字和待查找的值key进行比较。如果相等，则查找成功。如果扫描结束仍然没有发现相等的数据元素，则查找失败。\n    * 1\n    * 2\n    * 3 \n    * 4\n    * 时间复杂度为O(n)\n### 折半查找\n* 算法思路：\n    * 首先将给定值key与表中中间位置元素的关键字比较，若相等，则查找成功，返回该元素的存储位置；若不等，则所需查找的元素只能在中间元素以外的前半部分或后半部分中。然后在缩小的范围内继续进行同样的查找，如此重复直到找到为止，或者确定表中没有所需要查找的元素，则查找不成功，返回查找失败的信息。\n* 折半查找分析\n    * 折半查找判定树\n        * 对于折半查找，查找的比较次数就是从根结点到该结点经历的结点数\n        * 时间复杂度为O(logn)\n        * 概要: 具有N个（N>0）结点的完全二叉树的高度为 [log2(N+1)] 或 [log2N] +1。\n\n### 分块查找\n* 分块查找又称为索引顺序查找\n* 分块查找思想：\n    * ①确定待查找值在哪个块（折半查找）\n\n②在确定的块中查找待查找值（顺序查找）\n* 分块查找分析\n    * 由于分块查找实际是进行两次查找，所以整个算法的平均查找长度是两次查找的平均查找长度之和。\n即ASL分块=ASL折半+ASL顺序\n        *  \n### 二叉排序树\n* 二叉排序树(Binary Search Tree 也叫二叉搜索树)或者是一棵空树，或者是具有以下性质的二叉树\n①若左子树不空，则左子树上所有结点的值均小于它的根结点的值。\n②若右子树不空，则右子树上所有结点的值均大于它的根结点的值。\n③它的左右子树也是一棵二叉排序树。\n* 算法思想\n    * 由于二叉排序树的特点(左子树<根结点<右子树),所以每次查找一个关键字，需要先和根结点进行比较：\n如果这个关键字小于根结点的值，则再到这个根结点的左子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。\n如果这个关键字大于根结点的值，则再到这个根结点的右子树进行同样的比较操作一直进行下去直到找到该关键字，表示查找成功，或者是空指针，表示查找失败。\n        * 查找关键字代码\n            * 1 \n            * 2\n        * 插入关键字代码\n            * 1)空树：直接插入新结点返回成功\n2)树不空：检查是否存在关键字重复的结点：\n①存在：返回插入失败\n②不存在：检查根结点的值和待插入关键字值的大小关系递归插入左右子树\n            *  \n        * 构造代码\n            *  \n        * 删除结点\n            * ①删除的是叶子结点\n                * 方法：直接删去该结点即可\n            * ②删除的是仅有左子树或者右子树的结点\n                * 方法：“子承父业”\n            * ③删除的是左右子树都有的结点\n                * 仿照②类型，先将一个孩子“继承父业”，另一个孩子“归顺”于这个孩子\n方法：找到待删除结点的直接前驱或者直接后继结点，用该结点来替换待删除结点，再删除该结点。\n* 二叉排序树分析\n    * 查找时间复杂度是O(n)\n* 概要: “左小右大”\n### 平衡二叉树(AVL树)\n* 平衡二叉树(AVL树)是特殊的二叉排序树，特殊的地方在于左右子树的高度之差绝对值不超过1，而且左右子树又是一棵平衡二叉树。\n* 平衡因子\n    * 定义结点左子树与右子树的高度差为该结点的平衡因子，则平衡二叉树结点的平衡因子的值只可能是−1、0或1。\n* 平衡调整\n    * 平衡二叉树的建立过程和二叉排序树的建立过程是相似的，都是从一棵空树开始陆续插入结点。不同的地方在于对于平衡二叉树的建立过程中，由于插入结点可能会破坏结点的平衡性，所以需要进行平衡调整。\n\n        * LL调整(左孩子的左子树上插入结点导致)\n            * 最小不平衡子树根结点的平衡因子为2>0\n它的左孩子结点平衡因子为1>0\n两个都大于0，所以直接右旋就可以调整\n            * 概要: “正则右旋”\n        * RR调整(右孩子的右子树上插入结点导致)\n            *  最小不平衡子树根结点的平衡因子为-2<0\n它的右孩子结点平衡因子为-1<0\n两个都小于0，所以直接左旋就可以调整\n            * 概要: “负则左旋”\n        * LR调整(左孩子的右子树上插入结点导致)\n        * RL调整(右孩子的左子树上插入结点导致)\n        * 概要: 先局部转换为LL或RR，最后进行调整\n* 分析\n    * 含有n个结点平衡二叉树的最大深度为O(log2n)，因此，平衡二叉树的平均查找长度为O(log2n) \n### B树和B+树\n* 2-3树\n    * 2-3树是一种多路查找树：2和3的意思就是2-3树包含两种结点\n        * 1)2结点包含一个元素和两个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值\n    ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子\n        * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。(两个元素按大小顺序排列好)\n    ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。\n    ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子\n        * 3)2-3树所有叶子结点都在同一层次\n* 2-3-4树\n    * 2-3-4树也是一种多路查找树：2和3和4的意思就是2-3-4树包含三种结点\n        * 1)2结点包含一个元素和两个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点的元素值，右子树包含的元素大于该结点的元素值\n    ②2结点要不有两个孩子，要不就没有孩子，不允许有一个孩子\n        * 2)3结点包含一大一小两个元素和三个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点较小的元素值，右子树包含的元素大于该结点较大的元素值，中间子树包含的元素介于这两个元素值之间。\n    ②3结点要不有三个孩子，要不就没有孩子，不允许有一个或两个孩子\n        * 3)4结点包含小中大三个元素和四个孩子(或者没有孩子)。\n    ①左子树包含的元素小于该结点最小的元素值，第二个子树包含大于最小的元素值小于中间元素值的元素，第三个子树包含大于中间元素值小于最大元素值的元素，右子树包含的元素大于该结点最大的元素值。   \n    ②4结点要不有四个孩子，要不就没有孩子，不允许有一个或两个或三个孩子\n        * 4)2-3-4树所有叶子结点都在同一层次\n* B树\n    * B树也是一种平衡的多路查找树，2-3树和2-3-4树都是B树的特例，我们把树中结点最大的孩子数目称为B树的阶。通常记为m。\n一棵m阶B树或为空树，或为满足如下特性的m叉树：\n        * 1）树中每个结点至多有m棵子树。（即至多含有m-1个关键字) (\"两棵子树指针夹着一个关键字\")\n        * 2）若根结点不是终端结点，则至少有两棵子树。(至少一个关键字)\n        * 3）除根结点外的所有非叶结点至少有 ⌈m/2⌉棵子树。（即至少含有⌈m/2⌉-1个关键字）\n        * 4）所有非叶结点的结构如下：\n        * 5）所有的叶子结点出现在同一层次上，不带信息。(就像是折半查找判断树中查找失败的结点)\n    * 1.B树的查找操作\n        * 查找过程：①先让待查找关键字key和结点的中的关键字比较，如果等于其中某个关键字，则查找成功。\n                  ②如果和所有关键字都不相等，则看key处在哪个范围内，然后去对应的指针所指向的子树中查找。\n                      Eg:如果Key比第一个关键字K1还小，则去P0指针所指向的子树中查找，如果比最后一个关键字Kn还大，则去Pn指针所指向的子树中查找。\n\n    * 2.B树的插入操作\n        * 分裂的方法：取这个关键字数组中的中间关键字(⌈n/2⌉)作为新的结点，然后其他关键字形成两个结点作为新结点的左右孩子。\n    * 3.B树的删除操作\n        * B树中的删除操作与插入操作类似，但要稍微复杂些，要使得删除后的结点中的关键字个数≥⌈m/2⌉-1 ，因此将涉及结点的“合并”问题。由于删除的关键字位置不同，可以分为关键字在终端结点和不在终端结点上两种情况。\n            * 1）如果删除的关键字在终端结点上（最底层非叶子结点）：\n      ①结点内关键字数量大于⌈m/2⌉-1 ，这时删除这个关键字不会破坏B树的定义要求。所以直接删除。\n      ②结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中存在关键字数量大于⌈m/2⌉-1 的结点，则去兄弟阶段中借关键字。\n      ③结点内关键字数量等于⌈m/2⌉-1 ，并且其左右兄弟结点中不存在关键字数量大于⌈m/2⌉-1 的结点，则需要进行结点合并。\n\n            * 2）如果删除的关键字不在终端结点上（最底层非叶子结点）：需要先转换成在终端结点上，再按照在终端结点     上的情况来分别考虑对应的方法。\n                * 相邻关键字：对于不在终端结点上的关键字,它的相邻关键字是其左子树中值最大的关键字或者右子树中值最小的关键字。\n                * 第一种情况：存在关键字数量大于⌈m/2⌉-1 的左子树或者右子树，在对应子树上找到该关键字的相邻关键字，然后将相邻关键字替换待删除的关键字。\n                * 第二种情况：左右子树的关键字数量均等于⌈m/2⌉-1 ，则将这两个左右子树结点合并，然后删除待删除关键字。\n* B+树\n    * B+树是常用于数据库和操作系统的文件系统中的一种用于查找的数据结构\n    * m阶的B+树与m阶的B树的主要差异在于：\n1）在B+树中，具有n个关键字的结点只含有n棵子树，即每个关键字对应一棵子树；而在B树中，具有n个关键字的结点含有(n+1)棵子树。\n2）在B+树中，每个结点（非根内部结点）关键字个数n的范围是 ⌈m/2⌉≤n≤m（根结点1≤n≤m），在B树中，每个结点（非根内部结点）关键字个数n的范围是⌈m/2⌉ -1≤n≤m-1（根结点：1≤n≤m-1）。\n3）在B+树中，叶结点包含信息，所有非叶结点仅起到索引作用，非叶结点中的每个索引项只含有对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。\n4）在B+树中，叶结点包含了全部关键字，即在非叶结点中出现的关键字也会出现在叶结点中；而在B树中，叶结点包含的关键字和其他结点包含的关键字是不重复的。\n### 散列表\n* 散列表：根据给定的关键字来计算出关键字在表中的地址的数据结构。也就是说，散列表建立了关键字和存储地址之间的一种直接映射关系。\n* 散列函数：一个把查找表中的关键字映射成该关键字对应的地址的函数，记为Hash(key)=Addr。\n* 散列函数可能会把两个或两个以上的不同关键字映射到同一地址，称这种情况为“冲突”，这些发生碰撞的不同关键字称为同义词。\n* 构造散列函数的tips：\n    * 1）散列函数的定义域必须包含全部需要存储的关键字，而值域的范围则依赖于散列表的大小或地址范围。\n    * 2）散列函数计算出来的地址应该能等概率、均匀地分布在整个地址空间，从而减少冲突的发生。\n    * 3）散列函数应尽量简单，能够在较短的时间内就计算出任一关键字对应的散列地址。\n* 1.常用Hash函数的构造方法：\n    * 1.开放定址法：直接取关键字的某个线性函数值为散列地址，散列函数为H(key)=a×key+b。式中，a和b是常数。这种方法计算最简单，并且不会产生冲突\n    * 2.除留余数法：假定散列表表长为m，取一个不大于m但最接近或等于m的质数p，利用以下公式把关键字转换成散列地址。散列函数为H(key)=key % p\n除留余数法的关键是选好p，使得每一个关键字通过该函数转换后等概率地映射到散列空间上的任一地址，从而尽可能减少冲突的可能性\n    * 3.数字分析法：设关键字是r进制数（如十进制数），而r个数码在各位上出现的频率不一定相同，可能在某些位上分布均匀些，每种数码出现的机会均等；而在某些位上分布不均匀，只有某几种数码经常出现，则应选取数码分布较为均匀的若干位作为散列地址。这种方法适合于已知的关键字集合\n    * 4.平方取中法：顾名思义，取关键字的平方值的中间几位作为散列地址。具体取多少位要看实际情况而定。这种方法得到的散列地址与关键字的每一位都有关系，使得散列地址分布比较均匀。\n    * 5.折叠法：将关键字分割成位数相同的几部分（最后一部分的位数可以短一些），然后取这几部分的叠加和作为散列地址，这种方法称为折叠法。关键字位数很多，而且关键字中每一位上数字分布大致均匀时，可以采用折叠法得到散列地址。\n\n* 2.常用Hash函数的冲突处理办法：\n    * 1.开放定址法：将产生冲突的Hash地址作为自变量，通过某种冲突解决函数得到一个新的空闲的Hash地址。\n        * 1）线性探测法：冲突发生时，顺序查看表中下一个单元（当探测到表尾地址m-1时，下一个探测地址是表首地址0），直到找出一个空闲单元（当表未填满时一定能找到一个空闲单元）或查遍全表。\n        * 2）平方探测法：设发生冲突的地址为d,平方探测法得到的新的地址序列为d+12，d-12，d+22，d-22......\n平方探测法是一种较好的处理冲突的方法，可以避免出现“堆积”问题，它的缺点是不能探测到散列表上的所有单元，但至少能探测到一半单元。\n        * 3）再散列法：又称为双散列法。需要使用两个散列函数，当通过第一个散列函数H(Key)得到的地址发生冲突时，则利用第二个散列函数Hash2(Key)计算该关键字的地址增量。\n        * 4）伪随机序列法：当发生地址冲突时，地址增量为伪随机数序列，称为伪随机序列法。\n    * 2.拉链法：对于不同的关键字可能会通过散列函数映射到同一地址，为了避免非同义词发生冲突，可以把所有的同义词存储在一个线性链表中，这个线性链表由其散列地址唯一标识。拉链法适用于经常进行插入和删除的情况。\n    * 3.散列表的查找过程：类似于构造散列表，给定一个关键字Key。\n      先根据散列函数计算出其散列地址。然后检查散列地址位置有没有关键字。\n         1)如果没有，表明该关键字不存在，返回查找失败。\n         2)如果有，则检查该记录是否等于关键字。\n                 ①如果等于关键字，返回查找成功。\n                 ②如果不等于，则按照给定的冲突处理办法来计算下一个散列地址，再用该地址去执行上述过程。\n    * 4.散列表的查找性能：和装填因子有关。\n        *  \n        * α越大，表示装填的记录越“满”，发生冲突的可能性就越大，反之发生冲突的可能性越小\n## 第七章：排序\n### 排序的基本知识\n* 定义：排序就是将原本无序的序列重新排列成有序的序列。\n* 排序的稳定性\n    * 如果待排序表中有两个元素Ri、Rj，其对应的关键字keyi=keyj，且在排序前Ri在Rj前面，如果使用某一排序算法排序后，Ri仍然在Rj的前面，则称这个排序算法是稳定的，否则称排序算法是不稳定的。\n### 插入类排序\n* 直接插入排序\n    * 直接插入排序：首先以一个元素为有序的序列，然后将后面的元素依次插入到有序的序列中合适的位置直到所有元素都插入有序序列。\n    * 时间复杂度为O(n)\n    * 直接插入排序是稳定性是稳定的。\n* 折半插入排序\n    * 折半插入排序将比较和移动这两个操作分离出来，也就是先利用折半查找找到插入的位置，然后一次性移动元素，再插入该元素。\n    * 折半插入排序的时间复杂度为O(n^2)\n    * 稳定性：和直接插入排序稳定性相同，是稳定的。\n* 希尔排序\n    * 希尔排序的基本思想：希尔排序本质上还是插入排序，只不过是把待排序序列分成几个子序列，再分别对这几个子序列进行直接插入排序。\n        * ①先以增量5来分割序列，也就是下标为0,5,10,15...的关键字分成一组，下标为1,6,11,16..分成一组,然后对这些组分别进行直接插入排序，这就完成了一轮希尔排序。\n        * ②缩小增量(d1=n/2，di+1= [di/2]，比如10个数据序列，第一次增量d1=10/2=5,第二次增量d2= [d1/2]= [5/2]=2,并且最后一个增量等于1),所以第二轮以增量为2进行类似的排序过程。\n        * ③接下来的第三轮，第四轮...都是类似的过程，直到最后一轮以增量为1。此时就是前面所说的直接插入排序。\n        * 概要:  \n    * 时间复杂度：...  希尔排序的时间复杂度约为O(n^1.3)    在最坏情况下希尔排序的时间复杂度为O(n^2)\n    * 空间复杂度：希尔排序的空间复杂度为O(1)\n    * 稳定性：不稳定，由于不同的增量可能就会把相等的关键字划分到两个直接插入排序中进行排序， 可能就会造成相对顺序变化。\n### 交换类排序\n* 冒泡排序\n    * 假设待排序表长为n，从后往前（或从前往后）两两比较相邻元素的值，若为逆序（即A[i-1]>A[i]），则交换它们，直到序列比较完。我们称它为一趟冒泡，结果将最小的元素交换到待排序列的第一个位置。下一趟冒泡时，前一趟确定的最小元素不再参与比较，待排序列减少一个元素，每趟冒泡的结果把序列中的最小元素放到了序列的最终位置，……，这样最多做n-1趟冒泡就能把所有元素排好序。\n    * 空间复杂度：交换时开辟了存储空间来存储中间变量，所以空间复杂度为O(1)\n    * 时间复杂度\n    * 稳定性：当两个关键字相等，if判断条件不成立，所以不会发生数据移动。所以是稳定的。\n* 快速排序\n    * 快速排序是一种基于分治法的排序方法。\n每一趟快排选择序列中任一个元素作为枢轴(pivot)(通常选第一个元素)，将序列中比枢轴小的元素都移到枢轴前边，比枢轴大的元素都移到枢轴后边。\n        * 1\n        * 2\n    * 时间复杂度：\n最好情况下时间复杂度为O(nlogn) ,待排序序列越无序，算法效率越高。\n 最坏情况下时间复杂度为O(n^2)，待排序序列越有序，算法效率越低。\n    * 空间复杂度：\n由于快速排序是递归的，需要借助一个递归工作栈来保存每一层递归调用的必要信息，其容量应与递归调用的最大深度一致。\n最好情况下为 ⌈log2(n+1)⌉(每次partition都很均匀)递归树的深度O(logn)\n最坏情况下，因为要进行n-1次递归调用，所以栈的深度为O(n)；\n    * 稳定性：快速排序是不稳定的，是因为存在交换关键字。\n### 选择类排序\n* 简单选择排序\n    *  \n    * 空间复杂度：需要额外的存储空间仅为交换元素时借助的中间变量，所以空间复杂度是O(1)\n    * 时间复杂度：\n关键操作在于交换元素操作，整个算法由双重循环组成，外层循环从0到n-2一共n-2+1=n-1次，\n对于第i层外层循环，内层循环执行n-1-(i+1)+1=n-i-1次。\n                      当i=0,内层循环执行n-1次，当i=n-2,内层循环执行1次，所以是一个等差数列求和,一共为(1+n-1)(n-1)/2=n(n-1)/2 ,所以时间复杂度为O(n^2)\n    * 稳定性：不稳定   原因就在于交换部分会打破相对顺序\n* 堆排序\n    * 什么是堆？\n        * 堆是一棵完全二叉树，而且满足任何一个非叶结点的值都不大于(或不小于)其左右孩子结点的值。\n            * 如果是每个结点的值都不小于它的左右孩子结点的值，则称为大顶堆。\n            * 如果是每个结点的值都不大于它的左右孩子结点的值，则称为小顶堆。\n    * 什么是堆排序？\n        * 我们知道对于一个堆来说，它的根结点是整个堆中所有结点的值的最大值(大顶堆)或者最小值(小顶堆)。所以堆排序的思想就是每次将无序序列调节成一个堆，然后从堆中选择堆顶元素的值，这个值加入有序序列，无序序列减少一个，再反复调节无序序列，直到所有关键字都加入到有序序列。\n            *  \n            *  \n        * 时间复杂度：\n       堆排序的总时间可以分为①建堆部分+②n-1次向下调整堆\n\n       堆排序的时间复杂度为O(n)+O(nlog2n)=O(nlog2n)\n        * 堆排序不稳定\n### 归并排序\n* 假定待排序表含有n个记录，则可以看成是n个有序的子表，每个子表长度为1，然后两两归并，得到 ⌈n/2⌉个长度为2或1的有序表；再两两归并，……如此重复，直到合并成一个长度为n的有序表为止，这种排序方法称为2-路归并排序。\n    *   \n    *  \n* 例如：49 38 65 97 76 13 27\n    * ①首先将整个序列的每个关键字看成一个单独的有序的子序列\n    * ②两两归并，49和38归并成{38 49} ，65和97归并成{65 97}，76和13归并成{13 76}，27没有归并对象\n    * ③两两归并，{38 49}和{65 97}归并成{38 49 65 97}，{13,76}和27归并成{13 27 76}\n    * ④两两归并，{38 49 65 97}和{13 27 76}归并成{13 27 38 49 65 76 97}\n* 时间复杂度：O(nlog2n)\n* 空间复杂度:因为需要将这个待排序序列转存到一个数组，所以需要额外开辟大小为n的存储空间，即空间复杂度为O(n)\n* 稳定性：稳定\n### 基数排序\n* 基数排序(也叫桶排序)是一种很特别的排序方法，它不是基于比较进行排序的，而是采用多关键字排序思想（即基于关键字各位的大小进行排序的），借助“分配”和“收集”两种操作对单逻辑关键字进行排序。基数排序又分为最高位优先（MSD）排序和最低位优先（LSD）排序。\n* 例子：53, 3, 542, 748, 14, 214, 154, 63, 616\n    * 补充位数：053, 003, 542, 748, 014, 214, 154, 063, 616\n    * 桶实际是一个队列，先进先出(从桶的上面进，下面出)\n    * 关键字数量为n,关键字的位数为d,比如748 d=3，r为关键字的基的个数，就是组成关键字的数据的种类，比如十进制数字一共有0至9一共10个数字，即r=10\n* 空间复杂度：需要开辟关键字基的个数个队列，所以空间复杂度为O(r)\n* 时间复杂度：需要进行关键字位数d次\"分配\"和\"收集\"，一次\"分配\"需要将n个关键字放进各个队列中，一次\"收集\"需要将r个桶都收集一遍。所以一次\"分配\"和一次\"收集\"时间复杂度为O(n+r)。d次就需要O(d(n+r))的时间复杂度。\n* 稳定性：由于是队列，先进先出的性质，所以在分配的时候是按照先后顺序分配，也就是稳定的，所以收集的时候也是保持稳定的。即基数排序是稳定的排序算法。\n### 外部排序\n* 需要将待排序的记录存储在外存上，排序时再把数据一部分一部分的调入内存进行排序。在排序过程中需要多次进行内存和外存之间的交换，对外存文件中的记录进行排序后的结果仍然被放到原有文件中。这种排序的方法就叫做外部排序。\n* 如何得到初始的归并段\n    * 置换选择排序：解决排序段放入内存的问题\n* 如何减少多个归并段的归并次数\n    * 最佳归并树：最少的归并次数（I/O次数）\n* 如何每次m路归并快速得到最小的关键字\n    * 败者树：减少比较次数\n* 概要: 内存容量无法容纳大量数据\n## 二叉树与树与森林\n### 树与二叉树\n* 如何将一棵树转化成二叉树？\n    * 树的孩子兄弟表示法与二叉树的二叉链表表示法都是用到两个指针\n        * 将孩子兄弟表示法理解成二叉链表\n    * 树转换成二叉树的手动模拟方法：\n        * ①将同一结点的各个孩子用线串连起来\n        * ②将每个结点的子树分支，从左往右，除了第一个以外全部删除\n        * 概要: 例子\n* 如何将一棵二叉树转化成树？\n    * 二叉树转换成树的手动模拟方法：\n        * ①将二叉树从上到下分层，并调节成水平方向。\n(分层方法：每遇到左孩子则为一层)\n        * ②找到每一层的双亲结点，方法为它的上一层相连的那个结点就是双亲结点。\n例如bcd这一层，与它相连的上一层结点即为a,所以bcd这三个结点的双亲结点都是a.\n        * ③将每一层结点和其双亲结点相连，同时删除该双亲结点各个孩子结点之间的联系。\n        * 概要: 例子\n### 森林与二叉树\n* 森林：森林是m（m≥0）棵互不相交的树的集合\n* 如何将森林转换成二叉树？\n    * 森林转换成树的手动模拟方法：\n        * ①将森林中每棵树都转换成二叉树\n        * ②将第二棵树作为第一棵树的根结点的右子树，将第三棵树作为第二棵树的根结点的右子树..依次类推\n        * 概要: 例子\n* 如何将二叉树转换成森林？\n    * 二叉树转换成森林的手动模拟方法：\n        * 反复断开二叉树根结点的右孩子的右子树指针，直到不存在根结点有右孩子的二叉树为止。\n        * 概要: 例子\n### 树与森林的遍历\n* 先序：先访问根结点，再访问根结点的每棵子树。           访问子树也是按照先序的要求\n* 后序：先访问根结点的每棵子树，再访问根结点。           访问子树也是按照先序的要求\n* 树的先序遍历等于它对应二叉树的先序遍历，后序遍历等于它对应的二叉树的中序遍历\n* 概要: 例子\n\n![picture](https://github.com/SSHeRun/CS-Xmind-Note/blob/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png)\n","tags":["408"]},{"title":"计算机组成原理","url":"/post/408/计算机组成/index.html  2019/03/04/408/计算机组成/","content":"# Principle-of-Computer-Composition\n计算机组成原理思维导图\n# 计算机组成\n## 第一章 计算机系统概论\n### 冯诺依曼型计算机特点\n* 1.计算机由运算器，控制器，存储器，输入和输出设备5部分组成\n* 2.采用存储程序的方式，程序和数据放在同一个存储器中，并以二进制表示。\n* 3.指令由操作码和地址码组成\n* 4.指令在存储器中按执行顺序存放，由指令计数器(即程序计数器PC)指明要执行的指令所在的储存单元地址，一般按顺序递增，但可按运算结果或外界条件而改变\n* 5.机器以运算器为中心，输入输出设备与存储器间的数据传送都通过运算器\n### 区别以运算器为中心的计算机还是存储器的方法\n* 看输入设备能否直接与存储器相连，是的话就是以存储器为中心\n### 计算机系统\n* 硬件\n    * 结构\n        * 主机\n            * cpu\n                * ALU运算器\n                * CU控制器\n            * 存储器\n                * 主存\n                * 辅存\n        * I/O\n            * 输入设备\n            * 输出设备\n    * 主要技术指标\n        * 机器字长\n            * CPU一次能处理的数据位数\n        * 存储容量\n            * 存储容量＝存储单元个数×存储字长\n        * 运算速度\n            * 单位时间执行指令的平均条数，MIPS\n* 软件\n    * 系统软件\n        * 用来管理整个计算机系统 \n            * 语言处理程序\n            * 操作系统\n            * 服务性程序\n            * 数据库管理系统\n            * 网络软件\n    * 应用软件\n        * 按任务需要编制成的各种程序\n## 第三章 运算方法和运算部件\n### 数据的表示方法和转换\n* 机器数正0负1\n    * 符号数值化的带符号二进制数，称为机器数。\n* 真值:符号位加绝对值\n* 余三码:在8421码的基础上，把每个编码都加上0011\n    * 当两个余三码想加不产生进位时，应从结果中减去0011;产生进位时，应将进位信号送入高位，本位加0011\n* 格雷码:任何两个相邻编码只有1个二进制位不同，而其余3个二进制位相同\n* 8421码\n    * 权值从高到低为8、4、2、1\n        * 算术运算时，需对运算结果进行修正。\u000b           方法：如果小于、等于(1001)2，不需要修正；否则加6修正\n### 带符号的二进制数据在计算机中的表示方法及加减法运算\n* 原码\n    * 定义\n        * 最高位为符号位0/1+数值的绝对值形式\n    * 特点\n        * （1）值+0，-0的原码分别为00000、10000，形式不唯一；\n        * （2）正数的原码码值随着真值增长而增长\n            *      负数的原码码值随着真值增长而减少\n        * （3）n+1位原码表示定点整数范围－(2n－1)——2n－1\n            *      n+1位原码表示定点小数范围 －(1－2－n)——1－2－n\n    * 运算\n        * 绝对值相加减，由数值大小决定运算结果符号\n* 补码\n    * 定义，特点和运算\n        * 运算:\n结果不超过机器所能表示范围时，[X+Y]补=[X]补+[Y]补\n减法运算:\n[X–Y]补=[X+(–Y)]补=[X]补+[–Y]补\n        * 结论\n            * 负数的补数＝模＋负数\n            * 互为补数的绝对值相加＝模\n            * 在补数中，减法运算即加法运算\n        * 定义\n            * 定义法，即[X]补=2·符号位+X     （MOD  2）\n            * X为正数，则符号0+X的绝对值；X为负数，则X的绝对值取反+1。\n        * 特点\n            * 数值零的补码表示唯一\n            * 正数补码码值随着真值增大而增大，负数补码码值随着真值增大而增大\n            * n+1位补码所表示定点整数范围－ 2n——2n－1，n+1位补码所表示定点小数范围－1——1－2－n\n    * 加法运算逻辑事例\n        * 过程\n        * 加减法运算的溢出处理\n            * 溢出定义\n                *  当运算结果超出机器数所能表示的范围\n            * 加减中，可能产生溢出的情况\n                * 可能出现溢出\n                    * 同号数相加\n                    * 异号数相减\n                * 不可能出现溢出\n                    * 异号数相加\n                    * 同号数相减\n            * 判断溢出的方法\n                * 法一：当符号相同两数相加，结果符号和加数（或被加数）不相同，则溢出\n                    * fa,fb表示两操作数（A,B）的符号位,fs为结果的符号位\n                * 法二：任意符号相加，如果C=Cf，则结果正确，否则溢出；\n                    * C为数值最高位的进位，Cf为符号位的进位\n                * 法三：采用双符号相加，如果fs1=fs2，则结果正确，否则溢出；\n                    * 运算结果的符号位为fs2；\n                    * 多符号位的补码，叫做变形补码；\n                    * 如果采用双符号位，当数为小数时，模m=4;当数为整数时，模m=2的n+2次方\n* 反码\n    * 定义\n        *  a.定义法，即[X]反=(2-2-n)·符号位+X   (MOD  2-2-n)\n        * b.X是正数，[X]反=[X]原；X是负数，符号+数值取反。\n    * 特点\n        * 数值零的反码表示不唯一\n        * 正数反码码值随着真值增大而增大，负数反码码值随着真值增大而增大\n        * n+1位反码所表示定点整数范围－ (2n－1)——2n－1，n+1位反码所表示定点小数范围－(1－2－n)——1－2－n\n    * 加减运算特点\n        * 在机器数范围内，反码运算满足[X+Y]反=[X]反+[Y]反\n，[X－Y]反=[X]反+[－Y]反\n    * 反码运算在最高位有进位时，要在最低位+1，此时要多进行一次加法运算，增加了复杂性，又影响了速度，因此很少采用\n    * 由于反码运算是以2-2的-次方为模，所以，当最高位有进位而丢掉进位(即2)时，要在最低位+/-1\n* 移码\n    * 由来及窍门\n        * 为了从码值直接判断对应真值的大小，所以引进移码\n        * [X]补的符号位取反，即得[X]移 \n    * 特点\n        * 最高位是符号位，1表示正，0表示负\n        * 数据0有唯一的编码\n        * 移码码值随着真值增大而增大\n        * n+1位移码所表示定点整数范围－ 2n——2n－1， n+1位移码所表示定点小数范围－1——1－2－n\n        * 计算机中，移码常用于表示阶码，故只执行加、减运算\n        * 计算机中，移码运算公式需要对结果进行修正\n    * 浮点数的阶码运算\n        * 移码定义:[X]移=2的n次方+X\n        * 补码定义:[X]补=2的n+1次方+Y\n        * 阶码求和公式\n            * [X]移+[Y]补=[X+Y]移  mod2的n+1次方\n            * [X]移+[-Y]补=[X-Y]移\n            * 判溢方法\n                * 双符号位参加运算，最高符号位恒置0\n                * 当结果最高符号位=1则溢出\n                    * 低位符号=0，则上溢；低位符号=1，则下溢；\n                *  当结果最高符号位=0则未溢出\n                    * 低位符号=0，负数；低位符号=1，正数\n            * 说明:如果阶码运算的结果溢出，上述条件不成立。此时，使用双符号位的阶码加法器，并规定移码的第二个符号位，即最高符号位恒用0参加加减运算，则溢出条件是结果的最高符号位为1。此时低位符号为0时，表明结果上溢;为1时，表明结果下溢。当最高符号位为0时，表明没有溢出，低位符号位为1，表明结果为正;为0时表明结果为负。\n* 补，反，原，移码的相互转换\n    * 反码-》原码\n        * 方法：符号位不变，正数不变，负数数值部分取反。\n    * 补码-》原码\n        * 方法1：正数不变，负数数值部分求反加1。\n        * 方法2：串行转换\n            * 从最后开始数，遇到第一个“1”，除第一个“1”不变，前面数字分别取反\n    * 移码-》原码\n        * 方法：移码转换为补码，再转换为原码\n* 数据从补码和反码表示形式转换成原码\n    * 自低位开始转换，从低位向高位，在遇到第一个1之前，保存各位的0不变，第一个1也不变，以后得各位按位取反，最后保持符号位不变，经历一遍后，即可得到补码\n* 定点数和浮点数\n    * 定点数\n        * 小数点固定在某个位置上的数据\n            * 32位定点小数、定点整数补码的范围\n                * 32位定点小数-1～1-2-31\n                *  32位定点整数-231～231-1\n    * 浮点数\n        * 根据IEEE754国际标准，常用的浮点数有两种格式\n            * Nmax=Mmax*2的Emax\nNmin=Mmin*2的Emax\n            * 单精度(32位)=8位阶码+24位尾数\n                * 单精度浮点数(32位)，阶码8位(含一位符号位)，尾数24(含一位符号位)，取值范围:-2的127次方～(1-2的-23次方)*2的127次方\n            * 双精度(64位)=11位阶码+53位尾数\n                * 双精度浮点数(64位)，阶码11位(含一位符号位)，尾数53位(含一位符号位)，取值范围:-2的1023次方～(1-2的-52次方)*2的1023次方\n        * 为了保证数据精度，尾数通常用规格化形式表示:当R=2，且尾数值不为0时，其绝对值应大于或等于(0.5)10\n            * 左规\n            * 右规\n        * 小数点位置可以浮动的数据。\n        * 表示形式：N = M · RE\n        * 计算机中存储形式\n            * Ms+Es+E(n位)+M(m位)\n                * 阶码E，一般为整数，用补码或者移码表示；\n                * 尾数M，一般为规格化的定点小数，用补码表示；\n### 二进制乘法运算\n* 定点原码一位乘法\n    * 两个原码数相乘，其乘积的符号为相乘两数符号的异或值，数值则为两数绝对值之积\n        * [X·Y]原=[X]原·[Y]原=(X0⊕Y0)|(X1X2..Xn) · (Y1Y2..Yn)\n    * 几点结论\n        * 从低到高根据乘数每位0、1决定相加被乘数还是0；\n        * 相加数每次左移，最后一起求积；\n        * 符号由异或决定\n    * 表达式\n    * 电路框架\n    * 修正\n        * 1.在机器内多个数据一般不能同时相加，一次加法操作只能求出两数之和，因此每每求得一个相加数，就与上次部分积相加\n        * 2.人工计算时，相加数逐次向左偏移一位，由于最后的乘积位数是乘数(或被乘数)的两倍，如按此算法在机器中运算，加法器也需增到两倍。观察计算过程很容易发现，在求本次部分积时，前一次部分积的最低位不再参与运算，因此可将其右移一位，相加数可直送而不必偏移，于是用N位加法器就可实现两个N位数相乘\n        * 部分积右移时，乘数寄存器同时右移一位，这样可以用乘数寄存器的最低位来控制相加数(取被乘数或零)，同时乘数寄存器的最高位可接受部分积右移出来的一位，因此，完成乘法运算后，A寄存器中保存乘积的高位部分，乘数寄存器中保存乘积低位部分\n    * 例题\n    * 控制流程图\n* 定点补码一位乘法\n    * 表达式\n    * [X·Y]补=[X]补·(－Y0+Y1·2-1+….Yn·2-n)\n    * 注意：此处为双符号位，当最后乘积高位为负数时，需要补充加上[-|x|]补的操作\n### 二进制除法\n* 加减交替法\n    * 当余数为正时，商上1，求下一位商的办法是，余数左移一位，再减去除数;当余数为负时，商上0，求下一位商的办法是，余数左移一位，再加上除数。此方法不用恢复余数，所以又叫不恢复余数法。但若最后一次上商为0而又需得到正确余数，则在这最后扔需恢复余数\n### 浮点数的运算方法\n* 浮点数的加减法运算\n    * 1.对阶操作\n        * 求出△E，再对小的进行移位\n    * 2.尾数的加减运算\n    * 3.规格化操作\n        * 规则简化是符号位和数值最高位不同，即00.1xxxx或11.0xxxx\n    * 4.舍入\n        * 超出表示范围的高位为1舍入\n    * 5.检查阶码是否溢出\n* 浮点数的乘除法运算\n    * 1.浮点数阶码运算(移码)\n        * 牢记公式\n            * [X+Y]移=[X]移+[Y]补\n            * [X–Y]移=[X]移+[–Y]补\n    * 2.按照一位乘或加减交替除运算\n        * 先确定符号，在列式子计算\n### 运算部件\n* ABC寄存器作业\n* 定点运算部件\n* 浮点运算部件\n    * 由阶码运算部件和尾数运算部件组成\n### 数据校验码\n* 码距\n    * 任意两个合法码之间不相同的二进制位数的最小值\n        * 要具有差错能力，则码距>1\n        * 合理增大码距，就能提高发现错误的能力\n* 鉴定方法\n    * 有无差错能力\n    * 是否能合理增大码距\n* 奇偶校验码\n    * 能发现数据代码中一位或奇数个位出错情况的编码\n    * 实现原理是使码距由1增加到2\n        * 步骤1：在字节高位补充一位，即校验位\n        * 步骤2：依据图3.10电路形成原始数据D8..D1的校验位值\n        * 步骤3：将9位数据写入主存\n        * 步骤4：读出该数据时，读取数据D8..D1通过图3.10判定合法性\n    * 电路图\n    * 结论\n        * （1）奇偶校验码只能发现一位或奇位错，且不能确定出错位置\n        * （2）奇偶校验码的码距=2\n* 海明校验码\n    * 海明码位号和校验位位号的关系\n        * Pi的位置在2的i-1次方，但是除了最高位\n    * 笔记\n        * 3,5,7||3,6,7||5,6,7\n    * 电路图\n    * 海明码码距为4\n    * 纠一位错，查一位错\n        * 2∧r≥k+r+1\n    * 纠一位错，查两位错\n        * 2∧(r–1)≥k+r\n* 循环冗余校验码(CRC)\n    * CRC码可以发现并纠正信息存储或传送过程中连续出现的多位错误\n    * CRC码一般是指k位信息码之后拼接r位校验码\n    * 模2运算\n        * 模2加减\n        * 模2乘除\n        * 异或逻辑\n    * CRC的译码与纠错\n        * 更换不同的待测码字可以证明:余数与出错位的对应关系是不变，只与码制和生成多项式有关\n        * 图\n## 第四章 主存储器\n### 主存储器处于全机中心低位\n### 辅助存储器或称为外存储器，通常用来存放主存的副本和当前不在运行的程序和数据\n### 主存储器的类型\n* 随机存储器RAM\n* 非易失性存储器\n### 主存储器的主要技术指标\n* 主存容量\n    * 64×8等等\n    * 计算机可寻址的最小信息单元是一个存储字\n    * 主存储器存储单元的总数\n* 存取速度\n    * 由存储器存取时间和存储周期表示\n* 存储器存取时间\n    * 启动一次存储器操作(读/写)到完成该操作所经历的时间\n* 存储周期\n    * 连续启动两次独立的存储器操作所间隔的最小时间\n### 主存储器的基本操作\n* CPU通过使用AR(地址寄存器)和DR(数据寄存器)和主存进行数据传送\n* 若AR为K位字长，DR为n位字长，则允许主存包含2∧k个可寻址单元\n* CPU与主存采取异步工作方式，以ready信号表示一次访存操作的结束\n### 读/写存储器\n* 随机存储器(RAM)按存储元件在运行中能否长时间保存信息分为静态存储器和动态存储器\n* 静态存储器，利用触发器保存信息，只要不断电，信息就不会丢失\n    * 电路简图\n    * MOS静态存储结构图\n* 动态存储器，利用MOS电容存储电荷来保存信息，需要不断给电容充电才能使信息来保存信息\n    * 电路简图\n    * 16K×1位动态存储器框图\n    * 再生\n        * 集中式\n        * 分散式\n        * 时间小于或等于2ms\n        * 行读出再生\n### 非易失性半导体存储器\n* 只读存储器ROM\n    * 只读不能写\n* 可编程序的只读存储器PROM\n    * 一次性写入\n* 可擦可编程序的只读存储器EPROM\n    * 可多次写入、读出\n* 可电擦可编程序只读存储器E2PROM\n    * 可多次读出但写入次数有限\n* 快擦除读写存储器Flash Memory\n    * 重复写入、读出\n### 存储器的组成与控制\n* 存储器容量扩展\n    * 位扩展:用多个存储器芯片对字长进行扩充\n    * 字扩展:增加存储器中字的数量，提高存储器的寻址范围\n    * 字位扩展，假设一个存储器的容量为M×N位，若使用L×K位存储器芯片，那么，这个存储器共需要(M/L)×(N/K)个存储器芯片\n### 多体交叉存储器\n* 提高访存速度的方式\n    * 采用高速器件\n    * 采用层次结构\n    * 调整主存结构\n* 计算机中大容量的主存可由多个存储体组成，每个存储体都具有自己的读写线路，地址寄存器和数据寄存器，称为\"存储模块\"。这种多模块存储器可以实现重叠与交叉存取\n* 第i个模块M的地址编号应按下式给出:M×j+i\n* 连续地址分布在相邻的不同模块内，而同一模块内的地址都是不连续的\n## 第五章:指令系统\n### 指令系统的发展\n* 20世纪70年代末人们提出了便于VLSI实现的精简指令系统计算机，简称RISC，同时将指令系统越来越复杂的计算机称为复杂指令系统计算机，简称CISC\n### 指令格式\n* 结构(操作码+地址码)\n    * 操作码\n    * 操作数的地址\n    * 操作结果的存储地址\n    * 下一条指令的地址\n* 地址码\n    * 零地址指令\n    * 一地址指令\n        * 寻址范围  224 = 16 M\n            * 2次访存\n    * 二地址指令\n        * 寻址范围  212 = 4 K\n            * 4 次访存\n    * 三地址指令\n        * 寻址范围  28 = 256\n            * 4 次访存\n    * 多地址指令\n        * 寻址范围  26 = 64\n            * 4 次访存\n* 指令字长\n    * 取决因素\n        * 操作码的长度\n        * 操作数地址的长度\n        * 操作数地址的个数\n    * 指令字长 固定\n        * 指令字长 = 存储字长\n    * 指令字长 可变\n        * 按字节的倍数变化\n    * 对准边界存放\n        * 不连续存放数据\n        * 按字节编址\n            * a.半字地址最低位恒为0\n            *  b.字地址最低两位恒为0\n            * c.双字地址的最低三位恒为0\n        * 减少访存次数，浪费存储空间\n    * 不 对 准 边 界 存 放\n        * 连续存放数据\n        * 节约存储器空间，但增加访存次数，对多字节数据存在调整高 低字节位置的问题\n* 寻址方式\n    * 确定本条指令的数据地址\n    * 下一条要执行的指令地址的方法\n* 指令操作码的扩展技术\n    * 指令操作码的长度决定了指令系统中完成不同操作的指令数\n    * 若某机器的操作码长度固定为K位，则它最多只能有2^K条不同指令\n    * 指令操作码两种格式\n        * 固定格式\n            * 优点:对于简化硬件设计，减少指令译码时间非常有利\n            * 缺点:指令少，浪费地址\n        * 可变格式(分散地放在字的不同字段)\n            * 优点:指令多，缩短指令平均长度，减少程序总位数，增加指令字所能表示的操作信息\n            * 缺点:译码复杂，控制器的设计难度增大\n    * 拓展方法的一个重要原则\n        * 使用频度(即指令在程序中出现概率)高的指令应分配短的操作码，使用频度低的指令相应地分配较长的操作码\n* 指令系统的兼容性\n    * 保持系统向上兼容\n### 精简指令系统计算机（RISC）——用于小型机\n### 复杂指令系统计算机（CISC）——用于大型机\n## 第六章：中央处理器\n### 计算机工作过程\n* 加电——》产生reset信号——》执行程序——》停机——》停电\n* 产生reset信号的任务\n    * 任务一：使计算机处于初始状态\n    * 任务二：从PC中取出指令地址\n* 控制器作用是协调并控制计算机各部件执行程序的指令序列\n### 控制器的组成\n* 控制器的功能\n    * 取指令\n        * 发出指令地址，取出指令的内容\n    * 分析指令\n        * （1）对操作码译码产生操作相应部件的控制信号\n        * （2）根据寻址方式形成操作数地址\n    * 执行指令\n        * （1）根据分析指令后产生控制信号、操作数地址信号序列，通过CPU及输入输出设备的执行实现每条指令的功能\n        * （2）结果回送存储器\n        * （3）形成下条指令的地址\n    * 控制程序和数据的输入和结果输出\n    * 对异常情况和某些请求的处理\n        * 异常情况的处理：例如算术运算的溢出、数据传送奇偶错\n        * 某些请求的处理\n            * “中断请求”信号\n            * DMA请求信号\n* 控制器的组成\n    * 程序计数器（PC）\n        * 即地址寄存器，用来存放当前正在执行的指令地址或即将要执行的下一条指令地址\n    * 指令寄存器（IR）\n        * 用以存放当前正在执行的指令，以便在指令执行过程中控制完成一条指令的全部功能\n    * 指令译码器或操作码译码器\n        * 对指令寄存器中的操作码进行分析解释，产生相应的控制信号\n    * 脉冲源及启停线路\n        * 脉冲源参数一定评率的脉冲作为整个机器的时钟脉冲，是机器周期和工作脉冲的基准信号，在机器刚加电时，还应产生一个总清信号（reset）\n    * 时序控制信号形成部件\n        * 当程序启动后，在CLK时钟作用下，根据当前正在执行的指令的需要，产生相应的时序控制信号，并根据被控制功能部件的反馈信号调整时序控制信号\n            * 控制存储器\n            * 微指令寄存器\n                * 控制字段+下址\n    *  周期概念\n        * 指令周期\n            * 完成一条指令所需的时间，包括取指令、分析指令、执行指令\n        * 机器周期\n            * 也称为CPU周期，是CPU从内存中读取一个指令的时间，通常等于取指周期\n        * 时钟周期\n            * 称为节拍脉冲或T周期，是基准脉冲信号\n    * 三条假设\n        * 程序是存放在主存中的，当执行完一条指令后才从主存中取下一条指令（非流水线）\n        * 指令的长度是固定的，并限制了寻址方式的多样化\n        * 在程序运行前，程序和数据都已存在主存中\n* 指令执行过程（运算器和控制器配合）\n    * 组成控制器的基本电路\n        * 具有记忆功能的触发器以及由它组成的寄存器，计数器和存储单元\n        * 没有记忆功能的门电路及由它组成的加法器，算术逻辑运算单元（ALU）和各种逻辑电路\n    * 举例\n        * 加法\n            * 取指令——》计算操作数地址——》取操作数——》执行结果并运算送结果\n        * 要能看懂时序图\n            * 哪些指令在对应的时间有效\n        * 条件转移指令\n            * 取指令——》计算地址\n    * 控制器的功能就是按每一条指令的要求产生所需的控制信号\n    * 产生控制信号的方法\n        * 微程序控制\n        * 硬布线控制\n### 微程序控制计算机的基本工作原理\n* 基本概念\n    * 微指令\n        * 在微程序控制的计算机中，将由同时发出的控制信号所执行的一组微操作\n    * 微命令\n        * 将指令分为若干条微指令，按次序执行这些微指令。组成微指令的操作即微命令\n    * 微程序\n        * 计算机的程序由指令序列构成，而计算机每条指令的功能均由微指令序列解释完成，这些微指令序列的集合就叫做微程序\n    * 控制存储器\n        * 微程序一般是存放在专门的存储器中的，由于该存储器主要存放控制命令（信号）与下一条执行的微指令地址（简称下址）\n        * 存储单元内容\n            * （1）微指令的控制信号——控制位\n            * （2）下条微指令的地址——下址字段\n        * 存储芯片：ROM\n    * 执行一条指令实际上就是执行一段存放在控制存储器中的微程序\n* 实现微程序控制的基本原理\n    * 控制信号（23条）\n    * 书上P123页为加法的过程\n    * 微指令格式：控制字段+下址字段\n    * 23个控制位，12个下址位——》容量为4K\n    * 取址微指令的操作对所有指令都是相同的，所以是一条公用的微指令，其下址由操作码译码产生\n* 微程序控制器\n* 时序信号及工作脉冲的形成\n* 停机和停电的区别\n    * 停机\n        * 电压：稳定\n            * 存放内容：保持\n                * 重启PC内容：断点指令地址\n    * 停电\n        * 电压：消失\n            * 存放内容：RAM的内容消失\n                * 重启PC内容：第一条指令地址\n### 微程序设计技术\n* 如何缩短微指令字长\n    * 直接控制法（容量太小）\n        * 编译方法：每一位代表一个控制信号，直接送往相应的控制点\n        * 优点：控制简单\n        * 缺点：微指令字长过大\n    * 字段直接编译法\n        * 选出互斥的微指令\n        * 每个字段都要留出一个代码，表示本段不发出任何指令（000）\n        * 优点：节省微指令的字长\n        * 缺点：增加了额外的硬件开销\n    * 字段间接编译法\n        * 指令之间相互联系的情况\n        * 举例：A为0-7，B为0-3，如果是直接编译——3+2=5，如果是间接编译——3+1=4\n        * 编码方法：在字段直接编译法中，译码输出端要兼由另一字段中的某些微命令配合解释\n        * 优点：减少了微指令长度\n        * 缺点：可能削弱微指令的并行控制能力，同时增加硬件开销\n    * 常熟源字段E(了解)\n* 如何减少微指令长度\n    * 现行微指令/微地址\n        * 现行微指令：当前正在执行的指令\n        * 现行微地址：存放现行微指令的控制器存储单元\n    * 后继微指令/微地址\n        * 后继微指令：下一条要执行的微指令\n        * 后继微地址：存放后继微指令的控制器存储单元\n    * 增量与下址字段结合产生后继微指令的方法\n        * 下址字段分成：转移控制字段BCF和转移地址字段BAF\n            * BCF：控制微程序的转移情况\n            * BAF：转移后的微指令所在地址\n        * BAF有两种情况\n            * 与uPC的位数相等——转移灵活，但增加微指令长度\n            * 比uPC短——转移地址收到限制，但可缩短微指令长度\n        * 优点\n            *  微指令的下址字段很短，仅用于选择输入uPC计数器的某条线路有效\n        * 缺点\n            * 微程序转移不灵活，使得微程序在控存中的物理空间分配有困难\n    * 多路转移方式\n        * 一条微指令存在多个转移分支的情况称为多路转移\n    * 微中断\n        * 1.微中断请求信号是由程序中断请求信号引起的\n        * 2.在完成现行指令的微程序后响应该微中断请求\n        * 3.由硬件产生对应微中断处理程序在控存中的入口地址\n* 如何提高微程序的执行速度\n* 微指令格式\n    * 水平型微指令——直接控制，字段编译（直接、间接）\n        * 特点：在一条微指令中定义并并行执行多个微命令\n    * 垂直型微指令\n        * 特点：不强调实现微指令的并行控制功能\n        * 定义：采用微操作码编译法，由操作码规定微指令的功能\n* 微程序控制存储器\n    * 一般采用ROM存储器\n    * 也可采用RAM，为防止断电后内容消失，则必须开机后将外存中存放的微程序调入控存RAM，然后才能执行程序。\n    * 当前为了能不断扩展指令系统，通常采用ROM+RAM\n* 动态微程序设计\n    * 定义：能根据用户要求改变微程序\n    * 优点：是计算机能更灵活、有效的适应于各种不同的应用目标\n* 控制存储器的操作（P136）\n    * 串行方式\n    * 并行方式——比串行多了微指令寄存器\n        * 微周期=max(取微指令时间,执行微指令时间)\n        * 由于取微指令、执行微指令同时进行，故对于某些后继微地址的产生根据处理结果而定的微指令，则延迟一个微周期再取微指令\n### 硬布线控制的计算机（RISC）——特点快\n* 形成操作控制信号的逻辑框图（P141）\n* 操作控制信号的产生\n    * 取值周期cy1所产生的信号对所有指令都是相同的，即与当前执行的指令无关，逻辑式得到最简单的形式\n    * 通常，同一个控制控制信号在若干条指令的某些周期（或再加上一些条件）中都需要，为此需要把它们组合起来\n    * 同种类型的指令所需要的控制信号大部分是相同的，仅有少量区别\n    * 在确定指令的操作码时（即对具体指令赋予二进制操作码），为了便于逻辑表达式的化简以减少逻辑电路数量，往往给予特别关注\n* 设计组合逻辑电路从而产生需要的控制信号的步骤\n    * 1.实际逻辑问题2.真值表3.公式化简4.逻辑电路图\n* 设计目标\n    * 使用最少的电路元件达到最高的操作速度\n### 流水线工作原理\n* 几点结论\n    * 每条指令的执行时间不变\n    * 每条指令处理结果的时间缩短\n    * 流水线处理速率最高时=流水线处于满载的稳定状态\n    * 流水线处理速率最低时=流水线未满载状态\n    * 为了满足在重叠时间段不同指令的机器周期能够完成指定的操作，将时间段=操作完成的最长时间\n    * 为了保证一个周期内流水线的输入信号不变，相邻时间段之间必须设置锁存器或寄存器\n    * 除了指令执行流水线，还有运算操作流水线\n* 相关问题\n    * 流水线阻塞（P163-6.15）\n        * 数据相关产生\n            * 假设第二条指令需要的操作数是第一条指令运算的结果，那么出现了数据相关\n        * 指令执行时间不同产生\n        * 程序转移的影响\n        * 异常情况响应中断\n## 第七章：存储系统\n### 存储系统的层次结构\n* cache->主存->辅存\n### 高速缓冲存储器\n* cache的工作原理\n    * 局部性原理\n    * 主存地址和cache地址（P166 图7.2）\n    * 块长\n        * 块长一般取一个主存周期所能调出的信息长度（一般为16个字）\n    * cache的容量和块的大小是影响cache的效率的重要因素\n    * 命中率\n        * CPU所要访问的信息是否在cache中的比率，而将所要访问的信息不在cache中的比率称为失败率\n    * 一致性策略\n        * 标志交换方式（写回法）\n        * 通过式写入（写通法）\n        * 写操作直接对主存进行，而不写入cache\n    * cache的存取时间\n        * 平均存取时间=h*tc+(1-h)(tc+tm) \n    * 最好替换策略\n        * 按照被替换的字块是下一段时间最少使用的，由替换部件实现\n* cache组织\n    * 地址映像\n        * 直接映像\n            * cache中许多空的位置被浪费\n            * 主存地址：主存字块标记+cache字块地址+字块内地址\n        * 全相联映像\n            * 成本太高而不能采用\n            * 主存地址：主存字块标记+字块内地址\n            * 优点\n                * 方式灵活，缩小了块发生冲突的概率\n            * 缺点\n                * 增加了标识位位数\n                * 增加了寻找主存块在cache中对应块的时间\n        * 组相联映像\n            * 直接映像和全相联映像的折衷\n            * 主存地址：主存字块标记+组地址+块内地址\n### 虚拟存储器\n* 存储管理部件（MMU）\n    * 现代计算机一般都有辅助存储器，但具有辅存的存储系统不一定是虚拟存储系统\n    * 虚拟存储系统的特点\n        * 允许用户程序用比主存大的多的空间来访问主存\n        * 每次访存都要进行虚实地址的转换\n## 第八章：辅助存储器\n### 半导体存储器可随机访问任一单元，而辅助存储器一般为串行访问存储器\n### 辅助存储器的种类\n* 磁表面存储器\n    * 数字式磁记录\n        * 硬盘、软盘和磁带\n    * 模拟式磁记录\n        * 录音、录像设备\n* 光存储器\n    * 光盘\n### 串行存储器\n* 顺序存取存储器\n* 直接存取存储器\n### 辅助存储器的技术指标\n* 存储密度\n    * 定义：单位长度或单位面积磁层表面磁层所存储的二进制信息量\n    * 道密度\n        * 沿磁盘半径方向单位长度的磁道数称为道密度，单位为道/英寸tpi或道/毫米tpmm\n    * 位密度或线密度\n        * 单位长度磁道所能记录二进制信息的位数叫位密度或线密度，单位为位/英寸bpi或位/毫米bpmm\n    * 每个磁道所存储的信息量是一样的\n* 存储容量\n    * C = n × k × s\n* 寻址时间\n    * 平均寻址时间Ta=平均找道时间Ts+平均等待时间Tw\n    * 辅存的速度\n        * 寻址时间\n        * 磁头读写时间\n* 数据传输率\n    * Dr  = D × V\n* 误码率\n* 价格\n### 硬磁盘存储器的类型\n* (1) 固定磁头和移动磁头\n* (2) 可换盘和固定盘\n### 磁盘存储器\n* 温彻斯特磁盘简称温盘\n* 磁盘存储器由驱动器（HDD），控制器（HDC）和盘片组成\n* 最外面的同心圆叫0磁道，最里面的同心圆假设称为n磁道\n* 驱动器的定位驱动系统实现快速精准的磁头定位\n* 主轴系统的作用是带动盘片按额定转速稳定旋转\n* 数据控制系统的作用是控制数据的写入和读出，包括寻址，磁头旋转，写电流控制，读出放大，数据分离\n* 磁盘控制器有两个方向的接口\n    * 与主机的接口\n    * 与驱动器（设备）的接口\n### 光盘\n* 采用光存储技术\n    * 利用激光写入和读出\n    * 第一代光存储技术\n        * 采用非磁性介质\n            * 不可擦写\n    * 第二代光存储技术\n        * 采用磁性介质\n            * 可擦写\n* 光盘的存储原理\n    * 只读型和只写一次型\n        * 热作用（物理或化学变化）\n    * 可擦写光盘\n        * 热磁效应\n## 第九/十章：输出输出（I/O）设备/系统\n### 设备控制器（I/O）的基本功能\n* 实现主机和外部设备之间的数据传送\n* 实现数据缓冲，以达到主机同外部设备之间的速度匹配\n* 接受主机的命令，提供设备接口的设备，并按照主机的命令控制设备\n### I/O 编址方式\n* (1) 统一编址：用取数、存数指令\n* (2) 不统一编址：有专门的 I/O 指令\n### I/O 与主机的连接方式\n* 辐射式连接\n    * 每台设备都配有一套\n    * 控制线路和一组信号线\n    * 不便于增删设备\n* 总线连接\n    * 便于增删设备\n### I/O设备\n* 人机交互设备\n    * 键盘、鼠标等\n* 计算机信息的驻留设备\n    * 硬盘、光盘等\n* 机——机通信设备\n    * MODEN等\n### 为什么要设置接口？\n* 1. 实现设备的选择\n* 2. 实现数据缓冲达到速度匹配\n* 3. 实现数据串     并格式转换\n* 4. 实现电平转换\n* 5. 传送控制命令\n* 6. 反映设备的状态\n    * （“忙”、“就绪”、“中断请求”）\n### 中断服务程序的流程\n* (1) 保护现场\n    * 程序断点的保护\n    * 寄存器内容的保护\n* (2) 中断服务\n    * 对不同的 I/O 设备具有不同内容的设备服务\n* (3) 恢复现场\n    * 出栈指令\n* (4) 中断返回\n    * 中断返回指令\n### 单重中断和多重中断\n* 单重 中断\n    * 不允许中断 现行的 中断服务程序\n* 多重 中断\n    * 允许级别更高 的中断源\n    * 中断 现行的 中断服务程序\n### DMA 方式\n* 主存和 I/O 之间有一条直接数据通道\n* CPU 和 I/O 并行工作\n* DMA 的三种工作方式\n    * (1) CPU暂停方式\n    * (2) CPU周期窃取方式\n    * (3)直接访问存储器\n* DMA 接口功能\n    * (1) 向 CPU 申请 DMA 传送\n    * (2) 处理总线 控制权的转交\n    * (3) 管理 系统总线、控制 数据传送\n    * (4) 确定 数据传送的 首地址和长度，修正 传送过程中的数据地址和长度\n    * (5) DMA 传送结束时，给出操作完成信号\n* DMA 传送过程\n    * 预处理、数据传送、后处理\n### 外设接口\n* 设备与主机相连时，必须按照规定的物理互连特性、电气特性等进行连接，这些特性的技术规范称为接口标准\n\n![计算机组成原理思维导图图片](https://img-blog.csdn.net/20180620085759852?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0Nhb3lhbmdfSGU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n","tags":["408"]},{"title":"Ubuntu 18.04.1 LTS 安装tensorflow-gpu","url":"/post/机器学习/Ubuntu 18.04.1 LTS 安装tensorflow-gpu/index.html  2019/03/04/机器学习/Ubuntu 18.04.1 LTS 安装tensorflow-gpu/","content":"# Ubuntu 18.04.1 LTS 安装tensorflow-gpu\n## 1.安装驱动\n![93](https://obs-one-for-fan.obs.cn-north-1.myhwclouds.com/imageHosting/1547012467893.png)\n## 2.安装python3.6\n```\nwget http://www.python.org/ftp/python/3.6.4/Python-3.6.4.tgz \ntar -xvzf Python-3.6.4.tgz cd Python-3.6.4 \n./configure --with-ssl \nmake \nsudo make install\nsudo apt-get install pip3\n```\n## 4.CUDA Toolkit 9.0\n[下载地址](https://developer.nvidia.com/cuda-90-download-archive?target_os=Linux&target_arch=x86_64&target_distro=Ubuntu&target_version=1604&target_type=deblocal)\n![1547038387531](https://obs-one-for-fan.obs.cn-north-1.myhwclouds.com/imageHosting/1547038387531.png)\n进入步骤1.1中下载文件\n`cuda_9.0.176_384.81_linux.ru`\n在安装CUDA前先装依赖包\n```\nsudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libglu1-mesa-dev\n```\n所在目录，执行如下命令安装CUDA 9.0：\n```\nsudo chmod +x cuda_9.0.176_384.81_linux.run \nsudo ./cuda_9.0.176_384.81_linux.run -override\n```\n```\nDo you accept the previously read EULA?\naccept/decline/quit: accept\n\nYou are attempting to install on an unsupported configuration. Do you wish to continue?\n(y)es/(n)o [ default is no ]: y\n\nInstall NVIDIA Accelerated Graphics Driver for Linux-x86_64 384.81?\n(y)es/(n)o/(q)uit: n\n\nInstall the CUDA 9.0 Toolkit?\n(y)es/(n)o/(q)uit: y\n\nEnter Toolkit Location\n [ default is /usr/local/cuda-9.0 ]: \n\nDo you want to install a symbolic link at /usr/local/cuda?\n(y)es/(n)o/(q)uit: y\n\nInstall the CUDA 9.0 Samples?\n(y)es/(n)o/(q)uit: \nInstall the CUDA 9.0 Samples?\n(y)es/(n)o/(q)uit: y\n\nEnter CUDA Samples Location\n [ default is /home/lovemefan ]: \n\nInstalling the CUDA Toolkit in /usr/local/cuda-9.0 ...\nMissing recommended library: libGLU.so\nMissing recommended library: libX11.so\nMissing recommended library: libXi.so\nMissing recommended library: libXmu.so\nMissing recommended library: libGL.so\n\nInstalling the CUDA Samples in /home/lovemefan ...\nCopying samples to /home/lovemefan/NVIDIA_CUDA-9.0_Samples now...\nFinished copying samples.\n\n===========\n= Summary =\n===========\n\nDriver:   Not Selected\nToolkit:  Installed in /usr/local/cuda-9.0\nSamples:  Installed in /home/lovemefan, but missing recommended libraries\n\nPlease make sure that\n -   PATH includes /usr/local/cuda-9.0/bin\n -   LD_LIBRARY_PATH includes /usr/local/cuda-9.0/lib64, or, add /usr/local/cuda-9.0/lib64 to /etc/ld.so.conf and run ldconfig as root\n\nTo uninstall the CUDA Toolkit, run the uninstall script in /usr/local/cuda-9.0/bin\n\nPlease see CUDA_Installation_Guide_Linux.pdf in /usr/local/cuda-9.0/doc/pdf for detailed information on setting up CUDA.\n\n***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 384.00 is required for CUDA 9.0 functionality to work.\nTo install the driver using this installer, run the following command, replacing <CudaInstaller> with the name of this run file:\n    sudo <CudaInstaller>.run -silent -driver\n\nLogfile is /tmp/cuda_install_28234.log\n\n```\n\n\n\n## 4.CUDNN 7.0 \n\n[下载地址](https://developer.nvidia.com/rdp/cudnn-download)\n\n![1547025670135](https://obs-one-for-fan.obs.cn-north-1.myhwclouds.com/imageHosting/1547025670135.png)\n\n```\ntar -xzvf cudnn-9.0-linux-x64-v7.4.2.24.tgz\nsudo cp cuda/include/cudnn.h /usr/local/cuda/include\nsudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64\nsudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*\n```\n\n\n\n## 5.libcupti\n\n安装libcupti库\n\n```\nsudo apt-get install libcupti-dev\n```\n\n---------------------\n## 6.配置\n\n```\nsudo gedit ~/.bashrc\n```\n\n```\nexport CUDA_HOME=/usr/local/cuda\nexport PATH=/usr/local/cuda-9.0/bin:$PATH\nexport LD_LIBRARY_PATH=/usr/local/cuda-9.0/lib64:$LD_LIBRARY_PATH\n```\n\n一定要执行下面命令刷新环境变量\n\n```\n. ~/.bashrc\n```\n\npycharm 中配置\n\n打开 Run-Edit Configurations\n\n![1547275915797](https://obs-one-for-fan.obs.cn-north-1.myhwclouds.com/imageHosting/1547275915797.png)\n将下面添加到环境变量\n![1547276126564](https://obs-one-for-fan.obs.cn-north-1.myhwclouds.com/imageHosting/1547276126564.png)\n\n\n```\nLD_LIBRARY_PATH=/usr/local/cuda-9.0=/usr/local/cuda-9.0\n```\n\n\n\n## 7.测试\n在pycharm中运行一个hello world\n```python\nimport  tensorflow as tf\nhello = tf.constant(\"hello tensorflow\")\nwith tf.Session() as sess :\n    print(sess.run(hello))\n```\n结果如下\n```shell\n/usr/bin/python3 /home/lovemefan/python_project/practice/hello_tensorflow.py\n2019-01-12 15:01:21.072275: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: AVX2 FMA\n2019-01-12 15:01:21.253447: I tensorflow/stream_executor/cuda/cuda_gpu_executor.cc:964] successful NUMA node read from SysFS had negative value (-1), but there must be at least one NUMA node, so returning NUMA node zero\n2019-01-12 15:01:21.253901: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1432] Found device 0 with properties: \nname: GeForce GTX 970M major: 5 minor: 2 memoryClockRate(GHz): 1.038\npciBusID: 0000:01:00.0\ntotalMemory: 2.95GiB freeMemory: 2.65GiB\n2019-01-12 15:01:21.253925: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1511] Adding visible gpu devices: 0\n2019-01-12 15:01:26.381187: I tensorflow/core/common_runtime/gpu/gpu_device.cc:982] Device interconnect StreamExecutor with strength 1 edge matrix:\n2019-01-12 15:01:26.381251: I tensorflow/core/common_runtime/gpu/gpu_device.cc:988]      0 \n2019-01-12 15:01:26.381271: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1001] 0:   N \n2019-01-12 15:01:26.381661: I tensorflow/core/common_runtime/gpu/gpu_device.cc:1115] Created TensorFlow device (/job:localhost/replica:0/task:0/device:GPU:0 with 2345 MB memory) -> physical GPU (device: 0, name: GeForce GTX 970M, pci bus id: 0000:01:00.0, compute capability: 5.2)\nb'hello tensorflow'\n\nProcess finished with exit code 0\n```\n","tags":["机器学习"]},{"title":"个人网站首次备案的记录","url":"/post/其他/为什么要备案/index.html  2018/10/12/其他/为什么要备案/","content":"\n## 为什么要备案\n>根据国务院令第292号《互联网信息服务管理办法》和工信部令第 33 号《非经营性互联网信息服务备案管理办法》规定，国家对经营性互联网信息服务实行许可制度，对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务，否则属于违法行为。\n### 不备案的影响\n域名将无法解析\n也就是说，使用`中国大陆境`内的服务器开办网站必须先办理网站备案，备案成功才能合法的使用域名解析,不然买个域名啥都没用.不想备案就只能使用香港或境外服务器,笔者学生党买不起\n## 如何备案\n目前阿里云,腾讯云,百度云都可代理备案\n首先备案需要个人真实信息,不需要收费\n### 备案基本流程\n ![mark](http://oskhhyaq3.bkt.clouddn.com/img/180918/7dgiEHL5EG.png?imageslim)\n### 注意事项\n* 网站名称要求三个字以上（含三个字）,不可以有敏感词啦,个人网站名称要尽量体现个人网站的主要内容；例如，技术分享类，个人爱好类；不能涉及到论坛、博客、行业、企业、产品、经营性等信息，且个人网站名称请勿涉及个人姓名、域名、地名、成语。(`不合格则驳回`)\n* 域名千万别解析,管局规则要求，未取得备案号的域名，在备案期间禁止打开访问(`解析就驳回`)\n## 进度记录\n### 完成备案信息\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180918/8cE6agi6hb.png?imageslim)\n上传材料有身份证正反面,还有穿着衣服的非裸贷手持身份证照片(+_+)以及网站核验单(按要求来)\n\n我的`核验单`长这个样子,腾讯云的\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180918/AhLEmdeG58.png?imageslim)\n\n### 备案信息第一次提交结果\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180918/iKBL70kCIl.png?imageslim)\n审核倒是挺快的,第二天就完成审核\n\n第一次有三点不合格\n* 核验单未按手印\n* 网站名称不合格\n* 把域名解析到了服务器上...  (ˉ▽ˉ；)...\n\n### 备案信息第二次提交结果\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180919/4Jj31KllkF.png?imageslim)\n第二次审核同样是第二天出结果,通过了φ(*￣0￣)\n接下来申请幕布拍照\n### 幕布拍照\n要求:上传在指定幕布的上身照\n审核通过(刚好碰上国庆假期,用了五六天)\n### 管局审核\n这个速度厉害了,国庆放假后一个星期就通过了,感动(ಥ _ ಥ)\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/181012/dhK7F8Id2c.png?imageslim)\n个人网站备案完成","tags":["其他"]},{"title":"视频解析工具分享","url":"/post/学习资料/ivideo/index.html  2018/09/06/学习资料/ivideo/","content":"# ivideo\n发现一款好东西当然要分享出来了\n[Windows,Linux,Mac原项目链接](https://github.com/phobal/ivideo)\n[安卓版原项目链接](https://github.com/CrazyDudo/fvip)\n[网页版原项目链接](https://github.com/alphardex/ivideo-python)\n\n##产品介绍\n\n> 基于 Electron 开发的跨平台客户端版本的视频播放器，该播放器包括国内主流视频平台视频资源，你不用去单独下载各个平台的客户端，只需要使用这一个客户端就能查看所有平台的视频，并且内置了各大视频网站 VIP 资源。\n\n##使用方法\n\n1. 下载客户端 \n* [Mac](https://github.com/phobal/ivideo/releases/download/1.1.1/ivideo-1.1.1-mac.zip)\n* [Windows](https://github.com/phobal/ivideo/releases/download/1.1.1/ivideo-1.1.1-win.zip)\n* [Linux](https://github.com/phobal/ivideo/releases/download/1.0.0/linux-unpacked.v1.0.0.zip)\n* [Android](https://fir.im/qu73) \n* [网页版](https://ivideo-python.herokuapp.com/)\n\n\n2. 选择视频资源  \n\n比方说看腾讯视频上的 VIP 才能看的《下一站,别离》\n\n![](https://github.com/phobal/ivideo/blob/master/resources/showcase01.jpg?raw=true)\n\n点击进去以后提示需要开通VIP才能看\n\n![](https://github.com/phobal/ivideo/blob/master/resources/showcase02.jpg?raw=true)\n\n3. 选择资源播放接口  \n\n![](https://github.com/phobal/ivideo/blob/master/resources/showcase03.jpg?raw=true)\n\n点击【确定】按钮就可以播放了，如果遇到无法播放的情况，请多换几条线路试试\n\n![](https://github.com/phobal/ivideo/blob/master/resources/showcase04.jpg?raw=true)\n\n### 技术栈\n\n* Electron\n* React\n* Redux\n\n### 如何启动\n\n> node version >= 7.6\n\n1. clone 项目到本地\n\n``` bash\n\ngit clone https://github.com/phobal/ivideo.git\n\n```\n\n2. 进入项目 ` cd ivideo`\n3. 安装依赖 `yarn install`(如果没有的话，请全局安装yarn, `npm i yarn -g`)\n4. 打开开发环境 `yarn start`\n\n### 如何编译\n\n* 编译全平台 ` yarn package-all`\n* 编译当前平台 `yarn package`\n* windows: `yarn package-win`\n* Linux `yarn package-linux`\n\n编译出来的包都放在 `release` 目录下\n\n该项目是基于 [electron-react-boilerplate](https://github.com/chentsulin/electron-react-boilerplate) 脚手架 进行创建，感谢 @[chentsulin](https://github.com/chentsulin)","tags":["学习资料"]},{"title":"后端架构师技术图谱 --来自github","url":"/post/学习资料/《后端架构师技术图谱》/index.html  2018/09/05/学习资料/《后端架构师技术图谱》/","content":"`原文地址`[https://github.com/xingshaocheng/architect-awesome](https://github.com/xingshaocheng/architect-awesome)\n`笔者只是Mark一下,侵删`\n<h1>《后端架构师技术图谱》</h1>\n\n\n[![知识共享协议（CC协议）](https://img.shields.io/badge/License-Creative%20Commons-DC3D24.svg)](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)\n[![GitHub stars](https://img.shields.io/github/stars/xingshaocheng/architect-awesome.svg?style=flat&label=Star)](https://github.com/xingshaocheng/architect-awesome/stargazers)\n[![GitHub forks](https://img.shields.io/github/forks/xingshaocheng/architect-awesome.svg?style=flat&label=Fork)](https://github.com/xingshaocheng/architect-awesome/fork)\n[![GitHub watchers](https://img.shields.io/github/watchers/xingshaocheng/architect-awesome.svg?style=flat&label=Watch)](https://github.com/xingshaocheng/architect-awesome/watchers)\n\n**更新于20180624**\n\n\n* [数据结构](#数据结构)\n\t* [队列](#队列)\n\t* [集合](#集合)\n\t* [链表、数组](#链表数组)\n\t* [字典、关联数组](#字典关联数组)\n\t* [栈](#栈)\n\t* [树](#树)\n\t\t* [二叉树](#二叉树)\n\t\t* [完全二叉树](#完全二叉树)\n\t\t* [平衡二叉树](#平衡二叉树)\n\t\t* [二叉查找树（BST）](#二叉查找树bst)\n\t\t* [红黑树](#红黑树)\n\t\t* [B-，B+，B*树](#b-bb树)\n\t\t* [LSM 树](#lsm-树)\n\t* [BitSet](#bitset)\n* [常用算法](#常用算法)\n\t* [排序、查找算法](#排序查找算法)\n\t\t* [选择排序](#选择排序)\n\t\t* [冒泡排序](#冒泡排序)\n\t\t* [插入排序](#插入排序)\n\t\t* [快速排序](#快速排序)\n\t\t* [归并排序](#归并排序)\n\t\t* [希尔排序](#希尔排序)\n\t\t* [堆排序](#堆排序)\n\t\t* [计数排序](#计数排序)\n\t\t* [桶排序](#桶排序)\n\t\t* [基数排序](#基数排序)\n\t\t* [二分查找](#二分查找)\n\t\t* [Java 中的排序工具](#java-中的排序工具)\n\t* [布隆过滤器](#布隆过滤器)\n\t* [字符串比较](#字符串比较)\n\t\t* [KMP 算法](#kmp-算法)\n\t* [深度优先、广度优先](#深度优先广度优先)\n\t* [贪心算法](#贪心算法)\n\t* [回溯算法](#回溯算法)\n\t* [剪枝算法](#剪枝算法)\n\t* [动态规划](#动态规划)\n\t* [朴素贝叶斯](#朴素贝叶斯)\n\t* [推荐算法](#推荐算法)\n\t* [最小生成树算法](#最小生成树算法)\n\t* [最短路径算法](#最短路径算法)\n* [并发](#并发)\n\t* [Java 并发](#java-并发)\n\t* [多线程](#多线程)\n\t* [线程安全](#线程安全)\n\t* [一致性、事务](#一致性事务)\n\t\t* [事务 ACID 特性](#事务-acid-特性)\n\t\t* [事务的隔离级别](#事务的隔离级别)\n\t\t* [MVCC](#mvcc)\n\t* [锁](#锁)\n\t\t* [Java中的锁和同步类](#java中的锁和同步类)\n\t\t* [公平锁 &amp; 非公平锁](#公平锁--非公平锁)\n\t\t* [悲观锁](#悲观锁)\n\t\t* [乐观锁 &amp; CAS](#乐观锁--cas)\n\t\t* [ABA 问题](#aba-问题)\n\t\t* [CopyOnWrite容器](#copyonwrite容器)\n\t\t* [RingBuffer](#ringbuffer)\n\t\t* [可重入锁 &amp; 不可重入锁](#可重入锁--不可重入锁)\n\t\t* [互斥锁 &amp; 共享锁](#互斥锁--共享锁)\n\t\t* [死锁](#死锁)\n* [操作系统](#操作系统)\n\t* [计算机原理](#计算机原理)\n\t* [CPU](#cpu)\n\t\t* [多级缓存](#多级缓存)\n\t* [进程](#进程)\n\t* [线程](#线程)\n\t* [协程](#协程)\n\t* [Linux](#linux)\n* [设计模式](#设计模式)\n\t* [设计模式的六大原则](#设计模式的六大原则)\n\t* [23种常见设计模式](#23种常见设计模式)\n\t* [应用场景](#应用场景)\n\t* [单例模式](#单例模式)\n\t* [责任链模式](#责任链模式)\n\t* [MVC](#mvc)\n\t* [IOC](#ioc)\n\t* [AOP](#aop)\n\t* [UML](#uml)\n\t* [微服务思想](#微服务思想)\n\t\t* [康威定律](#康威定律)\n* [运维 &amp; 统计 &amp; 技术支持](#运维--统计--技术支持)\n\t* [常规监控](#常规监控)\n\t* [APM](#apm)\n\t* [统计分析](#统计分析)\n\t* [持续集成(CI/CD)](#持续集成cicd)\n\t\t* [Jenkins](#jenkins)\n\t\t* [环境分离](#环境分离)\n\t* [自动化运维](#自动化运维)\n\t\t* [Ansible](#ansible)\n\t\t* [puppet](#puppet)\n\t\t* [chef](#chef)\n\t* [测试](#测试)\n\t\t* [TDD 理论](#tdd-理论)\n\t\t* [单元测试](#单元测试)\n\t\t* [压力测试](#压力测试)\n\t\t* [全链路压测](#全链路压测)\n\t\t* [A/B 、灰度、蓝绿测试](#ab-灰度蓝绿测试)\n\t* [虚拟化](#虚拟化)\n\t\t* [KVM](#kvm)\n\t\t* [Xen](#xen)\n\t\t* [OpenVZ](#openvz)\n\t* [容器技术](#容器技术)\n\t\t* [Docker](#docker)\n\t* [云技术](#云技术)\n\t\t* [OpenStack](#openstack)\n\t* [DevOps](#devops)\n\t* [文档管理](#文档管理)\n* [中间件](#中间件)\n\t* [Web Server](#web-server)\n\t\t* [Nginx](#nginx)\n\t\t* [OpenResty](#openresty)  \n\t\t* [Tengine](#Tengine)  \n\t\t* [Apache Httpd](#apache-httpd)\n\t\t* [Tomcat](#tomcat)\n\t\t\t* [架构原理](#架构原理)\n\t\t\t* [调优方案](#调优方案)\n\t\t* [Jetty](#jetty)\n\t* [缓存](#缓存)\n\t\t* [本地缓存](#本地缓存)\n\t* [客户端缓存](#客户端缓存)\n\t* [服务端缓存](#服务端缓存)\n\t\t* [Web缓存](#web缓存)\n\t\t* [Memcached](#memcached)\n\t\t* [Redis](#redis)\n\t\t\t* [架构](#架构)\n\t\t\t* [回收策略](#回收策略)\n\t\t* [Tair](#tair)\n\t* [消息队列](#消息队列)\n\t\t* [消息总线](#消息总线)\n\t\t* [消息的顺序](#消息的顺序)\n\t\t* [RabbitMQ](#rabbitmq)\n\t\t* [RocketMQ](#rocketmq)\n\t\t* [ActiveMQ](#activemq)\n\t\t* [Kafka](#kafka)\n\t\t* [Redis 消息推送](#redis-消息推送)\n\t\t* [ZeroMQ](#zeromq)\n\t* [定时调度](#定时调度)\n\t\t* [单机定时调度](#单机定时调度)\n\t\t* [分布式定时调度](#分布式定时调度)\n\t* [RPC](#rpc)\n\t\t* [Dubbo](#dubbo)\n\t\t* [Thrift](#thrift)\n\t\t* [gRPC](#grpc)\n\t* [数据库中间件](#数据库中间件)\n\t\t* [Sharding Jdbc](#sharding-jdbc)\n\t* [日志系统](#日志系统)\n\t\t* [日志搜集](#日志搜集)\n\t* [配置中心](#配置中心)\n\t* [API 网关](#api-网关)\n* [网络](#网络)\n\t* [协议](#协议)\n\t\t* [OSI 七层协议](#osi-七层协议)\n\t\t* [TCP/IP](#tcpip)\n\t\t* [HTTP](#http)\n\t\t* [HTTP2.0](#http20)\n\t\t* [HTTPS](#https)\n\t* [网络模型](#网络模型)\n\t\t* [Epoll](#epoll)\n\t\t* [Java NIO](#java-nio)\n\t\t* [kqueue](#kqueue)\n\t* [连接和短连接](#连接和短连接)\n\t* [框架](#框架)\n\t* [零拷贝（Zero-copy）](#零拷贝zero-copy)\n\t* [序列化(二进制协议)](#序列化二进制协议)\n\t\t* [Hessian](#hessian)\n\t\t* [Protobuf](#protobuf)\n* [数据库](#数据库)\n\t* [基础理论](#基础理论)\n\t\t* [数据库设计的三大范式](#数据库设计的三大范式)\n\t* [MySQL](#mysql)\n\t\t* [原理](#原理)\n\t\t* [InnoDB](#innodb)\n\t\t* [优化](#优化)\n\t\t* [索引](#索引)\n\t\t\t* [聚集索引, 非聚集索引](#聚集索引-非聚集索引)\n\t\t\t* [复合索引](#复合索引)\n\t\t\t* [自适应哈希索引(AHI)](#自适应哈希索引ahi)\n\t\t* [explain](#explain)\n\t* [NoSQL](#nosql)\n\t\t* [MongoDB](#mongodb)\n\t\t* [Hbase](#hbase)\n* [搜索引擎](#搜索引擎)\n\t* [搜索引擎原理](#搜索引擎原理)\n\t* [Lucene](#lucene)\n\t* [Elasticsearch](#elasticsearch)\n\t* [Solr](#solr)\n\t* [sphinx](#sphinx)\n* [性能](#性能)\n\t* [性能优化方法论](#性能优化方法论)\n\t* [容量评估](#容量评估)\n\t* [CDN 网络](#cdn-网络)\n\t* [连接池](#连接池)\n\t* [性能调优](#性能调优)\n* [大数据](#大数据)\n\t* [流式计算](#流式计算)\n\t\t* [Storm](#storm)\n\t\t* [Flink](#flink)\n\t\t* [Kafka Stream](#kafka-stream)\n\t\t* [应用场景](#应用场景-1)\n\t* [Hadoop](#hadoop)\n\t\t* [HDFS](#hdfs)\n\t\t* [MapReduce](#mapreduce)\n\t\t* [Yarn](#yarn)\n\t* [Spark](#spark)\n* [安全](#安全)\n\t* [web 安全](#web-安全)\n\t\t* [XSS](#xss)\n\t\t* [CSRF](#csrf)\n\t\t* [SQL 注入](#sql-注入)\n\t\t* [Hash Dos](#hash-dos)\n\t\t* [脚本注入](#脚本注入)\n\t\t* [漏洞扫描工具](#漏洞扫描工具)\n\t\t* [验证码](#验证码)\n\t* [DDoS 防范](#ddos-防范)\n\t* [用户隐私信息保护](#用户隐私信息保护)\n\t* [序列化漏洞](#序列化漏洞)\n\t* [加密解密](#加密解密)\n\t\t* [对称加密](#对称加密)\n\t\t* [哈希算法](#哈希算法)\n\t\t* [非对称加密](#非对称加密)\n\t* [服务器安全](#服务器安全)\n\t* [数据安全](#数据安全)\n\t\t* [数据备份](#数据备份)\n\t* [网络隔离](#网络隔离)\n\t\t* [内外网分离](#内外网分离)\n\t\t* [登录跳板机](#登录跳板机)\n\t* [授权、认证](#授权认证)\n\t\t* [RBAC](#rbac)\n\t\t* [OAuth2.0](#oauth20)\n\t\t* [双因素认证（2FA）](#双因素认证2fa)\n\t\t* [单点登录(SSO)](#单点登录sso)\n* [常用开源框架](#常用开源框架)\n\t* [开源协议](#开源协议)\n\t* [日志框架](#日志框架)\n\t\t* [Log4j、Log4j2](#log4jlog4j2)\n\t\t* [Logback](#logback)\n\t* [ORM](#orm)\n\t* [网络框架](#网络框架)\n\t* [Web 框架](#web-框架)\n\t\t* [Spring 家族](#spring-家族)\n\t* [工具框架](#工具框架)\n* [分布式设计](#分布式设计)\n\t* [扩展性设计](#扩展性设计)\n\t* [稳定性 &amp; 高可用](#稳定性--高可用)\n\t\t* [硬件负载均衡](#硬件负载均衡)\n\t\t* [软件负载均衡](#软件负载均衡)\n\t\t* [限流](#限流)\n\t\t* [应用层容灾](#应用层容灾)\n\t\t* [跨机房容灾](#跨机房容灾)\n\t\t* [容灾演练流程](#容灾演练流程)\n\t\t* [平滑启动](#平滑启动)\n\t* [数据库扩展](#数据库扩展)\n\t\t* [读写分离模式](#读写分离模式)\n\t\t* [分片模式](#分片模式)\n\t* [服务治理](#服务治理)\n\t\t* [服务注册与发现](#服务注册与发现)\n\t\t* [服务路由控制](#服务路由控制)\n\t* [分布式一致](#分布式一致)\n\t\t* [CAP 与 BASE 理论](#cap-与-base-理论)\n\t\t* [分布式锁](#分布式锁)\n\t\t* [分布式一致性算法](#分布式一致性算法)\n\t\t\t* [PAXOS](#paxos)\n\t\t\t* [Zab](#zab)\n\t\t\t* [Raft](#raft)\n\t\t\t* [Gossip](#gossip)\n\t\t\t* [两阶段提交、多阶段提交](#两阶段提交多阶段提交)\n\t\t* [幂等](#幂等)\n\t\t* [分布式一致方案](#分布式一致方案)\n\t\t* [分布式 Leader 节点选举](#分布式-leader-节点选举)\n\t\t* [TCC(Try/Confirm/Cancel) 柔性事务](#tcctryconfirmcancel-柔性事务)\n\t* [分布式文件系统](#分布式文件系统)\n\t* [唯一ID 生成](#唯一id-生成)\n\t\t* [全局唯一ID](#全局唯一id)\n\t* [一致性Hash算法](#一致性hash算法)\n* [设计思想 &amp; 开发模式](#设计思想--开发模式)\n\t* [DDD(Domain-driven Design - 领域驱动设计)](#ddddomain-driven-design---领域驱动设计)\n\t\t* [命令查询职责分离(CQRS)](#命令查询职责分离cqrs)\n\t\t* [贫血，充血模型](#贫血充血模型)\n\t* [Actor 模式](#actor-模式)\n\t* [响应式编程](#响应式编程)\n\t\t* [Reactor](#reactor)\n\t\t* [RxJava](#rxjava)\n\t\t* [Vert.x](#vertx)\n\t* [DODAF2.0](#dodaf20)\n\t* [Serverless](#serverless)\n\t* [Service Mesh](#service-mesh)\n* [项目管理](#项目管理)\n\t* [架构评审](#架构评审)\n\t* [重构](#重构)\n\t* [代码规范](#代码规范)\n\t* [代码 Review](#代码-review)\n\t* [RUP](#rup)\n\t* [看板管理](#看板管理)\n\t* [SCRUM](#scrum)\n\t* [敏捷开发](#敏捷开发)\n\t* [极限编程（XP）](#极限编程xp)\n\t* [结对编程](#结对编程)\n\t* [PDCA 循环质量管理](#pdca-循环质量管理)\n\t* [FMEA管理模式](#fmea管理模式)\n* [通用业务术语](#通用业务术语)\n* [技术趋势](#技术趋势)\n* [政策、法规](#政策法规)\n\t* [法律](#法律)\n\t\t* [严格遵守刑法253法条](#严格遵守刑法253法条)\n* [架构师素质](#架构师素质)\n* [团队管理](#团队管理)\n\t* [招聘](#招聘)\n* [资讯](#资讯)\n\t* [行业资讯](#行业资讯)\n\t* [公众号列表](#公众号列表)\n\t* [博客](#博客)\n\t\t* [团队博客](#团队博客)\n\t\t* [个人博客](#个人博客)\n\t* [综合门户、社区](#综合门户社区)\n\t* [问答、讨论类社区](#问答讨论类社区)\n\t* [行业数据分析](#行业数据分析)\n\t* [专项网站](#专项网站)\n\t* [其他类](#其他类)\n\t* [推荐参考书](#推荐参考书)\n\t\t* [在线电子书](#在线电子书)\n\t\t* [纸质书](#纸质书)\n\t\t\t* [开发方面](#开发方面)\n\t\t\t* [架构方面](#架构方面)\n\t\t\t* [技术管理方面](#技术管理方面)\n\t\t\t* [基础理论](#基础理论-1)\n\t\t\t* [工具方面](#工具方面)\n\t\t\t* [大数据方面](#大数据方面)\n* [技术资源](#技术资源)\n\t* [开源资源](#开源资源)\n\t* [手册、文档、教程](#手册文档教程)\n\t* [在线课堂](#在线课堂)\n\t* [会议、活动](#会议活动)\n\t* [常用APP](#常用app)\n\t* [找工作](#找工作)\n\t* [工具](#工具)\n\t* [代码托管](#代码托管)\n\t* [文件服务](#文件服务)\n\t* [综合云服务商](#综合云服务商)\n\t\t* [VPS](#vps)\n\t\n\n**（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）**\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B-，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)\n\t* 一侧比另外一次都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](http://www.importnew.com/18459.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](http://www.importnew.com/20472.html)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n* [《设计模式类图与示例》](https://github.com/ToryZhou/design-pattern)\n\n## 应用场景\n* [《细数JDK里的设计模式》](http://blog.jobbole.com/62314/)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://blog.csdn.net/yanquan345/article/details/19760027)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt-mobile-analytics-practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](https://www.testwo.com/article/1170)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。   \n* [agentzh 的 Nginx 教程](https://openresty.org/download/agentzh-nginx-tutorials-zhcn.html)  \n\t\n### Tengine\n* [官方网站](http://tengine.taobao.org/)  \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Spring。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](http://www.admin10000.com/document/5372.html)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObject 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](http://blog.it2048.cn/article_hash-collision.html )\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n\n* [CAS单点登录框架](https://github.com/apereo/cas)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Spring、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\nTODO\n## 法律\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.tom.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [InfoQ](http://www.infoq.com/cn/)\n\t\t* 偏重于基础架构、运维方向\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BfL5CR)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=rTlo0m)\n* 《架构之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=1KECBZ) \n* 《分布式服务架构》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=hkzqtK) \n* 《聊聊架构》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=A8Nd6Z) \n* 《云原生应用架构实践》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=D4WCpd) \n* 《亿级流量网站架构核心技术》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Rdmd21)\n* 《淘宝技术这十年》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=CoUdGG)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BxS6eI) \n\n* 《高可用架构（第1卷）》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=BcjUwS) \n\n#### 技术管理方面\n* 《CTO说》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=Gl3QAo) \n* 《技术管理之巅》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=MeloLt)\n* 《网易一千零一夜：互联网产品项目管理实战》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=qPuqMg) \n\n#### 基础理论\n* 《数学之美》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=0seUpO) \n* 《编程珠玑》[详情](https://www.coderxing.com/r.php?r=https://union-click.jd.com/jdc?d=I7jj9r) \n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n* [DigitalOcean](https://www.digitalocean.com)\n* [Vultr](https://www.vultr.com/)\n\n","tags":["学习资料"]},{"title":"Python小实践   微博爬虫之数据分析","url":"/post/Python学习笔记/python 词云/index.html  2018/06/20/Python学习笔记/python 词云/","content":"# python 词云\n## 1. 前期准备\n### 1.1 下载相关库\n* jieba (用于分词)\n* matplotlib\n* wordcloud\n`注意事项:`\n如果相关库安装失败,请到[https://www.lfd.uci.edu/~gohlke/pythonlibs/](https://www.lfd.uci.edu/~gohlke/pythonlibs/)下载相应包手动安装,注意python版本号与操作系统位数,如下图,例如python3.6,64位操作系统则选择`cp36-win_amd64.whl`文件下载\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180905/6Ch55mcee6.png?imageslim)\n### 使用命令行安装相关库\n```powershell\npip install 包名或本地包路径\n```\n## 2. wordcloud\n>wordcloud基于Python的词云生成类库,很好用,而且功能强大\n[Github](https://github.com/amueller/word_cloud )\n[官方文档](https://amueller.github.io/word_cloud)\n[参考博文](https://blog.csdn.net/fly910905/article/details/77763086)\n## 3. 小试牛刀\n```python\n# coding: utf-8\n\nimport json\n\nimport jieba.analyse\nimport matplotlib as mpl\nfrom scipy.misc import imread\nfrom wordcloud import WordCloud\n\n# mpl.use('TkAgg')\nimport matplotlib.pyplot as plt\n\n\ndef keywords(mblogs):\n    text = []\n    for blog in mblogs:\n        keyword = jieba.analyse.extract_tags(blog['text'])\n        text.extend(keyword)\n    return text\n\n\ndef gen_img(texts, img_file):\n    data = ' '.join(text for text in texts)\n    image_coloring = imread(img_file)\n    wc = WordCloud(\n        background_color='white',\n        mask=image_coloring,\n        max_font_size=500,  # 设置字体最大值\n        font_path='Fonts/HYC6GFM.TTF',\n        random_state = 30  # 设置有多少种随机生成状态，即有多少种配色方案\n    )\n    wc.generate(data)\n    # plt.figure()\n    # plt.imshow(wc, interpolation=\"bilinear\")\n    # plt.axis(\"off\")\n    # plt.show()\n\n    wc.to_file(img_file.split('.')[0] + '_wc.png')\n\n\nif __name__ == '__main__':\n    keyword = 'shida'\n    mblogs = json.loads(open('result_{}.json'.format(keyword), 'r', encoding='utf-8').read())\n    print('微博总数：', len(mblogs))\n\n    words = []\n    for blog in mblogs:\n        words.extend(jieba.analyse.extract_tags(blog['text']))\n\n    print(\"总词数：\", len(words))\n    print(words)\n    gen_img(words, 'love.jpg')\n\n\n```\n效果图\n\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180905/EhLH9dKA6g.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180905/02i70841eb.png?imageslim)","tags":["Python"]},{"title":"Python小实践   下载漫画","url":"/post/Python学习笔记/爬取前准备/index.html  2018/06/12/Python学习笔记/爬取前准备/","content":"\n# 爬取前准备\n[GitHub项目](https://github.com/lovemefan/python_tools)\n目标网站:[http://www.omanhua.com/comic/17521/](http://www.omanhua.com/comic/17521/)\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/jm0j3bkaiB.png?imageslim)\n## 分析网页\n```html\n<div class=\"subBookList\">\n<ul>\n    <li>\n        <a href='/comic/17521/366691/' title='332' target='_blank' class='new'>332</a>\n    </li>\n    <li>\n        <a href='/comic/17521/364901/' title='331' target='_blank' class='new'>331</a>\n    </li>\n    <li>\n        <a href='/comic/17521/364900/' title='腾讯动漫6周年福利活动！' target='_blank' class='new'>腾讯动漫6周年福利活动！</a>\n    </li>\n    <li>\n        <a href='/comic/17521/364899/' title='330。他们也是我们' target='_blank' class='new'>330。他们也是我们</a>\n    </li>\n    <li>\n    <a href='/comic/17521/364730/' title='329' target='_blank' class='new'>329</a>\n    </li>\n\t...\n</ul>\n```\n这里很明显 每个&lta&gt标签的href属性的值就是具体每一话的url\n先点进一话的页面看看\n[http://www.omanhua.com/comic/17521/366691/](http://www.omanhua.com/comic/17521/366691/)\n## 抓包分析\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/aJDLmKLIc8.png?imageslim)\n哈哈,没错这个,这是当前显示的一张漫画.但是只有一张.再看看下一张\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/iij3m7cKh7.png?imageslim)\n对比URL路径,我特么..,没有丝毫规律,陷入了僵局...,于是没有了后文.\n\n我就像看个漫画嘛,要不是腾讯收费,我&*%^*&%.\n但我还没有放弃,我打算看看js代码里有没有请求什么的痕迹\n就在我垂头顿足的时候,我发现了再网页里的一段神奇的代码\n```html\n<script type=\"text/javascript\">  var pVars = pVars || {}; var uzmh = uzmh || {};eval(function(p,a,c,k,e,d)\n{\n\te=function(c){return(c\n    <a?\"\":e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};\n\tif(!''.replace(/^/,String)){while(c--)d[e(c)]=k[c]||e(c);k=[function(e){return d[e]}];\n\t\te=function(){return'\\\\w+'};c=1;};\n\twhile(c--)\n\t\tif(k[c])p=p.replace(new RegExp('\\\\b'+e(c)+'\\\\b','g'),k[c]);\n\treturn p;\n}('h i={\"g\":1,\"e\":\"4\",\"f\":\"1.0\",\"m\":\"/n/1/2/l.j\",\"k\":2,\"6\":\"3\",\"7\":[\"8.0\",\"c.0\",\"5.0\",\"b.0\",\"9.0\",\"a.0\",\"d.0\",\"o.0\",\"D.0\",\"E.0\",\"C.0\",\"A.0\",\"B.0\",\"I.0\",\"J.0\",\"H.0\",\"F.0\",\"G.0\",\"z.0\",\"s.0\",\"t.0\",\"r.0\"],\"p\":q,\"x\":y,\"w\":\"/u/v/4/3/\"}||{};\n',46,46,'jpg|17521|366691|332|一人之下|388594b38e|cname|files|38ba1443ba|38f89724c3|381bce4fb2|3886aef5b2|38b823d13d|3857d21ce5|bname|bpic|bid|var|cInfo|html|cid|index|burl|comic|38779d6852|finished|false|3971856aff|399a8af80e|39cc4b3915|tu|undefined|path|len|22|39f92a9dae|387ed1275c|38e5f2512a|385573db27|387ab75347|3866af1df0|38d7d1fc53|382c0123f1|386a165c3e|3859ad824b|38e85b3b5a'.split('|'),0,{}))\n\n</script>\n```\n## 小有成就\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/G5L5cHjgFf.png?imageslim)\n通过一比对\n哇!!!我抑制不住内心的激动,这不就是图片名吗?\n以上代码为例,包含了漫画编号(17521),漫画集数编号(36691),漫画集数(332),漫画名(一人之下),当前集的漫画图片数(len=22),以及每张图片的文件名(比如38ba1443ba.jpg)\n大功告成!!!\n# 爬取图片\n## 思路\n有之前准备已经可以再页面上得到每一话的URL,每一话中的图片URL,剩下的就是对页面里的数据提取,分别下载了\n## python 代码\n```python\n# -*- codeing: utf-8 -*-\n# @Time:2018/3/13 22:20\n# @Author:lovemefan\n# @File:一人之下漫画爬虫.py\n# @Software:PyCharm\nimport os\nfrom imp import reload\nimport re\nimport requests as requests\nfrom urllib.request import urlretrieve\n\nrequestSession = requests.session()\n# 保存一张图片\n# 输入参数imgUrl 图片路径,imgPath 保存路径\ndef savePicture(imgUrl, imgPath):\n    response = requests.get(imgUrl)\n    codimg = response.content\n    fn = open(imgPath, 'wb')\n    fn.write(codimg)\n    fn.close()\n\n# 一人之下的漫画路径\nurl = \"http://www.omanhua.com/comic/17521/\"\nhtml = requests.get(url)\nhtml.encoding = 'UTF-8'\n# print(html.text)\n# 先获取每一话\n# 先将数据块取出\nbookListBlock = re.findall(r'<div class=\"subBookList\">(.*?)</div></div>', html.text, re.S)\n# booklist 为每一话的URL的列表\nbookList = re.findall(\"</a></li><li><a href='(.*?)' title='(.*?)'\", bookListBlock[0],re.S)\n\n# 逐话操作\nfor index in bookList:\n    indexUrl = \"http://www.omanhua.com/\"+index[0]+'index.html'\n    indexHtml = requests.get(indexUrl)\n    indexHtml.encoding = 'UTF-8'\n    print(indexHtml.url)\n    # 获得当前话的每张图片路径\n    picList = re.findall(\"一人之下\\|(.*?)'\\.\", indexHtml.text)[0].split('|')\n    #删去piclist无用的信息\n    for item in picList[:]:\n        if item.__len__() != 10:\n            picList.remove(item)\n\n    print(index[1]+'共有%d页'%picList.__len__())\n    picUrlRoot = u'http://pic.fxdm.cc/tu/undefined/一人之下/'\n    # 指定存储位置\n    location = \"J:/一人之下\"\n    # 分开放图片\n    # for page in range(len(picList)):\n    #     if not os.path.exists(\"%s/%s/\"%(location,index[1])):\n    #         os.makedirs(\"%s/%s/\"%(location,index[1]))\n    #     picUrl = picUrlRoot+ index[1]+'/'+picList[page]+'.jpg'\n    #     path = \"%s/%s/%d.jpg\"%(location,index[1],page)\n    #     picUrl.encode('UTF-8')\n    #     #不下载已经下载过的图片,便于更新\n    #     if not os.path.exists(path):\n    #         savePicture(picUrl,path)\n    #         print(picUrl + ' 保存到了 ' + path)\n    #\n\n    # 一起放图片\n    if not os.path.exists(location):\n        os.makedirs(location)\n    for page in range(len(picList)):\n        picUrl = picUrlRoot+ index[1]+'/'+picList[page]+'.jpg'\n        path = \"%s/%s_%d.jpg\"%(location,index[1],page)\n        picUrl.encode('UTF-8')\n        # 不下载已经下载过的图片,便于更新\n        if not os.path.exists(path):\n            savePicture(picUrl,path)\n            print(picUrl + ' 保存到了 ' + path)\n\n\n\n```\n如果想要图片分开放,取消掉注释的代码,注释掉后面一段代码\n\n## 结果\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/idJgkeGKgi.png?imageslim)\n### 分开放\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/8iDf2611JC.png?imageslim)\n### 一起放\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180612/J4gh2Gb514.png?imageslim)\n\n我要去看漫画了,不要打扰我(/≧▽≦)/~┴┴ \n\n## [`源码在这`](https://github.com/lovemefan/python_tools/blob/master/%E6%BC%AB%E7%94%BB/%E4%B8%80%E4%BA%BA%E4%B9%8B%E4%B8%8B%E6%BC%AB%E7%94%BB%E7%88%AC%E8%99%AB.py)\n\n\n","tags":["Python"]},{"title":"Python小实践   微博爬虫","url":"/post/Python学习笔记/抓取女神微博动态并保存到数据库/index.html  2018/05/28/Python学习笔记/抓取女神微博动态并保存到数据库/","content":"\n# 抓取女神微博动态并保存到数据库\n\n偶少有刷微博,常常错过女神的动态.微博客户端也常常不给我推送动态,于是我想自己给自己推送,而且还想把数据保存到自己的数据库里,于是有了接下来的尝试\n## 使用chrome浏览器抓包\n这里随便用什么软件都可以,目的只是抓包.本人使用chrome抓包\n按下F12,查看这两个getindex的数据包\n需要获得两个参数`uid`和`containerid`\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180528/7HhB9BliF2.png?imageslim)\t\n这里需要通过手机版weibo http://m.weibo.com来进行模拟请求，不是通过分析html代码再通过筛选来完成数据抓取。\n笔者先用postmen软件模拟一次post请求,返回结果如下\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180528/8c54K4H2E1.png?imageslim)\n返回的是json数据,接下来就是处理数据了\n## 模拟请求\n以下是python模拟的post请求\n``` python\nimport requests\nimport json\nimport pymysql\ncursor = db.cursor()\nurl=\"https://m.weibo.cn/api/container/getIndex\"\nfor k in range(10):\n    # 用户的uid,containerid,以及页数.每页最多为十条记录\n    payload={'type':'uid','value':'56xxxxxx00','containerid':'1076xxxxxxxx5400','page': '%d'%page}\n    r=requests.post(url,data=payload)\n    raw_text=r.text\n    d=json.loads(raw_text)\n``` \n由于每页只有最新的十条记录,所以需要把每一页的数据都存起来\n\n## 数据库建表\n笔者选择了一些基本信息存储,并没有保存评论信息.其中包括\n* itemid 每条微博的ID\n* scheme 每条微博的跳转链接(方便查看)\n* id 也是用于表示每条微博的ID,具体与itemid的区别笔者未深究\n* created_at 发微博的时间,精确到天\n* text 微博内容\n* source 微博来源,比如手机型号\n* user_id 发微博的用户ID \n``` sql\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for mblog\n-- ----------------------------\nDROP TABLE IF EXISTS `mblog`;\nCREATE TABLE `mblog` (\n  `itemid` varchar(40) NOT NULL,\n  `scheme` varchar(100) DEFAULT NULL,\n  `id` varchar(20) DEFAULT NULL,\n  `created_at` varchar(10) DEFAULT NULL,\n  `text` text,\n  `source` varchar(20) DEFAULT NULL,\n  `user_id` varchar(20) DEFAULT NULL,\n  PRIMARY KEY (`itemid`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n  \n```\n## 分析数据并插入表中\n这里直接贴代码了,代码有详细注释\n```python\n# -*- codeing: utf-8 -*-\n# @Time:2018/5/28 14:31\n# @Author:lovemefan\n# @File:抓取女神微博动态保存到数据库.py\n# @Software:PyCharm\n#\n#原始URL:https://m.weibo.cn/p/100xxxxxxxx15400\nimport requests\nimport json\nimport pymysql\n# 打开数据库连接\ndb = pymysql.connect(\"localhost\", \"账号\", \"密码\", \"数据库名\", charset='utf8')\n# 使用cursor()方法获取操作游标\ncursor = db.cursor()\nurl=\"https://m.weibo.cn/api/container/getIndex\"\npage = 1\nsum = 0\nfor k in range(35):\n    # 用户的uid,containerid,以及页数.每页最多为十条记录\n    payload={'type':'uid','value':'56xxxxxx00','containerid':'10760xxxxxxxx400','page': '%d'%page}\n    r=requests.post(url,data=payload)\n    raw_text=r.text\n    d=json.loads(raw_text)\n    try:\n        for i in range(10):\n            print(\"第%d页第%d条\"% (page,i))\n            print(d[\"data\"][\"cards\"])\n            itemid = str(d[\"data\"][\"cards\"][i][\"itemid\"])\n            scheme = str(d[\"data\"][\"cards\"][i][\"scheme\"])\n            id = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"id\"])\n            create_at = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"created_at\"])\n            #将内容中的单引号换成双引号,否则插入数据库中会报错\n            text = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"text\"]).replace(\"'\",\"\\\"\")\n            source = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"source\"])\n            user_id = str(d[\"data\"][\"cards\"][i][\"mblog\"][\"user\"][\"id\"])\n            # sql插入语句\n            sql = \"insert ignore into mblog(itemid,scheme,id,created_at,text,source,user_id) VALUES('%s','%s','%s','%s','%s','%s','%s')\" % (itemid,scheme,id,create_at,text,source,user_id)\n            print(sql)\n            # 执行sql语句\n            cursor.execute(sql)\n            # 执行sql语句\n            db.commit()\n            sum = sum + 1\n    except IndexError:\n        # 但记录不满10条的时候,捕获list越界异常,自动跳过\n        pass\n\n    page = page + 1\n    print(\"第%d页执行成功\"%page)\n        # print([\"text\"])\ndb.close()\nprint(\"一共插入了%d的条记录\"% sum)\n```\n## 结果\n![mark](http://oskhhyaq3.bkt.clouddn.com/img/180528/ICjHHa2I31.png?imageslim)\n保存成功,然后就可以去翻数据库里的数据了.\n## 缺陷\n* 只能一次性的保存至今的记录,后续添加监听并邮箱推送\n* 后续可以添加数据分析,关键子词云","tags":["Python"]},{"title":"Android学习笔记 (三)   MP3播放器","url":"/post/Android/MP3播放器/index.html  2017/11/12/Android/MP3播放器/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n 利用Intent 唤醒其他Activity或其他APP\n<!-- more -->\n<The rest of contents | 余下全文>\n# MP3播放器\n整个音乐播放器设计模仿网易云音乐风格\n工程源代码已上传至Github: [源码下载](https://github.com/lovemefan/MP3Player)\n\n**实现的功能**:\n* **1.**暂停,开始音乐,后台播放\n* **2.**进度条可拖动,能实现音乐跳转\n* **3.**能够循环切换上一曲和下一曲\n* **4.**播放完毕后自动下一曲\n* **5.**歌曲封面有旋转的动画\n* **6.**背景图片毛玻璃美化\n\n**待实现的功能**\n* 音乐列表\n* 本地音乐读取播放\n* 网络音乐播放\n\n## Music.java设计\n要播放多首音乐,首先设计一个音乐类用于存放歌曲信息,如歌曲名,封面图片的ID,音乐文件的ID\n`Music.java`\n```java\npackage com.lovemefan.mp3player;\n\nimport android.os.Bundle;\nimport android.os.Parcel;\nimport android.os.Parcelable;\n\n\n/**\n * Created by Lovemefan on 2017/11/7.\n */\n\npublic class Music implements Parcelable{\n    private String name;//歌曲名\n    private int coverId;//封面的ID\n    private int resourceId;//资源路径ID\n    public Music(String name, int coverId, int resourceId) {\n        this.name = name;\n        this.coverId = coverId;\n        this.resourceId = resourceId;\n    }\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getCoverId() {\n        return coverId;\n    }\n\n    public void setCoverId(int coverId) {\n        this.coverId = coverId;\n    }\n\n    public int getResourceId() {\n        return resourceId;\n    }\n\n    public void setResourceId(int resourceId) {\n        this.resourceId = resourceId;\n    }\n\n    @Override\n    public int describeContents() {\n        return 0;\n    }\n\n//    实现接口Parcelable需要重写下面两个方法\n    @Override\n    public void writeToParcel(Parcel parcel, int i) {\n        parcel.writeString(getName());\n        Bundle bundle = new Bundle();\n        bundle.putInt(\"coverId\",getCoverId());\n        bundle.putInt(\"resourceId\",getResourceId());\n        parcel.writeBundle(bundle);\n    }//将成员变量一一写入Parcel中\n    public static final Creator<Music> CREATOR = new Creator<Music>() {\n        @Override\n        public Music createFromParcel(Parcel parcel) {\n            Bundle bundle = parcel.readBundle();\n            return new Music(parcel.readString(), bundle.getInt(\"coverId\"), bundle.getInt(\"resourceId\"));\n        }\n\n        @Override\n        public Music[] newArray(int i) {\n            return new Music[i];\n        }\n    };\n}\n```\n## 后台服务类\n为了让音乐能够在app后台运行,就要设计一个Service.\n`MusicPlayService.java`\n```java\npackage com.lovemefan.mp3player;\n\nimport android.app.Service;\nimport android.content.Intent;\nimport android.media.MediaPlayer;\nimport android.os.Binder;\nimport android.os.IBinder;\n\nimport java.util.ArrayList;\n\npublic class MusicPlayService extends Service {\n    private MediaPlayer mediaPlayer = null;\n    public MusicPlayService() {\n    }\n    class MyBinder extends Binder{\n        public MediaPlayer getMediaPlayer(){\n            return mediaPlayer;\n        }\n    }\n    @Override\n    public IBinder onBind(Intent intent) {\n        // TODO: Return the communication channel to the service.\n        return new MyBinder();\n    }\n    @Override\n    public void onCreate() {\n        mediaPlayer = MediaPlayer.create(this,R.raw.aimer_ninelie);//设置初始值\n//        mediaPlayer.start();\n        super.onCreate();\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n    }\n}\n```\n##  MainActivity.java\n由MainActivity绑定MusicPlayService服务,让音乐在服务中运行.另外还要创建一个线程来更新进度条和当前时间.\n`MainActivity.java`\n```java\npackage com.lovemefan.mp3player;\n\nimport android.content.ComponentName;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.ServiceConnection;\nimport android.content.res.AssetFileDescriptor;\nimport android.content.res.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.graphics.drawable.BitmapDrawable;\nimport android.media.AudioAttributes;\nimport android.media.MediaPlayer;\nimport android.os.Build;\nimport android.os.Handler;\nimport android.os.IBinder;\nimport android.os.Message;\nimport android.support.annotation.RequiresApi;\nimport android.support.v7.app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.view.animation.Animation;\nimport android.view.animation.AnimationUtils;\nimport android.view.animation.LinearInterpolator;\nimport android.view.animation.RotateAnimation;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.ProgressBar;\nimport android.widget.SeekBar;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n\npublic class MainActivity extends AppCompatActivity implements ServiceConnection {\n    ArrayList<Music> musics = new ArrayList<>();\n    MediaPlayer mediaPlayer;//媒体播放器\n    ImageView playButton;//播放按钮\n    SeekBar progressBar ;//进度条\n    TextView title;//标题,用于显示歌名\n    TextView currentTime;//显示当前播放的时间\n    TextView duration;//显示歌曲时长\n    Handler handler ;//用于其他线程更新\n    CircleImageView cover;//显示歌曲的封面\n    LinearLayout root;//根面板\n    int musicProcess=0;//歌曲的进度;\n    int musicCurIndex = 0;//当前播放的歌曲的下标\n    Animation rotateAnimation ;\n\n    //用于handle的handleMessage处理不同的事件\n    static final int UpdateCurrentTime=0;//刷新当前播放时间标识符\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        supportRequestWindowFeature(Window.FEATURE_NO_TITLE);;//去掉标题栏\n        this.getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);//去掉信息栏\n        setContentView(R.layout.activity_main);\n        activityInit();//相关控件初始化\n        bindService(new Intent(MainActivity.this,MusicPlayService.class), MainActivity.this, Context.BIND_AUTO_CREATE);//绑定服务\n\n        musics.add(new Music(\"ninelie\",R.drawable.nineliecover,R.raw.aimer_ninelie));\n        musics.add(new Music(\"像风一样\",R.drawable.linkwinds,R.raw.like_winds));\n        musics.add(new Music(\"Let It Out\",R.drawable.let_it_out,R.raw.let_it_out));\n        refreshMusicInfo(musics.get(0));\n        //\n        progressBar.setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {\n            @Override\n            public void onProgressChanged(SeekBar seekBar, int i, boolean b) {\n                musicProcess = i;\n                //自动播放下一曲\n                if(mediaPlayer.getDuration() - musicProcess < 500){\n                    musicCurIndex = (musicCurIndex + 1) % musics.size();\n                    refreshMusicInfo(musics.get(musicCurIndex));\n                    play();//播放音乐\n                }\n            }\n\n            @Override\n            public void onStartTrackingTouch(SeekBar seekBar) {\n\n            }\n\n            @Override\n            public void onStopTrackingTouch(SeekBar seekBar) {\n                mediaPlayer.seekTo(musicProcess);//跳转到\n            }\n        });\n\n        handler = new Handler(new Handler.Callback(){\n        @Override\n        public boolean handleMessage(Message message) {\n            switch (message.what){\n                case UpdateCurrentTime:currentTime.setText(secondsToMinutes(mediaPlayer.getCurrentPosition()));break;\n            }\n            return true;\n        }\n        });\n        findViewById(R.id.playButton).setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                play();\n            }\n        });\n\n    }\n    public void activityInit(){\n        playButton = (ImageView) findViewById(R.id.playButton);\n        progressBar = ( SeekBar) this.findViewById(R.id.progressBar);\n        currentTime = (TextView) findViewById(R.id.curTime);\n        duration = (TextView) findViewById(R.id.duration);\n        title = (TextView) findViewById(R.id.musicName);\n        cover = (CircleImageView) findViewById(R.id.musicCover);\n        root = (LinearLayout) findViewById(R.id.root);\n        rotateAnimation =  AnimationUtils.loadAnimation(this,R.anim.rotation);\n        rotateAnimation.setFillEnabled(true);\n        rotateAnimation.setFillAfter(true);\n        rotateAnimation.setInterpolator(new LinearInterpolator());\n\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        unbindService(MainActivity.this);\n    }\n\n    @Override\n    public void onServiceConnected(ComponentName componentName, IBinder iBinder) {\n        System.out.println(\"绑定成功\");\n        mediaPlayer = ((MusicPlayService.MyBinder)iBinder).getMediaPlayer();\n        progressBar.setMax(mediaPlayer.getDuration());//设置进度条\n        duration.setText(\"\"+secondsToMinutes(mediaPlayer.getDuration()));\n        currentTime.setText(\"00:00\");\n        System.out.println(mediaPlayer.getDuration());\n\n    }\n\n    @Override\n    public void onServiceDisconnected(ComponentName componentName) {\n\n    }\n    public String secondsToMinutes(int seconds){\n        int minute = seconds/60000;\n        int second = (seconds/1000)%60;\n        String  m = \"\"+ minute;\n        String  s = \"\" + second;\n        if (minute<10){\n            m = \"0\" + minute;\n        }\n        if(second<10){\n           s = \"0\" + second;\n        }\n        return m + \":\" + s;\n    }\n\n    public void play() {\n        if(mediaPlayer == null ){\n            System.out.println(\"mediaplayer初始化失败\");\n        }else{\n            if(mediaPlayer.isPlaying()){\n                mediaPlayer.pause();\n                cover.clearAnimation();\n                playButton.setImageResource(R.drawable.play);\n            }else{\n                mediaPlayer.start();\n\n                cover.startAnimation(rotateAnimation);\n                playButton.setImageResource(R.drawable.pause);\n            }\n            System.out.println(mediaPlayer.isPlaying());\n            new MyThread().start();\n        }\n    }\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    public void refreshMusicInfo(Music curMusic){\n        title.setText(curMusic.getName());//设置歌曲名\n        //        获取需要被模糊的原图bitmap\n        Resources res = getResources();\n        Bitmap scaledBitmap = BitmapFactory.decodeResource(res, curMusic.getCoverId());\n        //        scaledBitmap为目标图像，25是缩放的倍数（越大模糊效果越高）\n        Bitmap blurBitmap = BlurImage.toBlur(scaledBitmap, 50);\n        root.setBackground(new BitmapDrawable(blurBitmap));//设置根面板背景\n        cover.setImageResource(curMusic.getCoverId());//设置封面\n        if(mediaPlayer == null){\n            System.out.println(\"mediaplayer初始化失败\");\n        }else{\n            try {\n                AssetFileDescriptor afd = this.getResources().openRawResourceFd(curMusic.getResourceId());\n                if (afd == null) {\n                    Toast.makeText(this,\"音乐打开失败\",Toast.LENGTH_SHORT).show();\n                }else{\n                    mediaPlayer.stop();\n                    final AudioAttributes aa = new AudioAttributes.Builder().build();\n                    mediaPlayer.setAudioAttributes(aa);\n                    mediaPlayer.setAudioSessionId(mediaPlayer.getAudioSessionId() + 1);\n                    mediaPlayer.setDataSource(afd.getFileDescriptor(), afd.getStartOffset(), afd.getLength());//设置音乐源\n                    afd.close();//关闭文件\n                    mediaPlayer.prepare();//音乐准备\n                }\n            } catch (IOException e) {\n                Toast.makeText(this,\"音乐播放失败\",Toast.LENGTH_SHORT).show();\n            }\n                currentTime.setText(\"00:00\");//设置开始时间\n                duration.setText(secondsToMinutes(mediaPlayer.getDuration()));//获取音乐时长,并设置时间\n                progressBar.setProgress(0);//将播放进度条清零\n                playButton.setImageResource(R.drawable.play);//重新将按钮设置为播放\n            }\n        }\n\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    public void previouMusic(View view) {\n        //可实现循环切换\n        musicCurIndex = (musicCurIndex + musics.size() -1) % musics.size() ;//加上music.size()防止出现负数\n        refreshMusicInfo(musics.get(musicCurIndex));\n        play();\n    }\n\n    @RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)\n    public void nextMusic(View view) {\n        //可实现循环切换\n        musicCurIndex = (musicCurIndex + 1) % musics.size();\n        refreshMusicInfo(musics.get(musicCurIndex));\n        play();\n    }\n\n    class MyThread extends Thread{\n        public  void run(){\n            while(mediaPlayer.isPlaying()){\n                progressBar.setMax(mediaPlayer.getDuration());\n                progressBar.setProgress(mediaPlayer.getCurrentPosition());\n                handler.sendMessage(Message.obtain());\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n}\n```\n## 界面设计\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.lovemefan.mp3player.MainActivity\">\n\n    <LinearLayout\n        android:id=\"@+id/root\"\n        android:layout_width=\"fill_parent\"\n        android:layout_height=\"fill_parent\"\n        android:orientation=\"vertical\"\n        >\n\n        <LinearLayout\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"0dp\"\n            android:layout_weight=\"1\"\n            android:alpha=\"0.4\"\n            android:background=\"#3c3c3c\"\n            android:orientation=\"horizontal\">\n\n            <TextView\n                android:id=\"@+id/musicName\"\n                android:layout_width=\"wrap_content\"\n                android:layout_height=\"wrap_content\"\n                android:layout_weight=\"1\"\n                android:textAlignment=\"center\"\n                android:textColorHighlight=\"@color/colorAccent\"\n                android:textStyle=\"bold\"\n                android:textColor=\"#fff\"\n                android:textSize=\"18pt\" />\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/centerArea\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"0dp\"\n            android:layout_weight=\"7.5\"\n            android:orientation=\"vertical\">\n\n            <RelativeLayout\n                android:layout_width=\"fill_parent\"\n                android:layout_height=\"fill_parent\"\n                android:layout_marginBottom=\"20dp\">\n\n                <ImageView\n                    android:layout_width=\"wrap_content\"\n                    android:layout_height=\"wrap_content\"\n                    android:layout_centerHorizontal=\"true\"\n                    android:layout_centerInParent=\"true\"\n                    android:layout_centerVertical=\"true\"\n                    android:src=\"@drawable/record\" />\n\n                <com.lovemefan.mp3player.CircleImageView xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n                    android:id=\"@+id/musicCover\"\n                    android:layout_width=\"225dp\"\n                    android:layout_height=\"225dp\"\n                    android:src=\"@drawable/nineliecover\"\n                    app:civ_border_color=\"#3c3c3c\"\n                    app:civ_border_width=\"2dp\"\n                    android:layout_centerHorizontal=\"true\"\n                    android:layout_centerInParent=\"true\"\n                    android:layout_centerVertical=\"true\"\n                    />\n            </RelativeLayout>\n\n            <LinearLayout\n                android:layout_width=\"match_parent\"\n                android:layout_height=\"20dp\"\n                android:layout_marginTop=\"-20dp\"\n                android:orientation=\"horizontal\">\n\n                <TextView\n                    android:id=\"@+id/curTime\"\n                    android:layout_width=\"0pt\"\n                    android:layout_height=\"match_parent\"\n                    android:textAlignment=\"center\"\n                    android:layout_weight=\"1.2\" />\n\n                <SeekBar\n                    android:id=\"@+id/progressBar\"\n                    style=\"?android:attr/progressBarStyleHorizontal\"\n                    android:layout_width=\"0dp\"\n                    android:layout_height=\"match_parent\"\n                    android:layout_weight=\"7.6\" />\n\n                <TextView\n                    android:id=\"@+id/duration\"\n                    android:layout_width=\"0dp\"\n                    android:layout_height=\"match_parent\"\n                    android:layout_weight=\"1.2\" />\n\n            </LinearLayout>\n\n\n        </LinearLayout>\n\n        <LinearLayout\n            android:id=\"@+id/playBar\"\n            android:layout_width=\"fill_parent\"\n            android:layout_height=\"0dp\"\n            android:layout_weight=\"1.5\"\n            android:alpha=\"0.4\"\n            android:background=\"#3c3c3c\"\n            android:orientation=\"horizontal\">\n\n            <ImageView\n                android:id=\"@+id/previouButton\"\n                android:layout_width=\"60dp\"\n                android:layout_height=\"60dp\"\n                android:layout_marginTop=\"10dp\"\n                android:layout_weight=\"2\"\n                android:onClick=\"previouMusic\"\n                app:srcCompat=\"@drawable/previous\" />\n\n            <ImageView\n                android:id=\"@+id/playButton\"\n                android:layout_width=\"60dp\"\n                android:layout_height=\"60dp\"\n                android:layout_marginTop=\"10dp\"\n                android:layout_weight=\"2\"\n                app:srcCompat=\"@drawable/play\" />\n\n            <ImageView\n                android:id=\"@+id/nextButton\"\n                android:layout_width=\"60dp\"\n                android:layout_height=\"60dp\"\n                android:layout_marginTop=\"10dp\"\n                android:layout_weight=\"2\"\n                android:onClick=\"nextMusic\"\n                app:srcCompat=\"@drawable/next\" />\n        </LinearLayout>\n\n    </LinearLayout>\n</android.support.constraint.ConstraintLayout>\n```\n\n## 界面效果\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/dlca6h3hAD.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/0GCA5kkBc2.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/hKd52055A0.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171116/jbaI2K4LC3.png?imageslim)","tags":["学习笔记"]},{"title":"Android学习笔记 (二)   Intent唤醒其他Activity或APP","url":"/post/Android/Android 如何唤醒第三方APP/index.html  2017/10/20/Android/Android 如何唤醒第三方APP/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n 利用Intent 唤醒其他Activity或其他APP\n<!-- more -->\n<The rest of contents | 余下全文>\n# Android 如何唤醒第三方APP\n## Intent类的通常用法\n### `1.启动 Activity：`\n\n>Activity 表示应用中的一个屏幕。通过将 Intent 传递给 startActivity()，您可以启动新的 Activity 实例。Intent 描述了要启动的 Activity，并携带了任何必要的数据。 \n如果您希望在 Activity 完成后收到结果，请调用 startActivityForResult()。在 Activity 的 onActivityResult() 回调中，您的 Activity 将结果作为单独的 Intent 对象接收。如需了解详细信息，请参阅 Activity 指南。\n\n### `2.启动服务：`\n\n>Service 是一个不使用用户界面而在后台执行操作的组件。通过将 Intent 传递给 startService()，您可以启动服务执行一次性操作（例如，下载文件）。Intent 描述了要启动的服务，并携带了任何必要的数据。 \n如果服务旨在使用客户端-服务器接口，则通过将 Intent 传递给 bindService()，您可以从其他组件绑定到此服务。如需了解详细信息，请参阅服务指南。\n\n### `3.传递广播：`\n\n>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 Intent 传递给 sendBroadcast()、sendOrderedBroadcast() 或 sendStickyBroadcast()，您可以将广播传递给其他应用。\n\n### `以下内容只讨论启动Activity`\n## Intent 启动Activity\n### 1.启动Activity\n`代码示例:`\n```java\n//调用系统默认浏览器打开百度\n    public void openBaidu(View view) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setData(Uri.parse(\"http://www.baidu.com\"));//设置url\n        startActivity(intent);\n    }\n    //调用系统电话,拨打10086.需要添加权限\n    public void openCall(View view) {\n        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) {\n            // TODO: Consider calling\n            //    ActivityCompat#requestPermissions\n            // here to request the missing permissions, and then overriding\n            //   public void onRequestPermissionsResult(int requestCode, String[] permissions,\n            //                                          int[] grantResults)\n            // to handle the case where the user grants the permission. See the documentation\n            // for ActivityCompat#requestPermissions for more details.\n            return;\n        }\n        startActivity(new Intent(Intent.ACTION_CALL, Uri.parse(\"tel:10086\")));\n    }\n    //调用系统信息应用\n    public void openSms(View view) {\n        Intent intent = new Intent(Intent.ACTION_VIEW);\n        intent.setType(\"vnd.android-dir/mms-sms\");\n        intent.putExtra(\"sms_body\",\"\"); //第二个参数为短信内容\n        startActivity(intent);\n    }\n    //打开QQ,uin=10000为打开qq10000的用户的聊天界面\n    public void openQQ(View view) {\n        EditText editText = (EditText)findViewById(R.id.editText);\n        startActivity(new Intent(Intent.ACTION_VIEW,Uri.parse(\"mqqwpa://im/chat?chat_type=wpa&uin=\"+ editText.getText()+\"&version=1\")));\n    }\n    //打开系统相机\n    public void openCamera(View view) {\n        startActivity(new Intent(\"android.media.action.STILL_IMAGE_CAMERA\"));\n    }\n    //打开微信\n    public void openWechat(View view) {\n        Intent intent = new Intent();\n        ComponentName cmp = new ComponentName(\"com.tencent.mm\",\"com.tencent.mm.ui.LauncherUI\");\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.setComponent(cmp);\n        startActivityForResult(intent, 0);\n\n\n    }\n    //打开新浪微博\n    public void openBlog(View view) {\n        Intent intent = new Intent();\n        ComponentName cmp = new ComponentName(\"com.sina.weibo\",\"com.sina.weibo.SplashActivity\");\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.setComponent(cmp);\n        startActivityForResult(intent, 0);\n    }\n```\n`以上代码主要用了两种方法设置将要跳转的Activity的信息,第一个是设置Uri,第二种是设置Component来实现跳转`\n### 2.启动APP\n对于第三方APP,笔者主要采用设置`Component`的方法\n\n\n在监听器或其他区域,输入以下代码\n\n```java\n\t\tIntent intent = new Intent();\n\t\t//ComponentName(String psk,String cls)\n\t\t//PKG的组件存在的包的名字。不能为空。CLS的PKG实现组件的内部类的名字。不能为空。\n        ComponentName cmp = new ComponentName(\"com.tencent.mm\",\"com.tencent.mm.ui.LauncherUI\");//启动微信\n        intent.setAction(Intent.ACTION_MAIN);\n        intent.addCategory(Intent.CATEGORY_LAUNCHER);\n        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);\n        intent.setComponent(cmp);\n        startActivityForResult(intent, 0);\n```\n\n## 一些安卓应用的pkg和cls\n`以下的APP都是根据笔者的当前手机的app导出得到的,所以只有部分常用的应用`\n导出App信息(pkg和cls)项目:[https://github.com/lovemefan/PackageMangerDemo](https://github.com/lovemefan/PackageMangerDemo) \n|应用|pkg |cls |\n|:--------|:----------:|:--------------:|\n|阿里云|com.alibaba.aliyun|com.alibaba.aliyun.biz.login.WelcomeActivity|\n|爱奇艺|com.qiyi.video|com.qiyi.video.WelcomeActivity|\n|百度贴吧|com.baidu.tieba|com.baidu.tieba.LogoActivity|\n|百度网盘|com.baidu.netdisk|com.baidu.netdisk.ui.Navigate|\n|备忘录|com.samsung.android.app.memo|com.samsung.android.app.memo.Main|\n|哔哩哔哩|tv.danmaku.bili|tv.danmaku.bili.ui.splash.SplashActivity|\n|车来了|com.ygkj.chelaile.standard|dev.xesam.chelaile.app.module.func.SplashActivity|\n|电话|com.android.contacts|com.android.dialer.DialtactsActivity|\n|电子邮件|com.samsung.android.email.provider|com.samsung.android.email.ui.activity.MessageListXL|\n|盖乐世空间|com.samsung.android.voc|com.samsung.android.voc.LauncherActivity|\n|高德地图|com.autonavi.minimap|com.autonavi.map.activity.SplashActivity|\n|高铁管家12306火车票|com.gtgj.view|com.gtgj.view.LaunchActivity|\n|黑域|me.piebridge.brevent|me.piebridge.brevent.ui.BreventActivity|\n|计算器|com.sec.android.app.popupcalculator|com.sec.android.app.popupcalculator.Calculator|\n|交管12123|com.tmri.app.main|com.tmri.app.ui.activity.TmriActivity|\n|京东|com.jingdong.app.mall|com.jingdong.app.mall.main.MainActivity|\n|联系人|com.android.contacts|com.android.contacts.activities.PeopleActivity|\n|猎吧出行|com.example.liabarcarandroid|com.liabarcar.guide.SplashActivity|\n|浏览器|com.sec.android.app.sbrowser|com.sec.android.app.sbrowser.SBrowserMainActivity|\n|录音机|com.sec.android.app.voicenote|com.sec.android.app.voicenote.main.VNMainActivity|\n|南昌航空大学|com.eteasun.nanhang|com.eteasun.nanhang.activity.WelcomeActvity|\n|全民K歌|com.tencent.karaoke|com.tencent.karaoke.module.splash.ui.SplashBaseActivity|\n|三星健康|com.sec.android.app.shealth|com.samsung.android.app.shealth.home.HomeMainActivity|\n|三星生活助手|com.samsung.android.app.sreminder|com.samsung.android.app.sreminder.phone.cardlist.SReminderActivity|\n|三星视频|com.samsung.android.onlinevideo|com.samsung.android.onlinevideo.list.activity.VideoList|\n|三星音乐|com.samsung.android.app.music.chn|com.samsung.android.app.music.common.activity.MusicMainActivity|\n|三星阅读|com.mci.smagazine|com.chaozh.iReader.ui.activity.WelcomeActivity|\n|三星云|com.samsung.multidevicecloud|com.kanbox.wp.Main|\n|扫描全能王|com.intsig.camscanner|com.intsig.camscanner.WelcomeActivity|\n|扇贝单词|com.shanbay.words|com.shanbay.words.startup.SplashActivity|\n|设置|com.android.settings|com.android.settings.Settings|\n|时钟|com.sec.android.app.clockpackage|com.sec.android.app.clockpackage.ClockPackage|\n|手机淘宝|com.taobao.taobao|com.taobao.tao.welcome.Welcome|\n|手机营业厅|com.sinovatech.unicom.ui|com.sinovatech.unicom.ui.WelcomeClient|\n|搜狐视频|com.sohu.sohuvideo|com.sohu.sohuvideo.FirstNavigationActivityGroup|\n|腾讯动漫|com.qq.ac.android|com.qq.ac.android.view.activity.SplashActivity|\n|腾讯课堂|com.tencent.edu|com.tencent.edu.module.SplashActivity|\n|腾讯视频|com.tencent.qqlive|com.tencent.qqlive.ona.activity.WelcomeActivity|\n|通卡宝|com.nci.tkb|com.nci.tkb.ui.SplashActivity|\n|网易有道词典|com.youdao.dict|com.youdao.dict.activity.DictSplashActivity|\n|网易云音乐|com.netease.cloudmusic|com.netease.cloudmusic.activity.LoadingActivity|\n|微博|com.sina.weibo|com.sina.weibo.SplashActivity|\n|微信|com.tencent.mm|com.tencent.mm.ui.LauncherUI|\n|我的文件|com.sec.android.app.myfiles|com.sec.android.app.myfiles.common.MainActivity|\n|闲鱼|com.taobao.idlefish|com.taobao.fleamarket.home.activity.InitActivity.Round|\n|相册|com.sec.android.gallery3d|com.sec.android.gallery3d.app.GalleryOpaqueActivity|\n|相机|com.sec.android.app.camera|com.sec.android.app.camera.Camera|\n|小米VR|com.mi.dlabs.vr.hulk|com.mi.dlabs.vr.hulk.launch.HulkLaunchActivity|\n|信息|com.android.mms|com.android.mms.ui.ConversationComposer|\n|一键锁屏|com.yujing.lockscreen|com.yujing.lockscreen.MainActivity|\n|应用商店|com.sec.android.app.samsungapps|com.sec.android.app.samsungapps.SamsungAppsMainActivity|\n|影梭|com.github.shadowsocks|com.github.shadowsocks.Shadowsocks|\n|优酷|com.youku.phone|com.youku.phone.ActivityWelcome|\n|悦动圈|com.yuedong.sport|com.yuedong.sport.main.WelcomeActivity_|\n|支付宝|com.eg.android.AlipayGphone|com.eg.android.AlipayGphone.AlipayLogin|\n|知乎|com.zhihu.android|com.zhihu.android.app.ui.activity.MainActivity|\n|智能管理器|com.samsung.android.sm|com.samsung.android.sm.app.dashboard.SmartManagerDashBoardActivity|\n|主题商店|com.samsung.android.themestore|com.samsung.android.themestore.activity.Launcher|\n|租八戒|com.rentpig.customer|com.rentpig.customer.main.WelcomeActivity|\n|AChm Free|com.pchen.achmfree|com.pchen.achm.MainActivity|\n|Chrome|com.android.chrome|com.google.android.apps.chrome.Main|\n|ES文件浏览器|com.estrongs.android.pop|com.estrongs.android.pop.app.openscreenad.NewSplashActivity|\n|Excel|com.microsoft.office.excel|com.microsoft.office.apphost.LaunchActivity|\n|Github|com.seasonfif.github|com.seasonfif.github.ui.activity.SplashScreenActivity|\n|IT之家|com.ruanmei.ithome|com.ruanmei.ithome.ui.MainActivity|\n|netkeeper|com.xinli.netkeeper|com.xinli.netkeeper.activitys.WelcomeActivity|\n|ofo共享单车|so.ofo.labofo|so.ofo.labofo.activities.EntryActivity|\n|QQ|com.tencent.mobileqq|com.tencent.mobileqq.activity.SplashActivity|\n|RD Client Beta|com.microsoft.rdc.android.beta|com.microsoft.rdc.ui.activities.HomeActivity|\n|S 换机助手|com.sec.android.easyMover|com.sec.android.easyMover.DistributionActivity|\n|S 日历|com.android.calendar|com.android.calendar.AllInOneActivity|\n|S Voice|com.samsung.voiceserviceplatform|com.samsung.voiceserviceplatform.ui.SVoiceMainActivity|\n|Samsung Gear|com.samsung.android.app.watchmanager|com.samsung.android.app.watchmanager.setupwizard.SetupWizardWelcomeActivity|\n|Super Pads|com.opalastudios.pads|com.opalastudios.pads.ui.MainActivity|\n|Survival Online|com.gameline.survivalcraftfree|com.unity3d.player.UnityPlayerActivity|\n|TapTap|com.taptap|com.play.taptap.ui.MainAct|\n|UC浏览器|com.UCMobile|com.UCMobile.main.UCMobile|\n|USIM卡应用|com.android.stk|com.android.stk.StkLauncherActivity|\n|WiFi万能钥匙|com.snda.wifilocating|com.lantern.launcher.ui.MainActivity|\n|Word|com.microsoft.office.word|com.microsoft.office.apphost.LaunchActivity|","tags":["学习笔记"]},{"title":"Excel 宏命令处理(一)","url":"/post/VBA/Excel 宏命令处理/index.html  2017/10/18/VBA/Excel 宏命令处理/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# Excel 宏命令处理\n&nbsp;&nbsp;&nbsp;&nbsp;在我们工作的时候,常常会遇到大量的数据处理.人工操作费时费力,于是笔者开始百度看看有没有什么自动化的方法,最后发现了excel可以使用宏指令来实现编程式处理.\n## Excel VBA\n>  Visual Basic for Applications(VBA)是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程式功能，特别是Microsoft Office软件。也可说是一种应用程式视觉化的Basic 脚本。该语言于1993年由微软公司开发的的应用程序共享一种通用的自动化语言--------Visual Basic For Application(VBA)，实际上VBA是寄生于VB应用程序的版本。微软在1994年发行的Excel5.0版本中，即具备了VBA的宏功能。\n要熟悉VBA，那么就不得不先了解宏和它们之间的关系。\nVBA被称为宏语言，但是它决不能和宏划上等号，宏是一条指令或者几条指令的集合，控制WORD或EXCEL等执行一连串的操作。而VBA则是不折不扣的高级语言，通过面向对象的方法来实现不能实现的功能。在编辑一个宏的时候，visual basic 编辑器会将这个宏记录为一个VBA过程\nVBA使应用程序具有生命的特征，以适应不同的环境，不同的应用，其主要表现为定制、自动化、协作化。\nVBA的特点是将VB语言与应用对象模型结合起来，处理各种应用需求。WORD VBA则是将VB应用于Word对象模型，或者说是用VB语言来操控这些Word对象模型，以达到各种应用的要求。所以，如果你想通过VBA控制WORD或EXCEL，必须同时熟悉VB语言和Word对象模型。\n\n## 如何使用VBA\n`视图-宏`\n![VBA](http://oskhhyaq3.bkt.clouddn.com/blog/171018/hHHBK2h4eh.png?imageslim)\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171018/F7CBBaFhH3.png?imageslim)\n\n如果不能使用宏,可能你的excel禁用了.启动即可\n启用方式:\n`文件-选项-信任中心-信任中心设置-宏设置-启用所有宏`\n配合录制宏就可以试着写代码了\n\n## Sheet 分割示例\n```vbscript\nSub 自动分类()\n\n' 前提条件:总表已经根据某个要分类的标识字段排好了顺序\n' 此方法是将一张数据量非常大的sheet表按某个字段进行分类并分割成不同的sheet表\n' 同时将该sheet的名称命名为sheet内标识该sheet的字段的名称\n    Dim sheetPage As Integer\n    Dim length As Integer '总表的最后一列的列数\n    Dim i As Integer\n    Dim Name As String\n    Dim topLeft As Integer '所选区域的左上角\n    Dim bottomRight As Integer '所选区域的右下角\n    \n '  参数初始化\n    Name = \"2013\" '总表的名称\n    length = 1510 '总表的最后一列的列数\n    sheetPage = 4 '从第几张sheet开始生成\n    topLeft = 2   '初始从第几列开始\n    bottomRight = 2 '初始从第几列结束\n '\n    '先建表\n        For i = 2 To length\n            Sheets(Name).Select\n            bottomRight = i\n            If Range(\"A\" & topLeft).Value <> Range(\"A\" & bottomRight).Value Then\n                Sheets.Add After:=ActiveSheet\n                topLeft = bottomRight\n            End If\n        Next i\n    '割分\n    \n        topLeft = 2\n        For i = 2 To length\n           Sheets(Name).Select\n           \n           bottomRight = i\n           If Range(\"A\" & topLeft).Value <> Range(\"A\" & bottomRight).Value Then\n                Sheets(Name).Select\n                Range(\"A\" & topLeft & \":\" & \"G\" & (bottomRight - 1)).Select '选择从AtopLeft到Gbottom的区域等待复制\n                Selection.Copy\n                \n                Sheets(sheetPage).Select\n                Range(\"A1\").Select\n                ActiveSheet.Paste\n                Sheets(sheetPage).Name = Range(\"A1\").Value\n                sheetPage = sheetPage + 1\n                topLeft = bottomRight\n           End If\n            \n        Next i\n        \n         Sheets(\"2013\").Select\n         Range(\"A\" & topLeft & \":\" & \"G\" & (bottomRight - 1)).Select\n         Selection.Copy\n         \n         Sheets(sheetPage - 1).Select\n         Sheets.Add After:=ActiveSheet\n         Sheets(sheetPage).Select\n         \n         Range(\"A1\").Select\n         ActiveSheet.Paste\n         sheetName = Range(\"A1\").Value\n         Sheets(sheetPage).Name = sheetName\n         \n         topLeft = bottomRight\n    \n    \n    \nEnd Sub\nSub 排序()\n    For Each Sh In Worksheets\n        If Sh.Index > 4 Then  '限定工作表范围\n            Sh.Select\n            Columns(\"B:B\").Select\n            Sh.Sort.SortFields.Clear\n            Sh.Sort.SortFields.Add Key:=Range(\"B1\"), _\n                SortOn:=xlSortOnValues, Order:=xlAscending, DataOption:=xlSortNormal\n            With Sh.Sort\n                .SetRange Range(\"A1:G69\")\n                .Header = xlNo\n                .MatchCase = False\n                .Orientation = xlTopToBottom\n                .SortMethod = xlPinYin\n                .Apply\n            End With\n            End If\n        Next\n\n\n\n\nEnd Sub\n\n\n\n```\n## [github源码下载](https://github.com/lovemefan/Excell-Macro)","tags":["宏命令"]},{"title":"Java学习笔记 (一)   基于Robot类的一些自动测试类的一些应用","url":"/post/Java/Java Robot类的一些应用/index.html  2017/10/17/Java/Java Robot类的一些应用/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n\n<!-- more -->\n<The rest of contents | 余下全文>\n# Java Robot类的一些应用\n##  Robot简介\n&nbsp;&nbsp;&nbsp;&nbsp;Robot类是JAVA程序实现自动测试，自动演示功能，或者是其它的一些鼠标和键盘控制的应用。出于这样的目的，自从JDK1.3开始，它就为我们提供了一个用来产生本机输入事件的机器人类－－java.awt.Robot.\n&nbsp;&nbsp;&nbsp;&nbsp;此类本来是通过操作鼠标键盘来完成软件的自动测试使用的,我们可以利用Robot类来实现一些我们想要达到的结果\n\n## Robot API\n[官方英文API](https://docs.oracle.com/javase/7/docs/api/java/awt/Robot.html)\n``Robot类其中的方法:``\n![methods](http://oskhhyaq3.bkt.clouddn.com/blog/171017/17j0LJJLEB.png?imageslim)\n\n\n通过查看API,Robot类提供了`截屏` ` 获取屏幕某一点的像素的颜色``键盘按下和释放事件``鼠标点击和释放事件``鼠标移动事件``鼠标滑轮事件`.\n\n## Demo\n这个demo是来实现模拟键盘的一个例子.实现一个信息轰炸功能.\n点击运行后,将光标移到输入区域,程序运行五秒之后会在光标出不断输出字符.\n其中还要使用到java.awt.event.KeyEvent类中的键值\n代码如下:\n```java\nimport java.awt.AWTException;\nimport java.awt.Robot;\nimport java.awt.event.KeyEvent;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class sendMessage {\n\t\n\tprivate int delayTime;\n\tprivate int range;\n\tRobot robot ;\n\tMap map;\n\tpublic sendMessage(int delayTime,int range)\n\t{\n\t\tthis.delayTime = delayTime;\n\t\tthis.range = range;\n\t}\n\tpublic void send() {\n\t\t//使用map 将控制键盘的常量存起来，好方便取用。\n\t\tmap = new HashMap();\n\t\tmap.put(0, 0x30);//键盘的0\n\t\tmap.put(1, 0x31);//键盘的1\n\t\tmap.put(2, 0x32);\n\t\tmap.put(3, 0x33);\n\t\tmap.put(4, 0x34);\n\t\tmap.put(5, 0x35);\n\t\tmap.put(6, 0x36);\n\t\tmap.put(7, 0x37);\n\t\tmap.put(8, 0x38);\n\t\tmap.put(9, 0x39);\n\t\ttry {\n\t\t\t\trobot = new Robot();\n\t\t\t\trobot.delay(5000);//延迟5秒供你打开编辑器\n\t\t\t\teditContent2();\n\t\t\t\t\n\t\t} catch (AWTException e) {\n\t\t// TODO Auto-generated catch block\n\t\te.printStackTrace();\n\t\t}\n\n\t}\n\tpublic static void main(String[] args) {\n\t\t//每隔几毫秒,以及数值的范围\n\t\tsendMessage demo = new sendMessage(1000,200);\n\t\tdemo.send();\n\t}\n\t/*********************************************\n\t *editContent1实验的功能输出从0到Range的一个方法\n   \t ********************************************/\n\tpublic void editContent1()\n\t{\n\t\t//让机器从0数到Range\n\t\tfor (int i = 0; i <= range; i++) {\n\t\t\trobot.delay(this.delayTime);\n\t\t\t// 个位数的处理\n\t\t\tif (i <= 9) {\n\t\t\t\trobot.keyPress((int) map.get(i));\n\t\t\t\trobot.keyRelease((int) map.get(i));\n\t\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t}\n\t\t\t// 两位数的处理\n\t\t\tif (i > 9 && i <= 99) {\n\t\t\t\tint a = i / 10;// 十位\n\t\t\t\tint b = i % 10;// 个位\n\t\t\t\trobot.keyPress((int) map.get(a));\n\t\t\t\trobot.keyRelease((int) map.get(a));\n\t\t\t\trobot.keyPress((int) map.get(b));\n\t\t\t\trobot.keyRelease((int) map.get(b));\n\t\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t}\n\t\t\t// 三位数的处理\n\t\t\tif (i > 99 && i <= 999) {\n\t\t\t\tint a = i / 100;// 百位\n\t\t\t\tint b = (i % 100) / 10;// 十位\n\t\t\t\tint c = i % 10;// 个位\n\t\t\t\trobot.keyPress((int) map.get(a));\n\t\t\t\trobot.keyRelease((int) map.get(a));\n\t\t\t\trobot.keyPress((int) map.get(b));\n\t\t\t\trobot.keyRelease((int) map.get(b));\n\t\t\t\trobot.keyPress((int) map.get(c));\n\t\t\t\trobot.keyRelease((int) map.get(c));\n\t\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t}\n\t\t}\n\t}\n\t/************************************************************************\n\t *editContent2为模拟键盘输入,在英文输入法状态下输出为拼音字母,中文输入法状态下为中文\n   \t ************************************************************************/\n\tpublic void editContent2()\n\t{\n\t\tfor (int i = 0; i < range; i++) {\n\t\t\trobot.delay(this.delayTime/2);\n\t\t\trobot.keyPress(KeyEvent.VK_C);\n\t\t\trobot.keyRelease(KeyEvent.VK_C);\n\t\t\trobot.keyPress(KeyEvent.VK_N);\n\t\t\trobot.keyRelease(KeyEvent.VK_N);\n\t\t\trobot.keyPress(KeyEvent.VK_M);\n\t\t\trobot.keyRelease(KeyEvent.VK_M);\n\t\t\trobot.keyPress(KeyEvent.VK_SPACE);\n\t\t\trobot.delay(this.delayTime/2); //注意,不过不加delay,在按下之母后立即继续按下后续操作会让输入法来不及相应,所以要延迟一小段时间\n\t\t\trobot.keyPress(KeyEvent.VK_ENTER);\n\t\t\trobot.keyRelease(KeyEvent.VK_ENTER);\n\t\t\t\n\t\t}\n\t\t\n\t}\n}\n\n```\n上面有两个方法分别是`editContent1`和`editContent2`,前者仅仅是从键盘输入一些数字,后者是在打开中文输入法的情况下依次输入中文的拼音,模拟人为打字.\n\n运行结果如下:\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/171017/afljFb21L3.png?imageslim)","tags":["编程语言"]},{"title":"Python学习笔记 (四)  安装scrapy框架","url":"/post/Python学习笔记/scrapy框架/index.html  2017/09/23/Python学习笔记/scrapy框架/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n安装scrapy框架\n<!-- more -->\n<The rest of contents | 余下全文>\n## scrapy框架\n>Scrapy，Python开发的一个快速、高层次的屏幕抓取和web抓取框架，用于抓取web站点并从页面中提取结构化的数据。Scrapy用途广泛，可以用于数据挖掘、监测和自动化测试。\nScrapy吸引人的地方在于它是一个框架，任何人都可以根据需求方便的修改。它也提供了多种类型爬虫的基类，如BaseSpider、sitemap爬虫等，最新版本又提供了web2.0爬虫的支持。 --百度百科\n\n## 安装准备\n* pip install whell\n* pip install lxml\n* pipi nstall twisted\n* pip install scrapy\n\n## 新建项目\n在控制台下输入:\n* 创建项目: scrapy startproject 项目名      \n* 创建爬虫: scrapy genspider -t basic 爬虫名 目标URL\n\n__项目目录如下:__\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170923/a4l4a8H3eJ.png?imageslim)\n\n## 运行项目\n\n  在控制台下输入: scrapy crawl  爬虫名\n ","tags":["Python"]},{"title":"Android学习笔记 (一)   按钮事件处理的五种方法","url":"/post/Android/Android 按钮事件的五种处理方法/index.html  2017/09/12/Android/Android 按钮事件的五种处理方法/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n 收集了五种处理按钮事件处理的方法\n<!-- more -->\n<The rest of contents | 余下全文>\n# Android 按钮事件的五种处理方法\n这里用一个小例子来说明:\n首先在新建的工程的activity_main.xml中添加一个Button和一个TextView.\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\t<android.support.constraint.ConstraintLayout\n    xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\"\n    xmlns:app=\"http://schemas.android.com/apk/res-auto\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"match_parent\"\n    tools:context=\"com.lovemefan.myapplication3.MainActivity\">\n\n    <TextView\n        android:id=\"@+id/tv1\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:text=\"Hello World!\"\n        app:layout_constraintBottom_toBottomOf=\"parent\"\n        app:layout_constraintLeft_toLeftOf=\"parent\"\n        app:layout_constraintRight_toRightOf=\"parent\"\n        app:layout_constraintTop_toTopOf=\"parent\" />\n    <Button\n        android:id=\"@+id/bt1\"\n        android:text=\"click\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n</android.support.constraint.ConstraintLayout>\n\n```\n## `1.使用匿名内部类`\n接下来在MainActivity.java文件中如下\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n       bt.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View view) {\n                TextView tv = (TextView) findViewById(R.id.tv1);\n                tv.setText(\"hello android\");\n            }\n        });//内部匿名类实现按键处理\n    }\n}\n\n```\n## `2.使用自定义单击事件监听类`\n```java\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n        bt.setOnClickListener(new myButtonClick());//自定义事件监听类实现按钮事件处理\n    }\n    public class myButtonClick implements View.OnClickListener{\n\n       @Override\n       public void onClick(View view) {\n           TextView tv = (TextView) findViewById(R.id.tv1);\n           tv.setText(\"hello android\");\n       }\n   }\n}\n\n```\n## `3.使用lambda语法实现按钮处理`\n首先确保环境支持`lambda`语法,即JDK在1.8及以上.\n```java\n\npublic class MainActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n        bt.setOnClickListener((view)->{\n            TextView tv = (TextView) findViewById(R.id.tv1);\n            tv.setText(\"hello android\");\n        });//lambda语法实现按钮处理事件\n\n    }\n}\n```\n如果在Android Studio 下报错:\n```\nError:Jack is required to support java 8 language features. Either enable Jack or remove sourceCompatibility JavaVersion.VERSION_1_8.\n```\n请在`build.gradle(Module:app)`文件加入以下代码\n```\n# 在 build.gradle 文件中加入如下代码\ndefaultConfig {\n    ...\n    jackOptions {\n        enabled true\n    }\n}\n\ncompileOptions {\n    sourceCompatibility org.gradle.api.JavaVersion.VERSION_1_8\n    targetCompatibility org.gradle.api.JavaVersion.VERSION_1_8\n}\n```\n## `4.Activity继承View.OnClickListener`\n由Activity实现OnClick(View view)方法，在OnClick(View view)方法中用switch-case对不同id代表的button进行相应的处理： \n```java\npublic class MainActivity extends AppCompatActivity implements View.OnClickListener {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        Button bt = (Button) findViewById(R.id.bt1);\n        bt.setOnClickListener((view)->{\n            TextView tv = (TextView) findViewById(R.id.tv1);\n            tv.setText(\"hello android\");\n        });//lambda语法实现按钮处理事件\n\n    }\n    public void onClick(View view) {  \n  \n        switch (view.getId()){  \n            case R.id.bt:  \n                TextView tv = (TextView) findViewById(R.id.tv1);\n\t            tv.setText(\"hello android\");  \n            break;  \n            default:  \n            break;  \n        }  \n    }  \n}\n\n```\n这个方法适合多个按钮\n\n## `5.在XML文件指定按钮的onClick属性`\n在XML文件中显示指定按钮的onClick属性，这样点击按钮时会利用反射的方式调用对应Activity中的click()方法： \n在我之前学习的Windows 10 `UWP` 的app开发中都是用的这种方法.\nUWP也是类似的在相应的XAML代码中设置click属性即可,并且Visual Studio会自动为其添加相应方法.**\\\\(▔＾▔)/ 微软大法好**\n```xml\n<Button\n        android:onClick=\"sayHelloAndroid\"\n        android:id=\"@+id/bt1\"\n        android:text=\"click\"\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\" />\n```\n笔者经过百度了后,发现Android Studio 有快捷键来生成click相应的方法:点击onclick的属性值,然后按Alt+Enter\n![生成方法](http://oskhhyaq3.bkt.clouddn.com/blog/170912/5jeDm9Klik.png?imageslim)\n然后就生成了相应方法,这样可以避免手动写方法时不小心拼错单词了.\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170912/547A3AcCIg.png?imageslim)\n\n我个人比较喜欢用第五种方法.界面与后台代码可以完全分开,代码量也少.不过反射最大的缺点就是影响性能和效率.","tags":["学习笔记"]},{"title":"查四六级准考证号的一种方法","url":"/post/其他/四六级查询准考证方法/index.html  2017/08/29/其他/四六级查询准考证方法/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n利用某软件返回值,js代码查询准考证号\n<!-- more -->\n<The rest of contents | 余下全文>\n# 四六级查询准考证方法\n## 前言\n身边有好多小伙伴们有忘记四六级准考证号而且还找不回准考证的情况.\n因为以前的九九宿舍不能用了,并且网上很少提供这种查询的网站(可能是我孤陋寡闻没听过)\n所以这里分享一个贴吧大神公布的方法(该贴已被删).实际上是利用某一个软件的bug,也不知道什么时候会被封.\n## 原理\n某一软件的一个查询口语的入口,即使没有报口语,在其内部的返回值中会包含准考证号的信息,利用这点获得准考证号\n\n## 操作流程\n最好用`谷歌的chrome浏览器`,我试过edge和UC都没用.其他没测试过.\n必要条件:\n* 身份证号\n* 姓名\n\n\n下面以chrome为例:\n1. 打开chrom,转到下面网址\n```http\nhttp://app.cet.edu.cn:7066/baas/app/setuser.do?method=UserVerify\n```\n这时候会出现一堆错误,没关系,继续下一步\n![chromerror](http://oskhhyaq3.bkt.clouddn.com/blog/170829/lFCj5E5CF5.png?imageslim)\n2.按下F12打开开发者工具,点击Console切换到控制台\n![控制台](http://oskhhyaq3.bkt.clouddn.com/blog/170829/i6Gc65eAbg.png?imageslim)\n3.在下面空白光标出输入以下代码\n```javascript\n(function(d, s){ d.body.appendChild(s = d.createElement('script')).src = 'http://code.jquery.com/jquery-1.9.1.min.js'})(document);\n\n```\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170829/JBGHkmkkm0.png?imageslim)\n如果出现`Uncaught SyntaxError: Unexpected end of input`字样,应该是代码不完整或部分拼写错误.重新复制一遍就好了\n4.接下来输入另一段代码\n```javascript\nvar url = \"http://app.cet.edu.cn:7066/baas/app/setuser.do?method=UserVerify\";\nvar ks_data = {\n\"ks_xm\": \"姓名\",\n\"ks_sfz\": \"身份证号\",\n\"jb\": \"四级填1,六级填2\"\n};\nvar postdata = {\n\"action\": \"\",\n\"params\": JSON.stringify(ks_data)\n};\n$.post(url = url, data = postdata, callback = function(data) {\ndata = $.parseJSON(data)\nconsole.log(data[\"ks_bh\"])\n})\n\n```\n将上述代码的姓名,身份证等参数替换掉,回车确定\n![返回准考证号](http://oskhhyaq3.bkt.clouddn.com/blog/170829/Icg2EBD67j.png?imageslim)\n如果出现其他错误,可能你的`信息输入有误`,请核对再输一遍.如果还有错则该考生不存在(没报考).\n这个只能查最近一次的准考证.\n好了,大功告成\n点击下面:\n[四级查询路口 http://cet.neea.edu.cn/cet/](http://cet.neea.edu.cn/cet/)\n 然后就可以查分数了.\n 溜了溜了...","tags":["JavaScript"]},{"title":"Python学习笔记 (三)  简单爬虫实战","url":"/post/Python学习笔记/Python 实战/index.html  2017/08/19/Python学习笔记/Python 实战/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nPython实战 抓取网页\n<!-- more -->\n<The rest of contents | 余下全文>\n# Python 实战\n## 简单的静态文本抓取\n### request库命令安装\nwindows下进入cmd ，定位到你Python的安装路径，我的是D:\\Program Files\\Python27\\Scripts。因为以后常用，不妨加到环境变量中，以后就不用在定位到安装路径，直接调用。\n然后在cmd、PowerShell、XShell中输入以下命令\n* Windows :  pip install request\n* Linux :  sudo pip install request\n* Mac OS :  sudo pip install request  \n### 抓取目标：\n* [http://my.0ff0.net/](http://my.0ff0.net/)\n* [https://get.freevpnss.me/#vpn](https://get.freevpnss.me/#vpn)\n\n以上是两个免费的VPN网站，目标是将网站中的VPN服务器IP、用户名、密码、IPSec密钥等相关信息抓取下来以便使用。本次程序需要用到request库，如果没有安装\n### 网站分析\n#### 第一个网站\n![http://my.0ff0.net](http://oskhhyaq3.bkt.clouddn.com/blog/170726/i9GiJIBJcd.png?imageslim)\n查看其源码如下：\n![my.0ff0.nety源码](http://oskhhyaq3.bkt.clouddn.com/blog/170726/fj8DBkdhgD.png?imageslim)\n第一个网站结构和源码都比较简单，直接使用Python的正则表达式匹配其字符就行\n直接上源代码：\n```python\n# coding:utf-8\nimport requests\nimport re\nhtml = requests.get(\"http://my.0ff0.net/\")\n# html.encoding = 'utf-8'\ncontent = re.findall('<div class=\"content\">(.*?)</div>',html.text,re.S)[0]\nserverip =re.findall('<span id=\"ip\">(.*?)</span>',content,re.S)\nuser =re.findall('<span id=\"user\">(.*?)</span>',content,re.S)\npassword =re.findall('<span id=\"pw\">(.*?)\\n</span>',content,re.S)\nsecret =re.findall('<span id=\"secret\">(.*?)</span>',content,re.S)\n\n\n# print html.text\nprint \"服务器地址: %s \"%str(serverip[0])\nprint \"用户名: %s\"%str(user[0])\nprint \"密码: %s\"%str(password[0])\nprint \"IPSec密钥: %s\"%str(secret[0])\nprint \"连接方式：PPTP和Cisco IPSec(IKEv1)\"\n```\n\n运行结果：\n![运行结果](http://oskhhyaq3.bkt.clouddn.com/blog/170726/maJClL2Ha4.png?imageslim)\n\n#### 第二个网站\n![freeVPN](http://oskhhyaq3.bkt.clouddn.com/blog/170820/hkebHGd2L7.png?imageslim)\n**F12查看源码,同样用正则表达式吧需要的字符匹配出来.**\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170820/L0g8L9L5C5.png?imageslim)\n### 源码\n```python\n# coding:utf-8\nfrom encodings import gb18030\n\nimport requests\nimport re\nhtml = requests.get(\"http://jn9.org/indexcn.html\")\nhtml.encoding = 'utf-8'\n\ntarget = re.findall('<div class=\"panel-heading\">(.*?)<span class=\"label label-success\">Active</span></p>.*?</div>.*?</div>.*?</div><!-- /.col-sm-4 -->',html.text,re.S)\nfor i in range(target.__len__()):\n    adress = re.findall('<h2 class=\"panel-title\">(.*?)</h2>',target[i],re.S)\n    contend = re.findall('<p>(.*?)</p>',target[i],re.S)\n    if adress:\n        print \"地区:\",adress[0]\n    for each in contend:\n        result = re.sub('<span class=\"hidden\">(.*?)</span>', '',each)\n        print result\n    print \"\\n\\n\"\n```\n运行结果如下:\n![效果图](http://oskhhyaq3.bkt.clouddn.com/blog/170820/49jGcfChGJ.png?imageslim)\n`好了,翻个墙出去玩耍了.`","tags":["Python"]},{"title":"数学建模论文格式分析","url":"/post/数学建模/论文格式分析鉴赏/index.html  2017/08/10/数学建模/论文格式分析鉴赏/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n关于数学建模论文格式分析 教会你怎么写相关论文\n<!-- more -->\n<The rest of contents | 余下全文>\n# 论文格式分析鉴赏\n## 论文格式\n根据分析论文中的格式，可以总结出以下格式：\n### 摘要\n摘要的特点首先在于'短\"，要简短扼要，高度浓缩，目的是节省老师的时间、提高效率。老师阅读        摘要后，就能够确切地了解论文的主要内容和结果，决定是否需要阅读全文。摘要最好能引人入胜，使之产生看完全文的兴趣。尽量简述对问题的解决思路，最好先一句话用什么方法解决了什么类型的问题。\n* 模型的数学归类（在数学上属于什么类型）\n* 建模的思想（思路）\n* 算法思想（求解思路）\n* 建模特点（模型优点，建模思想或方法，算法特点，结果检验，灵敏度 分析，模型检验）\n* 主要结果（数值结果，结论）（回答题目所问的全部“问题”） \n### 问题分析\n根据题目给出的已知条件，结合自己的理解，分析问题的解决方法，引出解题的思路．一个一个问题有条理得分析问题．最后一段总结．\n\n### 模型假设\n首先基本假设的合理性很重要。\n* 根据题目中条件和要求作出假设 \n* 关键性假设不能缺，假设要切合题意 \n\n### 符号说明\n根据范文分析，就是将本文将会出现的数学符号通过表格清晰明了得进行说明。\n如下图\n![符号说明](http://oskhhyaq3.bkt.clouddn.com/blog/170810/EfCjfI7k8d.png?imageslim)\n\n### 模型建立与求解\n#### 基本模型： \n*  首先要有数学模型：数学公式、方案等 \n* 基本模型，要求 完整，正确，简明\n#### 简化模型:\n * 要明确说明：简化思想，依据 \n* 简化后模型，尽可能完整给出 \n模型要实用，有效，以解决问题有效为原则。 数学建模面临的、要解决的是实际问题，不追求数学上。高（级）、深（刻）、 难（度大）。\n#### 模型要求：\n* 能用初等方法解决的、就不用高级方法;\n* 能用简单方法解决的，就不用复杂方法; \n* 能用被更多人看懂、理解的方法;\n* 就不用只能少数人看懂、理解的方法\n* 鼓励创新，但要切实，不要离题搞标新立异数模创新可出现在 \n* 建模中，模型本身，简化的好方法、好策略等， \n#### 模型求解中 \n* 结果表示、分析、检验，模型检验 \n* 推广部分 \n#### 在问题分析推导过程中，需要注意的问题： \n* 分析：中肯、确切 \n* 术语：专业、内行；；  \n* 原理、依据：正确、明确, \n* 表述：简明，关键步骤要列出 \n* 忌：外行话，专业术语不明确，表述混乱，冗长。\n\n### 模型评价和推广\n#### 模型评价:\n* 优点突出（预测问题关注精度，优化问题关注性能，分类问题关注准确性，等等，根据实际问题写模型优点，一定要写到点上）\n* 缺点不回避，但是缺点要挑无关痛痒的讲，可以将假设中的不足或局限性作为缺点。\n模型推广:\n* 适用的场景、人群、范围等等（不可硬套，根据实际题目实际情况来写） \n* 推广或改进方向时，不要玩弄新数学术语（让人看得懂，复杂也要简单化，切莫把简单的描述的过于复杂）\n\n### 参考文献\n按要求的格式写\n尽量引用好的文献、书籍、资料等等\n\n### 附录\n* 程序代码（基本上是代码）\n* 详细的结果，详细的数据表格，可在此列出，但不要错，错的宁可不列。\n* 主要结果数据应在正文中列出，不怕重复。 ","tags":["论文"]},{"title":"Python学习笔记 (二)  第三方库安装","url":"/post/Python学习笔记/第三方库安装/index.html  2017/07/22/Python学习笔记/第三方库安装/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\nPython的第三方库的安装\n<!-- more -->\n<The rest of contents | 余下全文>\n## 第三方库安装\n### 命令安装\nwindows下进入cmd ，定位到你Python的安装路径，我的是D:\\Program Files\\Python27\\Scripts。因为以后常用，不妨加到环境变量中，以后就不用在定位到安装路径，直接调用。\n然后在cmd、PowerShell、XShell中输入以下命令\n* Windows :  pip install xxx\n* Linux :  sudo pip install xxx\n* Mac OS :  sudo pip install xxx   \n\n     \n`少用easy_install 因为只能安装不能卸载`\n### 自定义安装\n 当出现问题或者不想用命令安装时  请戳>>[http://www.lfd.uci.edu/~gohlke/pythonlibs/](http://www.lfd.uci.edu/~gohlke/pythonlibs/)\n 这个网站有Python所有的第三方库文件。将下载好的文件原后缀.whl改为.zip,并解压到python安装目录的Lib文件夹下。","tags":["Python"]},{"title":"Python学习笔记 (一)  初识Python","url":"/post/Python学习笔记/初识Python/index.html  2017/07/22/Python学习笔记/初识Python/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n认识Python及搭建开发环境\n<!-- more -->\n<The rest of contents | 余下全文>\n#  初识Python\n##  Python\n>Python[1]  （英国发音：/ˈpaɪθən/ 美国发音：/ˈpaɪθɑːn/）, 是一种面向对象的解释型计算机程序设计语言，由荷兰人Guido van Rossum于1989年发明，第一个公开发行版发行于1991年。\nPython是纯粹的自由软件， 源代码和解释器CPython遵循 GPL(GNU General Public License)协议[2]  。Python语法简洁清晰，特色之一是强制用空白符(white space)作为语句缩进。\nPython具有丰富和强大的库。它常被昵称为胶水语言，能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中[3]  有特别要求的部分，用更合适的语言改写，比如3D游戏中的图形渲染模块，性能要求特别高，就可以用C/C++重写，而后封装为Python可以调用的扩展类库。需要注意的是在您使用扩展类库时可能需要考虑平台问题，某些可能不提供跨平台的实现。--百度百科\n\n***个人认为Python是一款非常适合初学者的语言，同时有面向过程和对象的特性，语法简单非常接近自然语言，功能强大***\n## 发展历程\n>自从20世纪90年代初Python语言诞生至今，它已被逐渐广泛应用于系统管理任务的处理和Web编程。\nPython的创始人为Guido van Rossum。1989年圣诞节期间，在阿姆斯特丹，Guido为了打发圣诞节的无趣，决心开发一个新的脚本解释程序，做为ABC 语言的一种继承。之所以选中Python（大蟒蛇的意思）作为该编程语言的名字，是因为他是一个叫Monty Python的喜剧团体的爱好者。\nABC是由Guido参加设计的一种教学语言。就Guido本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是ABC语言并没有成功，究其原因，Guido 认为是其非开放造成的。Guido 决心在Python 中避免这一错误。同时，他还想实现在ABC 中闪现过但未曾实现的东西。\n就这样，Python在Guido手中诞生了。可以说，Python是从ABC发展起来，主要受到了Modula-3（另一种相当优美且强大的语言，为小型团体所设计的）的影响。并且结合了Unix shell和C的习惯。\nPython[4]  已经成为最受欢迎的程序设计语言之一。2011年1月，它被TIOBE编程语言排行榜评为2010年度语言。自从2004年以后，python的使用率呈线性增长[5]  。\n由于Python语言的简洁性、易读性以及可扩展性，在国外用Python做科学计算的研究机构日益增多，一些知名大学已经采用Python来教授程序设计课程。例如卡耐基梅隆大学的编程基础、麻省理工学院的计算机科学及编程导论就使用Python语言讲授。众多开源的科学计算软件包都提供了Python的调用接口，例如著名的计算机视觉库OpenCV、三维可视化库VTK、医学图像处理库ITK。而Python专用的科学计算扩展库就更多了，例如如下3个十分经典的科学计算扩展库：NumPy、SciPy和matplotlib，它们分别为Python提供了快速数组处理、数值运算以及绘图功能。因此Python语言及其众多的扩展库所构成的开发环境十分适合工程技术、科研人员处理实验数据、制作图表，甚至开发科学计算应用程序。\n说起科学计算，首先会被提到的可能是MATLAB。然而除了MATLAB的一些专业性很强的工具箱还无法替代之外，MATLAB的大部分常用功能都可以在Python世界中找到相应的扩展库。和MATLAB相比，用Python做科学计算有如下优点：\n● 首先，MATLAB是一款商用软件，并且价格不菲。而Python完全免费，众多开源的科学计算库都提供了Python的调用接口。用户可以在任何计算机上免费安装Python及其绝大多数扩展库。\n● 其次，与MATLAB相比，Python是一门更易学、更严谨的程序设计语言。它能让用户编写出更易读、易维护的代码。\n● 最后，MATLAB主要专注于工程和科学计算。然而即使在计算领域，也经常会遇到文件管理、界面设计、网络通信等各种需求。而Python有着丰富的扩展库，可以轻易完成各种高级任务，开发者可以用Python实现完整应用程序所需的各种功能。\n\n## 风格\n>Python在设计上坚持了清晰划一的风格，这使得Python成为一门易读、易维护，并且被大量用户所欢迎的、用途广泛的语言。\n设计者开发时总的指导思想是，对于一个特定的问题，只要有一种最好的方法来解决就好了。这在由Tim Peters写的Python格言（称为The Zen of Python）里面表述为：There should be one-- and preferably only one --obvious way to do it. 这正好和Perl语言（另一种功能类似的高级动态语言）的中心思想TMTOWTDI（There's More Than One Way To Do It）完全相反。\nPython的作者有意的设计限制性很强的语法，使得不好的编程习惯（例如if语句的下一行不向右缩进）都不能通过编译。其中很重要的一项就是Python的缩进规则。\n一个和其他大多数语言（如C）的区别就是，一个模块的界限，完全是由每行的首字符在这一行的位置来决定的（而C语言是用一对花括号{}来明确的定出模块的边界的，与字符的位置毫无关系）。这一点曾经引起过争议。因为自从C这类的语言诞生后，语言的语法含义与字符的排列方式分离开来，曾经被认为是一种程序语言的进步。不过不可否认的是，通过强制程序员们缩进（包括if，for和函数定义等所有需要使用模块的地方），Python确实使得程序更加清晰和美观。\n# 搭建环境\n## 下载Python\n官网下载[Python](https://www.python.org/),建议下载Python 2.X 版的。目前网上大部分教程为2.X版。3.X版改进很大。这里是一些关于2和3版本的区别和指导，请自己斟酌\n[Python3.x和Python2.x的区别](http://www.cnblogs.com/codingmylife/archive/2010/06/06/1752807.html)\n[应该学习最新版本的 Python 3 还是旧版本的 Python 2？](https://www.zhihu.com/question/24549965)![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170722/l6aFIFLfC3.png?imageslim)\n## 配置环境变量\n我的电脑右键属性-高级系统变量-环境变量-向Path 添加Python的安装路径\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170722/Ebeb0LC1iE.png?imageslim)\n## 下载IDE\n点击这里有推荐  [提供给开发者 10 款最好的 Python IDE](http://www.oschina.net/news/57468/best-python-ide-for-developers)\n另外VIsual Studio 也可以。我自己使用破解版的`JetBrains PyCharm`[下载](https://www.jetbrains.com/pycharm/) 。\n![PyCharm](http://oskhhyaq3.bkt.clouddn.com/blog/170722/b4mFhHgAFj.png?imageslim)\n然后就愉快的玩耍了","tags":["Python"]},{"title":"UWP学习笔记 (三)   XAML界面原理和语法","url":"/post/UWP学习笔记/什么是XAML/index.html  2017/07/10/UWP学习笔记/什么是XAML/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n学习XAML在UWP 中的原理及语法\n<!-- more -->\n<The rest of contents | 余下全文>\n## 什么是XAML\n>XAML是EXtensible Application Markup Language的英文缩写，相应的中文名称为可扩展应用程序标记语言，它是微软公司为构建应用程序用户界面而创建的一种新的描述性语言。XAML提供了一种便于扩展和定位的语法来定义和程序逻辑分离的用户界面，而这种实现方式和ASP.NET中的\"代码后置\"模型非常类似。XAML是一种解析性的语言，尽管它也可以被编译。它的优点是简化编程式上的用户创建过程，应用时要添加代码和配置等。 --百度百科\n\n### 优点\n&#160;&#160;&#160;&#160;XAML简化了.Net Framework 3.0编程模式上的用户界面创建过程，使用XAML开发人员可以对WPF程序的所有用户界面元素(例如文本、按钮、图像和列表框等)进行详细的定置，同时还可以对整个界面进行合理化的布局，这与使用HTML非常相似。但是由于XAML是基于XML的，所以它本身就是一个组织良好的XML文档，而且相对于HTML，它的语法更严谨、更明确。预计以后大部分的XAML都可由相应的软件自动生成，就如同我们现在制作一个静态页面时，几乎不用编写任何HTML代码就可以直接通过Dreamweaver软件生成一个美观的页面。但是最初通过手动编写XAML代码将是一次绝佳的学习体验，虽然实现的过程繁杂了些，但是将加深您对XAML语法和各个元素的理解。\n大多数的WPF程序可能同时包含程序代码和 XAML。我们可以使用XAML定义应用程序的初始界面，而后才编写相应的功能实现代码。我们可以将逻辑代码直接嵌入到一个XAML文件中，也可以将它保留在一个单独的文件中。实际上，能够用XAML实现的所有功能我们都可以使用程序代码来完成。因此，我们根本无需使用任何的XAML就可以创建一个完好的WPF程序。一般来说，程序代码的优势在于流程处理和逻辑判断，而不是界面的构建上。而XAML则是集中关注于界面的编程，我们可以将它和其它的.NET语言配合使用，从而构建出一个功能完善、界面美观的WPF程序。XAML是一种纯正的、用来描述用户界面构成元件和编排方式的标记语言。尽管有部分的XAML语法具备程序设计语言的特性(例如XAML中的Trigger和TRansform)，但是XAML并不是一种用于程序设计的语言，它的功能也不是为了执行应用程序逻辑。\n&#160;&#160;&#160;&#160;微软推荐XAML被编译成BAML(Binary Application Markup Language-二进制语言程序标记语言)。XAML和BAML都可以被WPF解析，并且将以一种和HTML相似的方式进行界面的呈现。但是和HTML不同的是，XAML是强类型化的。也就是说，HTML会忽略那些它不能识别的元素和属性，而XAML必须在识别所有的元素和属性的情况下，才对页面进行呈现。尽管在XAML中各个属性都是以一个个的字符串(例如Background)表示的，但是这些字符串实际上代表的是WPF中的对象，只有被WPF识别的对象才可以作为元素的属性，所以我们说XAML是强类型化的。\n### 新功能\n微软Build 2013发布了一些已经被添加到Windows 8.1中的XAML新功能。[1]  \n* Hub控件\n* 命令栏\n* 弹出（Flyout）控件\n* 日期/时间选择控件\n* 取消StandardStyles.xaml\n### 与HTML的区别\n&#160;&#160;&#160;&#160;还有一点是我们反复强调的，XAML并不是HTML。尽管XAML在元素的声明、程序样式的设置和指定事件处理程序上都和HTML非常类似，但是XAML是基于XML的，它是WPF的外在表现形式。而HTML只是一种标记语言，仅仅是用来为浏览器呈现页面内容。XAML除了用来呈现信息和请求用户输入等基本的功能外，它还包含了一些高级的特性，例如它提供了对动画和3D众多方面的支持。\nXAML是可扩展的，正如它的名字指明的那样。开发人员可以创建自定义的控件、元素和函数来扩展XAML。而且由于XAML各元素在本质上就是WPF类的映射，所以开发人员可以很轻松地使用面向对象的技术对XAML元素进行扩展。也就是说我们可以开发一些自定义控件和组合元素，并将它公开给用户界面设计人员和其它的开发人员使用。\n\n## XAML代码在UWP中的角色\n* Page是UWP的用户界面主体。传统桌面程序是由一个个窗口组成的，而UWP是由一个Page（页面）组成的\n*  Page是一个partial类\n*  我们的任务是扩展Page这个类\n\t* 微软预制的Page为一个空的界面，没有内容\n\t* 我们只能扩展它\n*  XAML代码是界面部分，用来实例化.NET对象的标记语言。它可以非常简单的创建对象。\n如下图，这段XAML代码创建了一个Button 对象\n![XAML代码](http://oskhhyaq3.bkt.clouddn.com/blog/170711/L1H43BAcC0.jpg?imageslim)\n同样的用C#实现会怎么样呢？\n![C#代码](http://oskhhyaq3.bkt.clouddn.com/blog/170711/Cabge4dJHj.jpg?imageslim)\n&#160;&#160;&#160;&#160;&#160;XAML中的Margin是直接等于一个字符串，而C#中是需要给Margin赋值一个Thickness对象的。这归功于XAML的类型转换器。XAML在编译的时候，XAML语法分析器将字符串转换为对应的对象或枚举值，这样的话，我们可以直接用一个非常简单的值来代替冗长的类型名和枚举值来提高效率。\n## XAML语法\n### Content Property （内容属性）\n每个标签都有自己的默认的内容属性。比如`<Grid/>`的默认属性是`<Grid.Children><Grid.Children/>`,`<Button>`的默认属性是`<Button.Content>`.通常内容属性可省略。\n### self-closing \nXAML标签与其他标签类似有两种开闭形式\n*  `<xxx><xxx/>`\n* `<xxx/>`\n### Attribute 与简单的property\n可以直接在标签内定义该控件的一些简单属性，比如\n```xml\n<Button Name=\"button\" Height=\"200\" Width=\"200\"/>\n```\n### 复杂的property与property标签\n标签里的属性对象很复杂的时候，编译器无法将字符转化成对象是，就需要使用属性标签。\n比如说，当我要设置背景颜色时，如果时简单的颜色可以直接这样\n```xml\n<Grid Background=\"red\">\n</Grid>\n```\n当然，我们肯定不能满足这种单一色调的背景，我想要一个渐变的漂亮的背景怎么做呢？\n```xml\n<Grid>\n        <Grid.Background>\n\t        <!--LinearGradientBrush为线性笔刷-->\n            <LinearGradientBrush EndPoint=\"0.5,1\" StartPoint=\"0.5,0\">\n\t\t\t\t<!--从#FFAC6CC开始 偏移量为0，#FF2D7099 结束偏移量为1-->            \n                <GradientStop Color=\"#FFACD6CC\" Offset=\"0\"/>\n                <GradientStop Color=\"#FF2D7099\" Offset=\"1\"/>\n            </LinearGradientBrush>\n        </Grid.Background>\n </Grid>\n\n```\n\n### 特殊属性（UWP，WPF特有）\n* Dependency Property 依赖属性\n依赖属性就是自己自己没有值，通过Binding从数据源获得值，就是依赖在别人身上，拥有依赖属性的对象称为依赖对象。\n几种应用依赖属性的场景： \n 1. 希望可在样式中设置属性。 \n2. 希望属性支持数据绑定。 \n3. 希望可使用动态资源引用设置属性。 \n4. 希望从元素树中的父元素自动继承属性值。 \n5. 希望属性可进行动画处理。 \n6. 希望属性系统在属性系统、环境或用户执行的操作或者读取并使用样式更改了属性以前的值时报告。 \n7. 希望使用已建立的、WPF 进程也使用的元数据约定，例如报告更改属性值时是否要求布局系统重新编写元素的可视化对象。 \n依赖对象创建时并不包含存储数据空间。WPF中必须使用依赖对象作为依赖属性的宿主。\n ```xml\n \n <TextBox x:Name=\"textBox1\" Margin=\"10\"  Text=\"{Binding Path=Title}\"/>\n ```\n* Attached Property 附加属性 。附加属性为本不应该是该控件的属性而在该控件下设置的属性。\n比如\n```xml\n<Grid>\n\t<!--声明该Grid有三行-->\n\t<Grid.RowDefinitions>\n            <RowDefinition Height=\"auto\"/>\n            <RowDefinition Height=\"auto\"/>\n            <RowDefinition Height=\"auto\"/>\n       </Grid.RowDefinitions>\n    <!--这里的Grid.row本来是Grid的属性，却被当做是Button的属性。Grid.Row为Button的附加属性-->  \n\t<Button Grid.Row=\"2\"/>\n</Grid>\n```","tags":["UWP"]},{"title":"UWP学习笔记 (二)   UWP开发环境及项目工程解析","url":"/post/UWP学习笔记/开发环境及项目工程解析/index.html  2017/07/09/UWP学习笔记/开发环境及项目工程解析/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n介绍开发环境及UWP的组成部分\n<!-- more -->\n<The rest of contents | 余下全文>\n# 开发环境及项目工程解析\n工欲善其事，必先利其器。本章将介绍如何搭建Windows 10通用应用开发的环境以\n及开发第一个Windows 10通用应用程序，并解析其工程结构和代码以及如何适配不同平\n台的特殊代码。\n## 搭建开发环境\n### 开发环境的要求\n进行Windows 10的开发，计算机需要达到以下要求\n* 1.操作系统Windows 10(64位专业版)。\n* 2.系统盘需要至少8G的剩余硬盘空间。\n* 3.内存达到4GB以上。\n* 4.Windows10的手机模拟器基于Hyper-V,需要CPU支持二级地址转换技术。\n\n注意部分计算机会默认关闭主板BIOS的虚拟化技术，这时需要进入主板BIOS设置\n页面开启虚拟化技术，然后再启动或者关闭Windows功能界面启动Hyper-V服务。\n\n###开发工具的安装\n\nWindows10 SDK已集成在Visual Studio上o 2015最新的版本中。开发工具可以直接到敝\n软的Windows开发者网站进行下载([https //dev.windows.com](https //dev.windows.com))，由于开发工具的更新速\n度较快，请以官方最新版本为准。安装完成后，里面包含了程序的SDK.运行模拟器和编程\n工具。Windows 10 Developer Tools包含的工具集合详细信息如下\n\n* 1.Visual Stuio是Winoows 10的集成开发环境(IDE)，其中包括了C#和XAML.代码编辑\n功能、简单界面的布局与设计功能、编译程序、连接模拟器、部署程序，以及调试程序等功能。\n* 2.Emulator是Winows 10的模拟器，开发者可以把应用程序部署到各种分辨率的模拟器上来检查程序运行效果。如果用户有Windows 10手机，可以直接使用手机来调试和运行自己编的程序。\n## 创建Windows 10 通用应用\n打开Visual Studio 2015/2017。本人用的是Visual Studio 2017。新建一个C#通用项目\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170710/cAjddJLAIJ.png?imageslim)\n![新建UWP项目](http://oskhhyaq3.bkt.clouddn.com/blog/170710/0LJL24D0fm.png?imageslim)\n编辑MainPage.xaml文件，添加以下代码\n```xml\n <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock HorizontalAlignment=\"Center\" Margin=\"125,105,0,0\" TextWrapping=\"Wrap\" Text=\"Hello World\" VerticalAlignment=\"Center\" FontSize=\"72\"/>\n    </Grid>\n```\n如图：\n![hello world](http://oskhhyaq3.bkt.clouddn.com/blog/170710/G7JCl403Eg.png?imageslim)\n运行结果：\n![结果](http://oskhhyaq3.bkt.clouddn.com/blog/170710/KCl6BB6mAG.png?imageslim)\n## 解析Hello World 应用\nHello World 项目工程中里面包含了MainPage.xaml文件、MainPage.xaml.cs文件、App.xaml文件、App.xaml.cs文件、Package.appxmanifest文件、AssemblyInfo.cs文件和一些图片文件。\n### MainPage.xaml 文件\n```xml\n<Page\n    x:Class=\"HelloWorld.MainPage\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:HelloWorld\"\n    xmlns:d=\"http://schemas.microsoft.com/expression/blend/2008\"\n    xmlns:mc=\"http://schemas.openxmlformats.org/markup-compatibility/2006\"\n    mc:Ignorable=\"d\">\n\n    <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n        <TextBlock HorizontalAlignment=\"Center\" Margin=\"125,105,0,0\" TextWrapping=\"Wrap\" Text=\"Hello World\" VerticalAlignment=\"Center\" FontSize=\"72\"/>\n\n\n    </Grid>\n</Page>\n\n```\n&#160;&#160;&#160;&#160;Page元素是一个程序页面的根元素，表示当前的XAML代码是一个页面，当前页面的其他所有UI元素都必须在Page元素下面。在当前的页面里面有两个控件：Grid控件、TextBlock法控件。其中，Grid控件是布局容器控件，所以在可视化视图上并没有看到Grid控件的显示。Text131ock控件是一个文本框控件，用于显示文本的内容，在可视化视图上看到的。“TextBlock”就是TextBlock控件。在上面的页面代码中可以看到TextBlock控件里面还有很多属性，这些属性用于定义控件的各种特性的设置。例如，\"x Name。属性定义了\n控件的名称，在后台代码里就可以通过名称来访问控件。Text。属性定义了TextBlock控\n件文本显示的内容，等等。\n\n### MainPage.xmal.cs文件\n```cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices.WindowsRuntime;\nusing Windows.Foundation;\nusing Windows.Foundation.Collections;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\nusing Windows.UI.Xaml.Controls.Primitives;\nusing Windows.UI.Xaml.Data;\nusing Windows.UI.Xaml.Input;\nusing Windows.UI.Xaml.Media;\nusing Windows.UI.Xaml.Navigation;\n\n// https://go.microsoft.com/fwlink/?LinkId=402352&clcid=0x804 上介绍了“空白页”项模板\n\nnamespace HelloWorld\n{\n    /// <summary>\n    /// 可用于自身或导航至 Frame 内部的空白页。\n    /// </summary>\n    public sealed partial class MainPage : Page\n    {\n        public MainPage()\n        {\n            this.InitializeComponent();\n        }\n    }\n}\n\n```\n&#160;&#160;&#160;&#160;MainPage.xmal.cs文件就是MainPage.xmal文件对应的后台代码的处理，在MainPage.xmal.cs文件会完成程序页面的控件的初始化工作和处理控件的触发事件。\n###  App.xaml 文件\n```xml\n<Application\n    x:Class=\"HelloWorld.App\"\n    xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n    xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n    xmlns:local=\"using:HelloWorld\"\n    RequestedTheme=\"Light\">\n\n</Application>\n```\n&#160;&#160;&#160;&#160;App.xaml文件是应用程序的入口XAML文件，一个应用程序只有一个该文件，并且\n它还会有一个对应的App.xaml.cs文件。App.xaml文件的根节点是Appplication元素，它\n里面的属性定义和空间定义与上面的Mainpage.xaml页面是一样的，不一样的地方是在\nApp.xam]文件中定义的元素是对整个应用程序是公用的，例如你在App.xaml文件中，添\n加了〈Application，Resources〉</Application.Resources>元素来定义一些资源文件或者样式，这些资源在整个应用程序的所有页面都可以引用，而在Page的页画所定义的资源或者控件就只能否在当前的页面使用。\n###  App.xaml.cs\n```cs\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Runtime.InteropServices.WindowsRuntime;\nusing Windows.ApplicationModel;\nusing Windows.ApplicationModel.Activation;\nusing Windows.Foundation;\nusing Windows.Foundation.Collections;\nusing Windows.UI.Xaml;\nusing Windows.UI.Xaml.Controls;\nusing Windows.UI.Xaml.Controls.Primitives;\nusing Windows.UI.Xaml.Data;\nusing Windows.UI.Xaml.Input;\nusing Windows.UI.Xaml.Media;\nusing Windows.UI.Xaml.Navigation;\n\nnamespace HelloWorld\n{\n    /// <summary>\n    /// 提供特定于应用程序的行为，以补充默认的应用程序类。\n    /// </summary>\n    sealed partial class App : Application\n    {\n        /// <summary>\n        /// 初始化单一实例应用程序对象。这是执行的创作代码的第一行，\n        /// 已执行，逻辑上等同于 main() 或 WinMain()。\n        /// </summary>\n        public App()\n        {\n            this.InitializeComponent();\n            this.Suspending += OnSuspending;\n        }\n\n        /// <summary>\n        /// 在应用程序由最终用户正常启动时进行调用。\n        /// 将在启动应用程序以打开特定文件等情况下使用。\n        /// </summary>\n        /// <param name=\"e\">有关启动请求和过程的详细信息。</param>\n        protected override void OnLaunched(LaunchActivatedEventArgs e)\n        {\n            Frame rootFrame = Window.Current.Content as Frame;\n\n            // 不要在窗口已包含内容时重复应用程序初始化，\n            // 只需确保窗口处于活动状态\n            if (rootFrame == null)\n            {\n                // 创建要充当导航上下文的框架，并导航到第一页\n                rootFrame = new Frame();\n\n                rootFrame.NavigationFailed += OnNavigationFailed;\n\n                if (e.PreviousExecutionState == ApplicationExecutionState.Terminated)\n                {\n                    //TODO: 从之前挂起的应用程序加载状态\n                }\n\n                // 将框架放在当前窗口中\n                Window.Current.Content = rootFrame;\n            }\n\n            if (e.PrelaunchActivated == false)\n            {\n                if (rootFrame.Content == null)\n                {\n                    // 当导航堆栈尚未还原时，导航到第一页，\n                    // 并通过将所需信息作为导航参数传入来配置\n                    // 参数\n                    rootFrame.Navigate(typeof(MainPage), e.Arguments);\n                }\n                // 确保当前窗口处于活动状态\n                Window.Current.Activate();\n            }\n        }\n\n        /// <summary>\n        /// 导航到特定页失败时调用\n        /// </summary>\n        ///<param name=\"sender\">导航失败的框架</param>\n        ///<param name=\"e\">有关导航失败的详细信息</param>\n        void OnNavigationFailed(object sender, NavigationFailedEventArgs e)\n        {\n            throw new Exception(\"Failed to load Page \" + e.SourcePageType.FullName);\n        }\n\n        /// <summary>\n        /// 在将要挂起应用程序执行时调用。  在不知道应用程序\n        /// 无需知道应用程序会被终止还是会恢复，\n        /// 并让内存内容保持不变。\n        /// </summary>\n        /// <param name=\"sender\">挂起的请求的源。</param>\n        /// <param name=\"e\">有关挂起请求的详细信息。</param>\n        private void OnSuspending(object sender, SuspendingEventArgs e)\n        {\n            var deferral = e.SuspendingOperation.GetDeferral();\n            //TODO: 保存应用程序状态并停止任何后台活动\n            deferral.Complete();\n        }\n    }\n}\n```\n&#160;&#160;&#160;&#160;App.xaml.cs 文件是一个控制整个应用程序的全局文件，整个应用程序的生命周期都在该文件中定义和处理。应用程序在整个生命周期会有三个状态：Running（运行），NotRunning（未运行）和 Suspended（挂起）\n![应用程序生命周期](http://oskhhyaq3.bkt.clouddn.com/blog/170710/DmKlm3EJ1b.png?imageslim)\n### Package.appxmanifest文件\n```xml\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<Package\n  xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:mp=\"http://schemas.microsoft.com/appx/2014/phone/manifest\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\"\n  IgnorableNamespaces=\"uap mp\">\n\n  <Identity\n    Name=\"f85505e4-25a4-4f06-b489-dfc4750ab693\"\n    Publisher=\"CN=Lovemefan\"\n    Version=\"1.0.0.0\" />\n\n  <mp:PhoneIdentity PhoneProductId=\"f85505e4-25a4-4f06-b489-dfc4750ab693\" PhonePublisherId=\"00000000-0000-0000-0000-000000000000\"/>\n\n  <Properties>\n    <DisplayName>HelloWorld</DisplayName>\n    <PublisherDisplayName>Lovemefan</PublisherDisplayName>\n    <Logo>Assets\\StoreLogo.png</Logo>\n  </Properties>\n\n  <Dependencies>\n    <TargetDeviceFamily Name=\"Windows.Universal\" MinVersion=\"10.0.0.0\" MaxVersionTested=\"10.0.0.0\" />\n  </Dependencies>\n\n  <Resources>\n    <Resource Language=\"x-generate\"/>\n  </Resources>\n\n  <Applications>\n    <Application Id=\"App\"\n      Executable=\"$targetnametoken$.exe\"\n      EntryPoint=\"HelloWorld.App\">\n      <uap:VisualElements\n        DisplayName=\"HelloWorld\"\n        Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n        Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n        Description=\"HelloWorld\"\n        BackgroundColor=\"transparent\">\n        <uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/>\n        <uap:SplashScreen Image=\"Assets\\SplashScreen.png\" />\n      </uap:VisualElements>\n    </Application>\n  </Applications>\n\n  <Capabilities>\n    <Capability Name=\"internetClient\" />\n  </Capabilities>\n</Package>\n```\n&#160;&#160;&#160;&#160;Package.appxmanifest文件是Windows 10应用程序的清单文件，声明应用的标识、应\n用的功能以及用来进行部署和更新的信息。可以在清单文件对当前的应用程序进行配置，\n例如添加磁帖图像和初始屏幕、指示应用支持的方向以及定义应用的功能种类、Package \n元素是整个清单的根节点；Identity元素表示应用程序版本发布者名称等信息mp: \nPhoneldentity元素表示应用程序相关的唯一标识符信息Properties元素包含了应用程序\n的名称、发布者名称等信息的设置；Prerequisites元素则是用于设置应用程序所支持的系\n统版本号；Resources元素表示应用程序所使用资源信息，例如语言资源Applications元\n素里面则包含了与应用程序相关的logo设置、闪屏图片设置等可视化的设置信息\nCapabilities元素表示当前应用程序所使用的一些手机特定功能，例如internetclient表示\n使用网络的功能。\n\n&#160;&#160;&#160;&#160;Page.appxmanifest文件可以支持在可视化图形中进行设置，可以双击解决方案中\n的package.appxmanifest文件来打开此文件的可视化编辑视图。我们可以直接在可视化界\n面上设置程序的logo、磁贴、功能权限等。在后续的应用程序开发里面有些功能会需要在\nPackage.appxmanifest清单文件上进行相关的配置，到时候再进行详细的讲解。\n\n\n\n## 不同平台设备的适配\n\n&#160;&#160;&#160;&#160;Windows 10通用应用程序针对特定的平台还会有一个子API的集合，当我们要使用\n到某个平台的特定API的时候(例如手机相机硬件按钮触发事件)，这时候就需要调用特定\n平台的API.因为Winclows 10应用程序是一个安装包，可以部署到所有的Windows 10系\n统平台，所以这里就涉及一个八PI适配的问题，对特定平台的API进行特殊处理。除了特\n定平台的API,还有一个适配的工作就是界面适配，Windows 10也提供了一系列的API来\n给我们做界面的适配工作。\n\n###特定平台的API调用\n\n&#160;&#160;&#160;&#160;目前在Winclows 10里面有Windows Mobile Extension SDK和田indows Desktop \nExtension SDK两个扩展的SDK分别表示手机版本和桌面版本的扩展SDK(在后面\n章节里面若用到特定平台的API,都会进行区分标识)。这两个SDK都是直接内置在\nWindows 10的开发SDK里面的，但是默认情况下不会给项目工程添加上，需要使用时可以\n在项目工程里面引用，路径为Project->Add Reference->-Windows Universal->Extensions. \n在使用特定平台的API的时候，必须判断当前的环境是否支持(不支持的平台调用将会引\n发异常)。判断的方法为Windows.Foundation.Metadata.ApiInformation.IsTypepresent \n(String type Name)，type Name表示带完整的命名空间的API的名称，返回true表示支持，\n返回false表示不支持。\n\n\n##界面适配\n&#160;&#160;&#160;&#160;Windows 10系统支持多种硬件平台和分辨率，Windows 10系统底层对界面的适配色\n昼非常强大的，同样的控件在不同的硬件平台上显示也可能会有差异，这种适配就是由\nWindows 10系统自己来完成适配，来匹配不同的硬件和分辨率的显示效果。虽然\nWindpws 10底层完成了各种控件的适配，但是很多时候还是需要在程序里来实现适配。在 \n开发通用程序的时候，要充分地考虑各种不同分辨率下的显示效果，可以通过可视化设计界\n面和各种分辨率的模拟器来进行测试。适配界面有几种常用的编程技巧\n* 使用相对的布局控件来进行排列，如Grid.Relativepanel等;\n* 使用相对的属性来设置控件在容器的位置，如orizontalAlignment.VerticalAlignment属性;\n* 设置长度宽度的最大值最小值限制;\n* 根据设备实际分辨率来设置长度宽度或者位置。\n\n\n\n","tags":["UWP"]},{"title":"UWP学习笔记 (一) 初识UWP","url":"/post/UWP学习笔记/什么是UWP/index.html  2017/07/08/UWP学习笔记/什么是UWP/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n认识UWP及开发前的一些准备\n<!-- more -->\n<The rest of contents | 余下全文>\n## 什么是UWP\n>UWP即Windows 10 中的Universal Windows Platform简称。即Windows通用应用平台，在Win 10 Mobile/Surface(Windows平板电脑）/PC/Xbox/HoloLens等平台上运行，uwp不同于传统pc上的exe应用也跟只适用于手机端的app有本质区别。它并不是为某一个终端而设计，而是可以在所有windows10设备上运行。\n微软在MWC 2015上首次展示了Win10统一平台战略的“代表作”：Win10通用应用（Windows10 Universal App）平台。在Win10中，所有设备将会运行在一个统一的Windows10系统核心之上。这样的设计使得一款应用可以在所有Win10设备上运行，今后Win10手机、平板电脑、笔记本电脑、PC、Xbox，甚至是3D全息眼镜HoloLens、巨屏触控Surface Hub和物联网设备例如Raspberry Pi 2等都不再有界限。新的通用平台允许新类型的Windows10通用应用真正实现一次编写、一套业务逻辑和统一的用户界面。应用在统一的Win10商店中将只会有一个安装包，而它将适用于所有Win10设备。[1]  在 Windows 10 Insider Preview 中的 Universal Windows Platform (UWP)借助 Windows 10 UWP 将在 Windows 应用中更上一层楼。UWP 会根据不同的设备类型使用相应的自适应 UI 控件，并使用运行 Windows 10 Insider Preview 的所有设备上必须具有的通用 API 集。简单的说，uwp就是通用应用的意思可以在电脑端，手机端，或其他设备通用。不用分别为不同的平台设计不同的软件。即一个软件就可以通吃。这是微软为win10系统定制的趋势。微软声称不管是开发者，还是使用者，都省事。   --百度百科\n\n首先来欣赏一下国内一些比较用心的UWP\n**网易云音乐**\n![网易云音乐](http://oskhhyaq3.bkt.clouddn.com/blog/170708/HJG2J760dA.png?imageslim)\n\n**IT之家**\n![IT之家](http://oskhhyaq3.bkt.clouddn.com/blog/170708/A65Aa9ECm6.png?imageslim)\n### 如何获取UWP\n* 1.从Window 应用商店获取。打开应用商店，搜索并选择下载。\n* 2.[离线部署](https://www.windows10.pro/how-to-install-uwp-offline-packages)\n## 开发准备\n* 开发环境：Windows 10 +Visual Studio 2015/2017    这里说明必须是**Windows 10 **，其他不行。VS 2015及以上才支持UWP开发，所以只能用VS 2015或2017。我目前的环境是 Win10 创意者 + VS 2017。\n* 开发者模式。前往 设置-更新与安全-针对开发者-开发者模式\n* 技术储备 C#/C++/VB 后期我们将使用C#进行开发程序的逻辑部分 [C#微软官方教程（有中文字幕）](http://bit.do/csharp-fundamentals)\n* XAML(EXtensible Application Markup Language)。XAML是一种类似HTML的标记语言。用来设计UI部分后面会着重学习XAML语言。如果是有HTML基础的同学会很容易上手。\n## 总结\n我对windows Phone有一种特有的情怀，从之前的Windows Phone 7 开始，我就喜欢Windows Phone上了其流畅顺滑的操作。到后来的Windows 10 mobile 。由于其软件生态太差，无法满足生活需求，我才不得不转向Android阵营。以前Android的卡慢是我无法忍受的，但随着Android 6.0/7.0，即将发布的Android 8.0，Android慢慢优化的系统也能适应大部分人的需求。Android，iOS是大势所趋，我为什么还要选择UWP这种有些人听都没听过的平台呢？\n* 首先，我看重的是UWP的优势，一次编译，能在所有Win 10 设备运行，包括电脑、平板、手机(Win10 手机)、XBox、HoloLens、surface Hub、loT(物联网)。微软费尽心思推广Win10，就是为了增加UWP的运行环境。现在及未来Win10的装机量不容小视。而且UWP小巧轻便，前途无可限量。\n* 其次，UWP有着自己的类似Google Play和Apple Store的应用商店，保证其安全性。\n* 然后，我想尽自己一份微薄力量来完善Windows 生态，主要还是Windows phone的生态。\n## 学习资料\n* UWP微软官方学习课程 [官方MVA]]() [bilibili搬运](http://www.bilibili.com/video/av7997007/)\nMicrosoft Virtual Academy (MVA)   [【链接】](https://mva.microsoft.com/)是微软官方的一个免费的视频教学课堂。里面有大量的学习资源(有中文字幕)，强烈推荐。\n* 深出浅入UWP （中文课程）[【bilibili】](http://www.bilibili.com/video/av3610677)","tags":["UWP"]},{"title":"PowerShell篇 (一) 初识PowerShell","url":"/post/PowerShsell/PowerShell篇  (一)初识PowerShell/index.html  2017/07/05/PowerShsell/PowerShell篇  (一)初识PowerShell/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n什么是PowerShell\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 初识PowerShell\n`作者：lovemefan` `以下资料收集于IT之家和知乎`\n## PowerShell的邂逅\n&#160;&#160;&#160;&#160;在我搭建我的博客的时候，cmd命令肯定是少不了的。除了cmd我们还可以选择Git Bash和PowerShell。\nGit Bash是Git自带的一个命令行工具，用来上传，克隆等一些GitHub的操作。我之前也只知道Power Shell也是命令行，用它部署过离线的[UWP](http://baike.baidu.com/link?url=J5GeaQ_aSSMscd2pdx3O7nv1xTjZ99hw4ppIODqWFTtGFqHuxw13ppv9HviTZ8IglPkdRudcQb4-expkEoxC_a)，但平常不太会用所以没太在意。我只知道是微软为了替代cmd而特意在Windows 10里添加的新功能 。但在我使用Windows 10 创意者 的时候，正如往常使用鼠标右键+Shift ，本来是**“从此处打开命令窗口”**，结果就是没找到。反而这样显示\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/IKDe87048g.jpg?imageslim)\n后来发现这是微软故意而为之的\n## 什么是PowerShell\n>&#160;&#160;&#160;&#160;Windows PowerShell 是一种命令行外壳程序和脚本环境，使命令行用户和脚本编写者可以利用 .NET Framework的强大功能。\n&#160;&#160;&#160;&#160;它引入了许多非常有用的新概念，从而进一步扩展了您在 Windows 命令提示符和 Windows Script Host 环境中获得的知识和创建的脚本。\n&#160;&#160;&#160;&#160;Windows PowerShell v3将伴随着MicrosoftHyper-V3.0和Windows Server 2012发布。PowerShell v3是一个Windows任务自动化的框架，它由一个命令行shell和内置在这个.NET框架上的编程语言组成。\n&#160;&#160;&#160;&#160;PowerShell v3采用新的cmdlet让管理员能够更深入到系统进程中，这些进程可以制作成可执行的文件或脚本（script）。一条cmdlet是一条轻量命令，Windows PowerShell运行时间在自动化脚本的环境里调用它。Cmdlet包括显示当前目录的Get-Location，访问文件内容的Get-Content和结束运行进程的Stop-Process。\n&#160;&#160;&#160;&#160;PowerShell v3在Windows Server 8中装载了Windows Management Framework 3.0。PowerShell运行时间也能嵌入到其它应用。——百度百科\n\n[微软PowerShell官网](https://msdn.microsoft.com/en-us/powershell)\n\n&#160;&#160;&#160;&#160;从Windows10创意者更新开始，PowerShell正式上位替换了命令提示符CMD。不论是Windows+X右键超级菜单，还是Shift+文件夹空白处右键，又或在文件资源管理器文件菜单中，都没有命令提示符CMD的身影了，全部都由PowerShell取而代之了。长期使用CMD的Windows系统管理员或Windows命令行极客恐怕一时不能适应，使用CMD都只能去开始菜单-所有应用-Windows系统-命令提示符打开使用，或者Windows+R键然后输入cmd，或者在小娜输入框输入cmd，再或者在PowerShell中输入cmd(看来又绕回来了)。藏得这么深，显然是不想让人用了啊。不仅如此，Power Shell还登陆了Linux和MacOS  \n[在Linux下安装PowerShell](https://zhuanlan.zhihu.com/p/26346821?utm_source=qq&utm_medium=social)\nPoweShell上位图如下\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/bfiiJCEHd4.jpg?imageslim)\n&#160;&#160;&#160;&#160;问题来了，PowerShell这货凭什么力压CMD，强行上位？如果你之前试用过PowerShell，相信它一定没有给你什么好印象。打开慢！反应慢！命令还陌生！还动不动就弹一大堆谁都看不懂错误，PowerShell究竟凭什么在Windows10创意者更新中替代命令提示符CMD呢？微软脑抽了？\n微软没有脑抽，PowerShell是凭借其强大的功能替换CMD的。这里要先说明以下PowerShell究竟是什么东西，或者它究竟是不是东西？\n&#160;&#160;&#160;&#160;Windows PowerShell不是东西，它是专为系统管理员设计的新Windows命令行shell，它包括交互式提示和脚本环境。PowerShell定义很多命令与操作系统，特别是与文件系统交互，能够启动应用程序，甚至操纵应用程序；PowerShell允许将几个命令组合起来放到文件里执行，实现文件级的重用，也就是说有脚本的性质；PowerShell能够充分利用.Net类型和COM对象，来简单地与各种系统交互，完成各种复杂的、自动化的操作。\n&#160;&#160;&#160;&#160;用人话说就是CMD能做的PowerShell都能做，CMD不能做的Powershell也能做。就是这么自信！不信？赶紧打开PowerShell把下面的命令复制进去，看看它干了什么事，然后你用CMD做出来吧！\n```powershell\n# create new excel instance\n$objExcel = New-Object -comobject Excel.Application\n$objExcel.Visible = $True\n$objWorkbook = $objExcel.Workbooks.Add()\n$objWorksheet = $objWorkbook.Worksheets.Item(1)\n# write information to the excel file\n$i = 0\n$first10 = (ps | sort ws -Descending | select -first 10)\n$first10 | foreach -Process {$i++; $objWorksheet.Cells.Item($i,1) = $_.name; $objWorksheet.Cells.Item($i,2) = $_.ws}\n$otherMem = (ps | measure ws -s).Sum - ($first10 | measure ws -s).Sum\n$objWorksheet.Cells.Item(11,1) = \"Others\"; $objWorksheet.Cells.Item(11,2) = $otherMem\n# draw the pie chart\n$objCharts = $objWorksheet.ChartObjects()\n$objChart = $objCharts.Add(0, 0, 500, 300)\n$objChart.Chart.SetSourceData($objWorksheet.range(\"A1:B11\"), 2)\n$objChart.Chart.ChartType = 70\n$objChart.Chart.ApplyDataLabels(5)\n```\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/CJi70f9ahF.png?imageslim)\n没错，有点慢，等下吧，接下来它自动打开了excel，如图，我果然还是IT之家老粉丝啊\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/B8IDAdFlm4.png?imageslim)\n&#160;&#160;&#160;&#160;上面一段代码是PowerShell界常见的一段神代码，很多初学者被其带入了PowerShell的大门。有效代码不过20来行，作用是把当前系统中最占内存的10个进程的数据发送到Excel中，并绘制成三维饼图。CMD是很难做到了，被替代也理所应当了。\n&#160;&#160;&#160;&#160;PowerShell的定位是操作系统和应用程序的管理工具，从这个角度看，它是CMD的升级版，并非简单的对CMD进行扩展，事实上微软也不打算扩展和升级CMD了，以后PowerShell将全方位的替代CMD，目前CMD和PowerShell还是并存状态。\n下面正式介绍PowerShell。\n### （一）简单的命令\n&#160;&#160;&#160;&#160;在CMD中，命令是从非常简单（如attrib.exe）到非常复杂（如netsh.exe）的可执行程序，新入门用户一旦遇到复杂命令，只能束手无策，只能求助搜索引擎，解决当前需求之后，就把命令的用法抛诸脑后，下次使用又要重新学习，极其不便。\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/526ijlFjLJ.png?imageslim)\n&#160;&#160;&#160;&#160;PowerShell命令设计非常规范，它的命令由“动词”和“名词”两部分组成，比如“get”表示检索数据，“process”表示系统进程，把“get”和“process”组合起来的PowerShell命令就是“get-process”，意思是获取系统进程列表，这种命令在PowerShell中称为“cmdlet（读作“command-let”）”。\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/CIBlH2i1f7.png?imageslim)\n&#160;&#160;&#160;&#160;使用“动词-名词”结构还有一个好处，就是不同的“动词”和“名词”可以自由组合，很少的几个“动词”和“名词”就可以组合出大量的可用命令，使命令记忆量大为降低，只需记住简单的几个词语，就可以使用大量的命令，这是包括命令提示符CMD在内的Shell不具备的，并且不会产生歧义，对新用户非常友好。\n### （二）别名系统\n&#160;&#160;&#160;&#160;“动词-名词”结构的cmdlet固然对新手友好，但也带来了另一个问题，命令名称过长，在命令行交互使用时不方便，在命令行窗口输入命令可以使用Tab键进行补全，可是经常使用还是需要键入大量的内容，要是能够把命令缩短一些就好了。PowerShell在设计时已经考虑到了，为此创建了别名系统，之所以叫名别系统，是因为PowerShell中的别名非常强大，能够非常方便的对别名进行增加、删除、修改，还为之创建了别名驱动器，可以像访问文件系统驱动器一样方便的访问别名驱动器。\nPowerShell非常贴心的为用户创建了大量内置别名，一方面减少了常用命令的输入长度，另一方面也为熟悉其它Shell而不熟悉PowerShell的用户提供了方便，常见Shell如bash、cmd，PowerShell都为用户提供了他们熟悉的别名。下面是可以在Powershell中使用的通用的Cmd.exe和UNIX命令的简短列表。\n**在PowerShell下输入**\n```powershell\nget-alias\n```\n以下只显示了部分，要想查询所有别名请用`alias`命令查询\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/6AghbjEgAg.png?imageslim)\n&#160;&#160;&#160;&#160;PowerShell除了自带别名外，用户自己也可以创建别名，不仅仅可以为cmdlet创建别名，也可以为PowerShell函数、带参数的命令和包含完整路径的命令行程序创建别名。\n比如为记事本创建别名，可以使用如下命令\n```powershell\nNew-Alias np c:\\windows\\notepad.exe\n```\n&#160;&#160;&#160;&#160;创建别名完成后，在命令行中输入np就能直接打开记事本。在命令行中创建的别名只能在当前命令行窗口中使用，如果想以后也能使用此别名，可以把以上命令保存在PowerShell配置文件中，以后无论是在命令行中，还是使用脚本，都可以在本机使用np别名了。\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/8h0kd2FD21.png?imageslim)\nPowrShell配置文件位置可以使用$profile命令查询。\n\n&#160;&#160;&#160;&#160;想查看当前命令行窗口可以使用的别名，可以进入别名驱动器查看，使用dir alias:就能查看所有能用的别名，也可以使用get-alias命令查看别名。\n### (三) 管理任务\nWindows PowerShell的基本目标是使用户能够以交互方式或通过脚本更好、更容易地对系统进行管理控制，为了达成这个目标，PowerShell提供了大量命令来执行各种管理任务，让用户轻松完成管理系统任务。\n#### 1、管理进程\n前面已经提过管理系统进程的命令，管理进程常用命令就是get-process命令和stop-process命令，get-process命令获取进程之后可以直接用管道发送给stop-process命令结束进程。比如，关闭之前打开的记事本，可以使用下面的命令很方便的关闭记事本。\n```powershell\nget-process -Name notepad | stop-process\n```\n#### 2、处理文件和文件夹\n&#160;&#160;&#160;&#160;PowerShell使用Get-ChildItem获取文件夹中直接包含的所有项，它有系统内置别名dir和ls，使用CMD和BASH的用户均可以轻松上手。如果想查看C:中的文件夹和文件，直接使用dir c:，PowerShell立刻就会列出C:中的文件和文件夹。其它处理文件和文件夹的命令有Copy-Item、New-Item、Remove-Item等，具体用法可以使用get-help然后跟命令名称即可查询。\n#### 3、处理系统服务\n&#160;&#160;&#160;&#160;可以像管理进程一样管理系统服务，Get-Service命令获取服务列表，Stop-Service命令停止服务，Start-Service命令启动服务，Suspend-Service命令挂起服务，Restart-Service命令重启服务，Set-Service服务设置服务属性。如果想一次性启动已经停止的服务，可以使用以下命令：\n```powershell\nget-service | where-object {$_.Status -eq \"Stopped\"} -exclude\nwisvc | start-service\n```\n&#160;&#160;&#160;&#160;这行命名会把除wisvc之外的命令都启动，这只是一个示例，不要在自己电脑使用，启动所有服务会消耗大量系统资源。\n#### 4、处理注册表\n&#160;&#160;&#160;&#160;PowerShell可以非常方便的处理注册表项目，与进程和服务不同的是，PowerShell并未提供专用的注册表命令，而是使用处理文件和文件夹的命令，这并不奇怪，PowerShell为用户提供了注册表驱动器，可以很好的处理注册表项目。由于注册表对系统非常重要，错误处理注册表也许会导致系统出问题，处理注册表，特别是删除注册表项目要非常小心，最好能在处理注册表项目之前先备份要处理的项目。没有管理员权限也能处理部分注册表项目，这与regedit注册表编辑器不同，注册表编辑器必须使用管理员权限打开，然后才能操作项目。\n**下面的表格列出了访问注册表所需的所有命令**\n\n![mark](http://oskhhyaq3.bkt.clouddn.com/blog/170705/LcIe6FFlJ4.png?imageslim)\nPowerShell只提供了两个注册表驱动器HKCU:和HKLM:，其中HKLM:是HKEY_LOCAL_MACHINE的缩写，HKCU:是HKEY_CURRENT_USER的缩写，如果想要访问所有注册表驱动器，可以进入Microsoft.PowerShell.Core\\Registry::。\n#### 5、处理其它任务\nPowerShell还可以处理证书、防火墙、appx应用、打印机等任务。大家可以使用get-command命令查找相关命令。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["PowerShell"]},{"title":"我为什么要建立这个博客","url":"/post/为什么要建立这个博客/index.html  2017/07/04/为什么要建立这个博客/","content":"** {{ title }}：** <Excerpt in index | 首页摘要>\n建立博客的原因\n<!-- more -->\n<The rest of contents | 余下全文>\n\n# 为什么要建立这个博客\n`作者：lovemefan`  [我的GitHub](www.github.com/lovemefan)\n\n>  &#160; &#160;&#160; &#160;我现在是一名即将大三的软件的学生。对编程还谈得上热爱，但至今也只能承认懂得点皮毛。为什么我要写这个博客？根本原因还是“懒”。我需要一个能够鞭策我一直坚持下去的东西。不过我也承认有一点点装B的嫌疑。我个人性格有点不羁，不喜欢按部就班，墨守成规。总想着做点疯狂的事。兴趣与时间总是矛盾的，可是时间又是从海绵里挤出来的。想想大一大二就这样“嗖”一般的过掉了...掉了...了。东西没学到多少，时间就快没了。看到有的同学能做一个看起来就很牛逼的程序，然后讲一堆从来没听过的专业术语。“卧槽！卧槽！！！”，“厉害了，我的哥”，“哇，大神，带我飞”，像这样的话没少听。一般这种时候我都会嫉妒一下。“TM为什么我不会”，“不过，不会也正常，我TM又不是神”，“妈蛋，下次去学，嗯！一定要学会”，“好像也就这样了，先放一放吧”。大多数情况下这件事就被无限延期了。\n  &#160; &#160;&#160; &#160;首先，我总结了一个原因——懒。这种东西确实是人类的天敌，当然不排除某些勤奋已经成了日常的hentai。我有一些类似的经历，写作业写到两三点停不下来，还像打了鸡血一样很兴奋，鬼知道发生了什么。最长的一次在图书馆呆了13多个小时，从早上8点到晚上9点半，丝毫不想走。这种接近痴狂的人生，我个人觉得还蛮不错的。但是，但是，但是我又双叒叕被懒惰打败了，一不小心就荒废了下学业。结果就是期末成绩无情的嘲讽。懒惰这东西迟早，一定，必须面对。所以我觉得有必要做些事情，比如维护这博客。\n &#160; &#160;&#160; &#160;其次，我吐槽下大学现在这个机制不是我想要的。大学也读了一半了，大多数人是这么过的：“上课可以不听，下课我看一下就好了。”，“这题好像老师讲过，不过我忘了。”“学习，学个屁”，“这次考试考哪些重点，帮我画一下”，“最后一个礼拜复习，祈祷不挂”，“复习什么，大家一起挂”，“成绩出来了，吐血，80多”（MD，老子一巴掌。。。）。然而结果不是我所期望的。考试这种东西确实是有存在的必要，但现在的考试总感觉变了味。老师说什么会考，就考什么，可能还是去年的原题。只要刷几套往年试卷，就可以考得很好，于是更多的人在钻研怎么“考试”，而不是解决问题。两年下来，你是更擅长考试，还是更擅长你的专业知识。我非常敬佩那些不以考试为目的教学的老师。就比如说那个陈胖子（没事，他看不到），他上的Java和c语言数据结构还是很有分量的。\n &#160; &#160;&#160; &#160;假设大学四年我都这样过的话，满足吗？能力能提高多少呢？到底能学到多少东西呢？我现在可以C，C++，C#，Java，JavaScript，Matlab，Python...写一个Hello world，这样够吗?有人会说可以了，已经很不错了。可是野心不大一点，目标不远一点，不疯狂一点还是我的风格吗？现在还不疯狂一把，以后还有机会吗？你能保证未来不会因现在后悔吗？\n所以，我建立了在个博客，并且想维护它。我想多学点东西。现在的初心是既可以记录学习的点滴，也可以每时每刻都鞭策着我，因为每更新一次这个东西，就会得到一种“快感”，成就感。更新GitHub时也是一样。私心还是有的，当然希望被人关注了，肯定是越多越好了。\n\n## 博客的内容\n我尽量能写就多写，最近在知乎，CDNS，简书...中看到大量IT干货，激发了我极大的兴趣\n所以想着现在来建立这博客也不迟，算得上是学习了一种记录和鞭策吧\n* 一些学习过程中的问题，解决思路方法。\n* 我感兴趣的事物，可能以后会写测评。\n* GitHub，知乎,IT之家等 一些趣味知识。\n* 开发UWP。我曾经是一名wper（Lumia 1020），早在很久之前就打算学习UWP了，我希望能够坚持下去，尽管可能没有太多的时间和精力。就算是龟速更新，我也不会停止学习的。\n## 计划列表\n* UWP，Android，web(大三必修)\n* UE4(虚幻4)，unity  (项目所需和个人兴趣爱好)\n* 学些脚本语言，待定：PowerShell，JavaScript等\n* 待定"}]